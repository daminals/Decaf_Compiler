Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BOOL
    DO
    DOUBLE
    ERROR
    LBRACKET
    RBRACKET
    float_const
    int_const
    string_const

Grammar

Rule 0     S' -> start
Rule 1     start -> class_decl
Rule 2     class_decl -> CLASS ID LCURLY class_body RCURLY
Rule 3     class_decl -> CLASS ID EXTENDS ID LCURLY class_body RCURLY
Rule 4     class_body -> field_decl
Rule 5     class_body -> method_decl
Rule 6     class_body -> constructor_decl
Rule 7     class_body -> class_body field_decl
Rule 8     class_body -> class_body method_decl
Rule 9     class_body -> class_body constructor_decl
Rule 10    class_body -> empty
Rule 11    field_decl -> modifier var_decl
Rule 12    modifier -> PUBLIC
Rule 13    modifier -> PRIVATE
Rule 14    modifier -> PUBLIC STATIC
Rule 15    modifier -> PRIVATE STATIC
Rule 16    modifier -> empty
Rule 17    var_decl -> type variables SEMICOLON
Rule 18    type -> INT
Rule 19    type -> FLOAT
Rule 20    type -> BOOLEAN
Rule 21    type -> ID
Rule 22    variables -> variable
Rule 23    variables -> variable COMMA variables
Rule 24    variable -> ID
Rule 25    method_decl -> modifier type ID LPAREN RPAREN block
Rule 26    method_decl -> modifier type ID LPAREN formals RPAREN block
Rule 27    method_decl -> modifier VOID ID LPAREN RPAREN block
Rule 28    method_decl -> modifier VOID ID LPAREN formals RPAREN block
Rule 29    constructor_decl -> modifier ID block
Rule 30    constructor_decl -> modifier ID formals block
Rule 31    formals -> formal_param
Rule 32    formals -> formal_param COMMA formals
Rule 33    formal_param -> type variable
Rule 34    block -> LCURLY stmt RCURLY
Rule 35    block -> empty
Rule 36    stmt -> IF LPAREN expression RPAREN stmt
Rule 37    stmt -> IF LPAREN expression RPAREN stmt ELSE stmt
Rule 38    stmt -> WHILE LPAREN expression RPAREN stmt
Rule 39    stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
Rule 40    stmt -> RETURN expression SEMICOLON
Rule 41    stmt -> RETURN SEMICOLON
Rule 42    stmt -> stmt_expression SEMICOLON
Rule 43    stmt -> BREAK SEMICOLON
Rule 44    stmt -> CONTINUE SEMICOLON
Rule 45    stmt -> block
Rule 46    stmt -> var_decl
Rule 47    stmt -> SEMICOLON
Rule 48    literal -> INTEGER
Rule 49    literal -> FLOAT
Rule 50    literal -> STRING
Rule 51    literal -> NULL
Rule 52    literal -> FALSE
Rule 53    literal -> TRUE
Rule 54    primary -> literal
Rule 55    primary -> THIS
Rule 56    primary -> SUPER
Rule 57    primary -> LPAREN expression RPAREN
Rule 58    primary -> NEW ID
Rule 59    primary -> NEW ID LPAREN arguments RPAREN
Rule 60    primary -> method_invocation
Rule 61    primary -> lhs
Rule 62    arguments -> expression
Rule 63    arguments -> expression COMMA arguments
Rule 64    lhs -> field_access
Rule 65    field_access -> primary DOT ID
Rule 66    field_access -> ID
Rule 67    method_invocation -> field_access LPAREN arguments RPAREN
Rule 68    method_invocation -> field_access LPAREN RPAREN
Rule 69    expression -> primary
Rule 70    expression -> assign
Rule 71    expression -> expression arith_op expression
Rule 72    expression -> expression bool_op expression
Rule 73    expression -> unary_op expression
Rule 74    assign -> lhs SETEQUAL expression
Rule 75    arith_op -> PLUS
Rule 76    arith_op -> MINUS
Rule 77    arith_op -> TIMES
Rule 78    arith_op -> DIVIDE
Rule 79    bool_op -> GREATER
Rule 80    bool_op -> LESS
Rule 81    bool_op -> GREATEREQ
Rule 82    bool_op -> LESSEQ
Rule 83    bool_op -> EQUAL
Rule 84    bool_op -> NOTEQUAL
Rule 85    bool_op -> AND
Rule 86    bool_op -> OR
Rule 87    unary_op -> PLUS
Rule 88    unary_op -> MINUS
Rule 89    unary_op -> NOT
Rule 90    stmt_expression -> assign
Rule 91    stmt_expression -> method_invocation
Rule 92    empty -> <empty>

Terminals, with rules where they appear

AND                  : 85
BOOL                 : 
BOOLEAN              : 20
BREAK                : 43
CLASS                : 2 3
COMMA                : 23 32 63
CONTINUE             : 44
DIVIDE               : 78
DO                   : 
DOT                  : 65
DOUBLE               : 
ELSE                 : 37
EQUAL                : 83
ERROR                : 
EXTENDS              : 3
FALSE                : 52
FLOAT                : 19 49
FOR                  : 39
GREATER              : 79
GREATEREQ            : 81
ID                   : 2 3 3 21 24 25 26 27 28 29 30 58 59 65 66
IF                   : 36 37
INT                  : 18
INTEGER              : 48
LBRACKET             : 
LCURLY               : 2 3 34
LESS                 : 80
LESSEQ               : 82
LPAREN               : 25 26 27 28 36 37 38 39 57 59 67 68
MINUS                : 76 88
NEW                  : 58 59
NOT                  : 89
NOTEQUAL             : 84
NULL                 : 51
OR                   : 86
PLUS                 : 75 87
PRIVATE              : 13 15
PUBLIC               : 12 14
RBRACKET             : 
RCURLY               : 2 3 34
RETURN               : 40 41
RPAREN               : 25 26 27 28 36 37 38 39 57 59 67 68
SEMICOLON            : 17 39 39 40 41 42 43 44 47
SETEQUAL             : 74
STATIC               : 14 15
STRING               : 50
SUPER                : 56
THIS                 : 55
TIMES                : 77
TRUE                 : 53
VOID                 : 27 28
WHILE                : 38
error                : 
float_const          : 
int_const            : 
string_const         : 

Nonterminals, with rules where they appear

arguments            : 59 63 67
arith_op             : 71
assign               : 70 90
block                : 25 26 27 28 29 30 45
bool_op              : 72
class_body           : 2 3 7 8 9
class_decl           : 1
constructor_decl     : 6 9
empty                : 10 16 35
expression           : 36 37 38 39 40 57 62 63 71 71 72 72 73 74
field_access         : 64 67 68
field_decl           : 4 7
formal_param         : 31 32
formals              : 26 28 30 32
lhs                  : 61 74
literal              : 54
method_decl          : 5 8
method_invocation    : 60 91
modifier             : 11 25 26 27 28 29 30
primary              : 65 69
start                : 0
stmt                 : 34 36 37 37 38 39
stmt_expression      : 39 39 42
type                 : 17 25 26 33
unary_op             : 73
var_decl             : 11 46
variable             : 22 23 33
variables            : 17 23

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . class_decl
    (2) class_decl -> . CLASS ID LCURLY class_body RCURLY
    (3) class_decl -> . CLASS ID EXTENDS ID LCURLY class_body RCURLY

    CLASS           shift and go to state 3

    start                          shift and go to state 1
    class_decl                     shift and go to state 2

state 1

    (0) S' -> start .



state 2

    (1) start -> class_decl .

    $end            reduce using rule 1 (start -> class_decl .)


state 3

    (2) class_decl -> CLASS . ID LCURLY class_body RCURLY
    (3) class_decl -> CLASS . ID EXTENDS ID LCURLY class_body RCURLY

    ID              shift and go to state 4


state 4

    (2) class_decl -> CLASS ID . LCURLY class_body RCURLY
    (3) class_decl -> CLASS ID . EXTENDS ID LCURLY class_body RCURLY

    LCURLY          shift and go to state 5
    EXTENDS         shift and go to state 6


state 5

    (2) class_decl -> CLASS ID LCURLY . class_body RCURLY
    (4) class_body -> . field_decl
    (5) class_body -> . method_decl
    (6) class_body -> . constructor_decl
    (7) class_body -> . class_body field_decl
    (8) class_body -> . class_body method_decl
    (9) class_body -> . class_body constructor_decl
    (10) class_body -> . empty
    (11) field_decl -> . modifier var_decl
    (25) method_decl -> . modifier type ID LPAREN RPAREN block
    (26) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (27) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (28) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (29) constructor_decl -> . modifier ID block
    (30) constructor_decl -> . modifier ID formals block
    (92) empty -> .
    (12) modifier -> . PUBLIC
    (13) modifier -> . PRIVATE
    (14) modifier -> . PUBLIC STATIC
    (15) modifier -> . PRIVATE STATIC
    (16) modifier -> . empty

  ! shift/reduce conflict for PUBLIC resolved as shift
  ! shift/reduce conflict for PRIVATE resolved as shift
    RCURLY          reduce using rule 92 (empty -> .)
    VOID            reduce using rule 92 (empty -> .)
    ID              reduce using rule 92 (empty -> .)
    INT             reduce using rule 92 (empty -> .)
    FLOAT           reduce using rule 92 (empty -> .)
    BOOLEAN         reduce using rule 92 (empty -> .)
    PUBLIC          shift and go to state 13
    PRIVATE         shift and go to state 14

  ! PUBLIC          [ reduce using rule 92 (empty -> .) ]
  ! PRIVATE         [ reduce using rule 92 (empty -> .) ]

    class_body                     shift and go to state 7
    field_decl                     shift and go to state 8
    method_decl                    shift and go to state 9
    constructor_decl               shift and go to state 10
    empty                          shift and go to state 11
    modifier                       shift and go to state 12

state 6

    (3) class_decl -> CLASS ID EXTENDS . ID LCURLY class_body RCURLY

    ID              shift and go to state 15


state 7

    (2) class_decl -> CLASS ID LCURLY class_body . RCURLY
    (7) class_body -> class_body . field_decl
    (8) class_body -> class_body . method_decl
    (9) class_body -> class_body . constructor_decl
    (11) field_decl -> . modifier var_decl
    (25) method_decl -> . modifier type ID LPAREN RPAREN block
    (26) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (27) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (28) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (29) constructor_decl -> . modifier ID block
    (30) constructor_decl -> . modifier ID formals block
    (12) modifier -> . PUBLIC
    (13) modifier -> . PRIVATE
    (14) modifier -> . PUBLIC STATIC
    (15) modifier -> . PRIVATE STATIC
    (16) modifier -> . empty
    (92) empty -> .

    RCURLY          shift and go to state 16
    PUBLIC          shift and go to state 13
    PRIVATE         shift and go to state 14
    VOID            reduce using rule 92 (empty -> .)
    ID              reduce using rule 92 (empty -> .)
    INT             reduce using rule 92 (empty -> .)
    FLOAT           reduce using rule 92 (empty -> .)
    BOOLEAN         reduce using rule 92 (empty -> .)

    field_decl                     shift and go to state 17
    method_decl                    shift and go to state 18
    constructor_decl               shift and go to state 19
    modifier                       shift and go to state 12
    empty                          shift and go to state 20

state 8

    (4) class_body -> field_decl .

    RCURLY          reduce using rule 4 (class_body -> field_decl .)
    PUBLIC          reduce using rule 4 (class_body -> field_decl .)
    PRIVATE         reduce using rule 4 (class_body -> field_decl .)
    VOID            reduce using rule 4 (class_body -> field_decl .)
    ID              reduce using rule 4 (class_body -> field_decl .)
    INT             reduce using rule 4 (class_body -> field_decl .)
    FLOAT           reduce using rule 4 (class_body -> field_decl .)
    BOOLEAN         reduce using rule 4 (class_body -> field_decl .)


state 9

    (5) class_body -> method_decl .

    RCURLY          reduce using rule 5 (class_body -> method_decl .)
    PUBLIC          reduce using rule 5 (class_body -> method_decl .)
    PRIVATE         reduce using rule 5 (class_body -> method_decl .)
    VOID            reduce using rule 5 (class_body -> method_decl .)
    ID              reduce using rule 5 (class_body -> method_decl .)
    INT             reduce using rule 5 (class_body -> method_decl .)
    FLOAT           reduce using rule 5 (class_body -> method_decl .)
    BOOLEAN         reduce using rule 5 (class_body -> method_decl .)


state 10

    (6) class_body -> constructor_decl .

    RCURLY          reduce using rule 6 (class_body -> constructor_decl .)
    PUBLIC          reduce using rule 6 (class_body -> constructor_decl .)
    PRIVATE         reduce using rule 6 (class_body -> constructor_decl .)
    VOID            reduce using rule 6 (class_body -> constructor_decl .)
    ID              reduce using rule 6 (class_body -> constructor_decl .)
    INT             reduce using rule 6 (class_body -> constructor_decl .)
    FLOAT           reduce using rule 6 (class_body -> constructor_decl .)
    BOOLEAN         reduce using rule 6 (class_body -> constructor_decl .)


state 11

    (10) class_body -> empty .
    (16) modifier -> empty .

  ! reduce/reduce conflict for VOID resolved using rule 10 (class_body -> empty .)
  ! reduce/reduce conflict for ID resolved using rule 10 (class_body -> empty .)
  ! reduce/reduce conflict for INT resolved using rule 10 (class_body -> empty .)
  ! reduce/reduce conflict for FLOAT resolved using rule 10 (class_body -> empty .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 10 (class_body -> empty .)
    RCURLY          reduce using rule 10 (class_body -> empty .)
    PUBLIC          reduce using rule 10 (class_body -> empty .)
    PRIVATE         reduce using rule 10 (class_body -> empty .)
    VOID            reduce using rule 10 (class_body -> empty .)
    ID              reduce using rule 10 (class_body -> empty .)
    INT             reduce using rule 10 (class_body -> empty .)
    FLOAT           reduce using rule 10 (class_body -> empty .)
    BOOLEAN         reduce using rule 10 (class_body -> empty .)

  ! VOID            [ reduce using rule 16 (modifier -> empty .) ]
  ! ID              [ reduce using rule 16 (modifier -> empty .) ]
  ! INT             [ reduce using rule 16 (modifier -> empty .) ]
  ! FLOAT           [ reduce using rule 16 (modifier -> empty .) ]
  ! BOOLEAN         [ reduce using rule 16 (modifier -> empty .) ]


state 12

    (11) field_decl -> modifier . var_decl
    (25) method_decl -> modifier . type ID LPAREN RPAREN block
    (26) method_decl -> modifier . type ID LPAREN formals RPAREN block
    (27) method_decl -> modifier . VOID ID LPAREN RPAREN block
    (28) method_decl -> modifier . VOID ID LPAREN formals RPAREN block
    (29) constructor_decl -> modifier . ID block
    (30) constructor_decl -> modifier . ID formals block
    (17) var_decl -> . type variables SEMICOLON
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    VOID            shift and go to state 24
    ID              shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    BOOLEAN         shift and go to state 27

    var_decl                       shift and go to state 21
    type                           shift and go to state 22

state 13

    (12) modifier -> PUBLIC .
    (14) modifier -> PUBLIC . STATIC

    VOID            reduce using rule 12 (modifier -> PUBLIC .)
    ID              reduce using rule 12 (modifier -> PUBLIC .)
    INT             reduce using rule 12 (modifier -> PUBLIC .)
    FLOAT           reduce using rule 12 (modifier -> PUBLIC .)
    BOOLEAN         reduce using rule 12 (modifier -> PUBLIC .)
    STATIC          shift and go to state 28


state 14

    (13) modifier -> PRIVATE .
    (15) modifier -> PRIVATE . STATIC

    VOID            reduce using rule 13 (modifier -> PRIVATE .)
    ID              reduce using rule 13 (modifier -> PRIVATE .)
    INT             reduce using rule 13 (modifier -> PRIVATE .)
    FLOAT           reduce using rule 13 (modifier -> PRIVATE .)
    BOOLEAN         reduce using rule 13 (modifier -> PRIVATE .)
    STATIC          shift and go to state 29


state 15

    (3) class_decl -> CLASS ID EXTENDS ID . LCURLY class_body RCURLY

    LCURLY          shift and go to state 30


state 16

    (2) class_decl -> CLASS ID LCURLY class_body RCURLY .

    $end            reduce using rule 2 (class_decl -> CLASS ID LCURLY class_body RCURLY .)


state 17

    (7) class_body -> class_body field_decl .

    RCURLY          reduce using rule 7 (class_body -> class_body field_decl .)
    PUBLIC          reduce using rule 7 (class_body -> class_body field_decl .)
    PRIVATE         reduce using rule 7 (class_body -> class_body field_decl .)
    VOID            reduce using rule 7 (class_body -> class_body field_decl .)
    ID              reduce using rule 7 (class_body -> class_body field_decl .)
    INT             reduce using rule 7 (class_body -> class_body field_decl .)
    FLOAT           reduce using rule 7 (class_body -> class_body field_decl .)
    BOOLEAN         reduce using rule 7 (class_body -> class_body field_decl .)


state 18

    (8) class_body -> class_body method_decl .

    RCURLY          reduce using rule 8 (class_body -> class_body method_decl .)
    PUBLIC          reduce using rule 8 (class_body -> class_body method_decl .)
    PRIVATE         reduce using rule 8 (class_body -> class_body method_decl .)
    VOID            reduce using rule 8 (class_body -> class_body method_decl .)
    ID              reduce using rule 8 (class_body -> class_body method_decl .)
    INT             reduce using rule 8 (class_body -> class_body method_decl .)
    FLOAT           reduce using rule 8 (class_body -> class_body method_decl .)
    BOOLEAN         reduce using rule 8 (class_body -> class_body method_decl .)


state 19

    (9) class_body -> class_body constructor_decl .

    RCURLY          reduce using rule 9 (class_body -> class_body constructor_decl .)
    PUBLIC          reduce using rule 9 (class_body -> class_body constructor_decl .)
    PRIVATE         reduce using rule 9 (class_body -> class_body constructor_decl .)
    VOID            reduce using rule 9 (class_body -> class_body constructor_decl .)
    ID              reduce using rule 9 (class_body -> class_body constructor_decl .)
    INT             reduce using rule 9 (class_body -> class_body constructor_decl .)
    FLOAT           reduce using rule 9 (class_body -> class_body constructor_decl .)
    BOOLEAN         reduce using rule 9 (class_body -> class_body constructor_decl .)


state 20

    (16) modifier -> empty .

    VOID            reduce using rule 16 (modifier -> empty .)
    ID              reduce using rule 16 (modifier -> empty .)
    INT             reduce using rule 16 (modifier -> empty .)
    FLOAT           reduce using rule 16 (modifier -> empty .)
    BOOLEAN         reduce using rule 16 (modifier -> empty .)


state 21

    (11) field_decl -> modifier var_decl .

    RCURLY          reduce using rule 11 (field_decl -> modifier var_decl .)
    PUBLIC          reduce using rule 11 (field_decl -> modifier var_decl .)
    PRIVATE         reduce using rule 11 (field_decl -> modifier var_decl .)
    VOID            reduce using rule 11 (field_decl -> modifier var_decl .)
    ID              reduce using rule 11 (field_decl -> modifier var_decl .)
    INT             reduce using rule 11 (field_decl -> modifier var_decl .)
    FLOAT           reduce using rule 11 (field_decl -> modifier var_decl .)
    BOOLEAN         reduce using rule 11 (field_decl -> modifier var_decl .)


state 22

    (25) method_decl -> modifier type . ID LPAREN RPAREN block
    (26) method_decl -> modifier type . ID LPAREN formals RPAREN block
    (17) var_decl -> type . variables SEMICOLON
    (22) variables -> . variable
    (23) variables -> . variable COMMA variables
    (24) variable -> . ID

    ID              shift and go to state 31

    variables                      shift and go to state 32
    variable                       shift and go to state 33

state 23

    (29) constructor_decl -> modifier ID . block
    (30) constructor_decl -> modifier ID . formals block
    (21) type -> ID .
    (34) block -> . LCURLY stmt RCURLY
    (35) block -> . empty
    (31) formals -> . formal_param
    (32) formals -> . formal_param COMMA formals
    (92) empty -> .
    (33) formal_param -> . type variable
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

  ! reduce/reduce conflict for ID resolved using rule 21 (type -> ID .)
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    LCURLY          shift and go to state 37
    RCURLY          reduce using rule 92 (empty -> .)
    PUBLIC          reduce using rule 92 (empty -> .)
    PRIVATE         reduce using rule 92 (empty -> .)
    VOID            reduce using rule 92 (empty -> .)
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 34

  ! ID              [ reduce using rule 21 (type -> ID .) ]
  ! ID              [ reduce using rule 92 (empty -> .) ]
  ! INT             [ reduce using rule 92 (empty -> .) ]
  ! FLOAT           [ reduce using rule 92 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 92 (empty -> .) ]

    block                          shift and go to state 35
    formals                        shift and go to state 36
    empty                          shift and go to state 38
    formal_param                   shift and go to state 39
    type                           shift and go to state 40

state 24

    (27) method_decl -> modifier VOID . ID LPAREN RPAREN block
    (28) method_decl -> modifier VOID . ID LPAREN formals RPAREN block

    ID              shift and go to state 41


state 25

    (18) type -> INT .

    ID              reduce using rule 18 (type -> INT .)


state 26

    (19) type -> FLOAT .

    ID              reduce using rule 19 (type -> FLOAT .)


state 27

    (20) type -> BOOLEAN .

    ID              reduce using rule 20 (type -> BOOLEAN .)


state 28

    (14) modifier -> PUBLIC STATIC .

    VOID            reduce using rule 14 (modifier -> PUBLIC STATIC .)
    ID              reduce using rule 14 (modifier -> PUBLIC STATIC .)
    INT             reduce using rule 14 (modifier -> PUBLIC STATIC .)
    FLOAT           reduce using rule 14 (modifier -> PUBLIC STATIC .)
    BOOLEAN         reduce using rule 14 (modifier -> PUBLIC STATIC .)


state 29

    (15) modifier -> PRIVATE STATIC .

    VOID            reduce using rule 15 (modifier -> PRIVATE STATIC .)
    ID              reduce using rule 15 (modifier -> PRIVATE STATIC .)
    INT             reduce using rule 15 (modifier -> PRIVATE STATIC .)
    FLOAT           reduce using rule 15 (modifier -> PRIVATE STATIC .)
    BOOLEAN         reduce using rule 15 (modifier -> PRIVATE STATIC .)


state 30

    (3) class_decl -> CLASS ID EXTENDS ID LCURLY . class_body RCURLY
    (4) class_body -> . field_decl
    (5) class_body -> . method_decl
    (6) class_body -> . constructor_decl
    (7) class_body -> . class_body field_decl
    (8) class_body -> . class_body method_decl
    (9) class_body -> . class_body constructor_decl
    (10) class_body -> . empty
    (11) field_decl -> . modifier var_decl
    (25) method_decl -> . modifier type ID LPAREN RPAREN block
    (26) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (27) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (28) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (29) constructor_decl -> . modifier ID block
    (30) constructor_decl -> . modifier ID formals block
    (92) empty -> .
    (12) modifier -> . PUBLIC
    (13) modifier -> . PRIVATE
    (14) modifier -> . PUBLIC STATIC
    (15) modifier -> . PRIVATE STATIC
    (16) modifier -> . empty

  ! shift/reduce conflict for PUBLIC resolved as shift
  ! shift/reduce conflict for PRIVATE resolved as shift
    RCURLY          reduce using rule 92 (empty -> .)
    VOID            reduce using rule 92 (empty -> .)
    ID              reduce using rule 92 (empty -> .)
    INT             reduce using rule 92 (empty -> .)
    FLOAT           reduce using rule 92 (empty -> .)
    BOOLEAN         reduce using rule 92 (empty -> .)
    PUBLIC          shift and go to state 13
    PRIVATE         shift and go to state 14

  ! PUBLIC          [ reduce using rule 92 (empty -> .) ]
  ! PRIVATE         [ reduce using rule 92 (empty -> .) ]

    class_body                     shift and go to state 42
    field_decl                     shift and go to state 8
    method_decl                    shift and go to state 9
    constructor_decl               shift and go to state 10
    empty                          shift and go to state 11
    modifier                       shift and go to state 12

state 31

    (25) method_decl -> modifier type ID . LPAREN RPAREN block
    (26) method_decl -> modifier type ID . LPAREN formals RPAREN block
    (24) variable -> ID .

    LPAREN          shift and go to state 43
    COMMA           reduce using rule 24 (variable -> ID .)
    SEMICOLON       reduce using rule 24 (variable -> ID .)


state 32

    (17) var_decl -> type variables . SEMICOLON

    SEMICOLON       shift and go to state 44


state 33

    (22) variables -> variable .
    (23) variables -> variable . COMMA variables

    SEMICOLON       reduce using rule 22 (variables -> variable .)
    COMMA           shift and go to state 45


state 34

    (21) type -> ID .

    ID              reduce using rule 21 (type -> ID .)


state 35

    (29) constructor_decl -> modifier ID block .

    RCURLY          reduce using rule 29 (constructor_decl -> modifier ID block .)
    PUBLIC          reduce using rule 29 (constructor_decl -> modifier ID block .)
    PRIVATE         reduce using rule 29 (constructor_decl -> modifier ID block .)
    VOID            reduce using rule 29 (constructor_decl -> modifier ID block .)
    ID              reduce using rule 29 (constructor_decl -> modifier ID block .)
    INT             reduce using rule 29 (constructor_decl -> modifier ID block .)
    FLOAT           reduce using rule 29 (constructor_decl -> modifier ID block .)
    BOOLEAN         reduce using rule 29 (constructor_decl -> modifier ID block .)


state 36

    (30) constructor_decl -> modifier ID formals . block
    (34) block -> . LCURLY stmt RCURLY
    (35) block -> . empty
    (92) empty -> .

    LCURLY          shift and go to state 37
    RCURLY          reduce using rule 92 (empty -> .)
    PUBLIC          reduce using rule 92 (empty -> .)
    PRIVATE         reduce using rule 92 (empty -> .)
    VOID            reduce using rule 92 (empty -> .)
    ID              reduce using rule 92 (empty -> .)
    INT             reduce using rule 92 (empty -> .)
    FLOAT           reduce using rule 92 (empty -> .)
    BOOLEAN         reduce using rule 92 (empty -> .)

    block                          shift and go to state 46
    empty                          shift and go to state 38

state 37

    (34) block -> LCURLY . stmt RCURLY
    (36) stmt -> . IF LPAREN expression RPAREN stmt
    (37) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (38) stmt -> . WHILE LPAREN expression RPAREN stmt
    (39) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (40) stmt -> . RETURN expression SEMICOLON
    (41) stmt -> . RETURN SEMICOLON
    (42) stmt -> . stmt_expression SEMICOLON
    (43) stmt -> . BREAK SEMICOLON
    (44) stmt -> . CONTINUE SEMICOLON
    (45) stmt -> . block
    (46) stmt -> . var_decl
    (47) stmt -> . SEMICOLON
    (90) stmt_expression -> . assign
    (91) stmt_expression -> . method_invocation
    (34) block -> . LCURLY stmt RCURLY
    (35) block -> . empty
    (17) var_decl -> . type variables SEMICOLON
    (74) assign -> . lhs SETEQUAL expression
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (92) empty -> .
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (64) lhs -> . field_access
    (65) field_access -> . primary DOT ID
    (66) field_access -> . ID
    (54) primary -> . literal
    (55) primary -> . THIS
    (56) primary -> . SUPER
    (57) primary -> . LPAREN expression RPAREN
    (58) primary -> . NEW ID
    (59) primary -> . NEW ID LPAREN arguments RPAREN
    (60) primary -> . method_invocation
    (61) primary -> . lhs
    (48) literal -> . INTEGER
    (49) literal -> . FLOAT
    (50) literal -> . STRING
    (51) literal -> . NULL
    (52) literal -> . FALSE
    (53) literal -> . TRUE

    IF              shift and go to state 48
    WHILE           shift and go to state 50
    FOR             shift and go to state 51
    RETURN          shift and go to state 54
    BREAK           shift and go to state 55
    CONTINUE        shift and go to state 56
    SEMICOLON       shift and go to state 53
    LCURLY          shift and go to state 37
    RCURLY          reduce using rule 92 (empty -> .)
    INT             shift and go to state 25
    FLOAT           shift and go to state 64
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 65
    THIS            shift and go to state 68
    SUPER           shift and go to state 69
    LPAREN          shift and go to state 49
    NEW             shift and go to state 70
    INTEGER         shift and go to state 71
    STRING          shift and go to state 72
    NULL            shift and go to state 73
    FALSE           shift and go to state 74
    TRUE            shift and go to state 75

    stmt                           shift and go to state 47
    stmt_expression                shift and go to state 52
    block                          shift and go to state 57
    var_decl                       shift and go to state 58
    assign                         shift and go to state 59
    method_invocation              shift and go to state 60
    empty                          shift and go to state 38
    type                           shift and go to state 61
    lhs                            shift and go to state 62
    field_access                   shift and go to state 63
    primary                        shift and go to state 66
    literal                        shift and go to state 67

state 38

    (35) block -> empty .

    RCURLY          reduce using rule 35 (block -> empty .)
    PUBLIC          reduce using rule 35 (block -> empty .)
    PRIVATE         reduce using rule 35 (block -> empty .)
    VOID            reduce using rule 35 (block -> empty .)
    ID              reduce using rule 35 (block -> empty .)
    INT             reduce using rule 35 (block -> empty .)
    FLOAT           reduce using rule 35 (block -> empty .)
    BOOLEAN         reduce using rule 35 (block -> empty .)
    ELSE            reduce using rule 35 (block -> empty .)


state 39

    (31) formals -> formal_param .
    (32) formals -> formal_param . COMMA formals

    LCURLY          reduce using rule 31 (formals -> formal_param .)
    RCURLY          reduce using rule 31 (formals -> formal_param .)
    PUBLIC          reduce using rule 31 (formals -> formal_param .)
    PRIVATE         reduce using rule 31 (formals -> formal_param .)
    VOID            reduce using rule 31 (formals -> formal_param .)
    ID              reduce using rule 31 (formals -> formal_param .)
    INT             reduce using rule 31 (formals -> formal_param .)
    FLOAT           reduce using rule 31 (formals -> formal_param .)
    BOOLEAN         reduce using rule 31 (formals -> formal_param .)
    RPAREN          reduce using rule 31 (formals -> formal_param .)
    COMMA           shift and go to state 76


state 40

    (33) formal_param -> type . variable
    (24) variable -> . ID

    ID              shift and go to state 78

    variable                       shift and go to state 77

state 41

    (27) method_decl -> modifier VOID ID . LPAREN RPAREN block
    (28) method_decl -> modifier VOID ID . LPAREN formals RPAREN block

    LPAREN          shift and go to state 79


state 42

    (3) class_decl -> CLASS ID EXTENDS ID LCURLY class_body . RCURLY
    (7) class_body -> class_body . field_decl
    (8) class_body -> class_body . method_decl
    (9) class_body -> class_body . constructor_decl
    (11) field_decl -> . modifier var_decl
    (25) method_decl -> . modifier type ID LPAREN RPAREN block
    (26) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (27) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (28) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (29) constructor_decl -> . modifier ID block
    (30) constructor_decl -> . modifier ID formals block
    (12) modifier -> . PUBLIC
    (13) modifier -> . PRIVATE
    (14) modifier -> . PUBLIC STATIC
    (15) modifier -> . PRIVATE STATIC
    (16) modifier -> . empty
    (92) empty -> .

    RCURLY          shift and go to state 80
    PUBLIC          shift and go to state 13
    PRIVATE         shift and go to state 14
    VOID            reduce using rule 92 (empty -> .)
    ID              reduce using rule 92 (empty -> .)
    INT             reduce using rule 92 (empty -> .)
    FLOAT           reduce using rule 92 (empty -> .)
    BOOLEAN         reduce using rule 92 (empty -> .)

    field_decl                     shift and go to state 17
    method_decl                    shift and go to state 18
    constructor_decl               shift and go to state 19
    modifier                       shift and go to state 12
    empty                          shift and go to state 20

state 43

    (25) method_decl -> modifier type ID LPAREN . RPAREN block
    (26) method_decl -> modifier type ID LPAREN . formals RPAREN block
    (31) formals -> . formal_param
    (32) formals -> . formal_param COMMA formals
    (33) formal_param -> . type variable
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    RPAREN          shift and go to state 81
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 34

    type                           shift and go to state 40
    formals                        shift and go to state 82
    formal_param                   shift and go to state 39

state 44

    (17) var_decl -> type variables SEMICOLON .

    RCURLY          reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    PUBLIC          reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    PRIVATE         reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    VOID            reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    ID              reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    INT             reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    FLOAT           reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    BOOLEAN         reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    ELSE            reduce using rule 17 (var_decl -> type variables SEMICOLON .)


state 45

    (23) variables -> variable COMMA . variables
    (22) variables -> . variable
    (23) variables -> . variable COMMA variables
    (24) variable -> . ID

    ID              shift and go to state 78

    variable                       shift and go to state 33
    variables                      shift and go to state 83

state 46

    (30) constructor_decl -> modifier ID formals block .

    RCURLY          reduce using rule 30 (constructor_decl -> modifier ID formals block .)
    PUBLIC          reduce using rule 30 (constructor_decl -> modifier ID formals block .)
    PRIVATE         reduce using rule 30 (constructor_decl -> modifier ID formals block .)
    VOID            reduce using rule 30 (constructor_decl -> modifier ID formals block .)
    ID              reduce using rule 30 (constructor_decl -> modifier ID formals block .)
    INT             reduce using rule 30 (constructor_decl -> modifier ID formals block .)
    FLOAT           reduce using rule 30 (constructor_decl -> modifier ID formals block .)
    BOOLEAN         reduce using rule 30 (constructor_decl -> modifier ID formals block .)


state 47

    (34) block -> LCURLY stmt . RCURLY

    RCURLY          shift and go to state 84


state 48

    (36) stmt -> IF . LPAREN expression RPAREN stmt
    (37) stmt -> IF . LPAREN expression RPAREN stmt ELSE stmt

    LPAREN          shift and go to state 85


state 49

    (57) primary -> LPAREN . expression RPAREN
    (69) expression -> . primary
    (70) expression -> . assign
    (71) expression -> . expression arith_op expression
    (72) expression -> . expression bool_op expression
    (73) expression -> . unary_op expression
    (54) primary -> . literal
    (55) primary -> . THIS
    (56) primary -> . SUPER
    (57) primary -> . LPAREN expression RPAREN
    (58) primary -> . NEW ID
    (59) primary -> . NEW ID LPAREN arguments RPAREN
    (60) primary -> . method_invocation
    (61) primary -> . lhs
    (74) assign -> . lhs SETEQUAL expression
    (87) unary_op -> . PLUS
    (88) unary_op -> . MINUS
    (89) unary_op -> . NOT
    (48) literal -> . INTEGER
    (49) literal -> . FLOAT
    (50) literal -> . STRING
    (51) literal -> . NULL
    (52) literal -> . FALSE
    (53) literal -> . TRUE
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (64) lhs -> . field_access
    (65) field_access -> . primary DOT ID
    (66) field_access -> . ID

    THIS            shift and go to state 68
    SUPER           shift and go to state 69
    LPAREN          shift and go to state 49
    NEW             shift and go to state 70
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    NOT             shift and go to state 95
    INTEGER         shift and go to state 71
    FLOAT           shift and go to state 96
    STRING          shift and go to state 72
    NULL            shift and go to state 73
    FALSE           shift and go to state 74
    TRUE            shift and go to state 75
    ID              shift and go to state 90

    expression                     shift and go to state 86
    primary                        shift and go to state 87
    assign                         shift and go to state 88
    unary_op                       shift and go to state 89
    literal                        shift and go to state 67
    method_invocation              shift and go to state 91
    lhs                            shift and go to state 92
    field_access                   shift and go to state 63

state 50

    (38) stmt -> WHILE . LPAREN expression RPAREN stmt

    LPAREN          shift and go to state 97


state 51

    (39) stmt -> FOR . LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt

    LPAREN          shift and go to state 98


state 52

    (42) stmt -> stmt_expression . SEMICOLON

    SEMICOLON       shift and go to state 99


state 53

    (47) stmt -> SEMICOLON .

    RCURLY          reduce using rule 47 (stmt -> SEMICOLON .)
    ELSE            reduce using rule 47 (stmt -> SEMICOLON .)


state 54

    (40) stmt -> RETURN . expression SEMICOLON
    (41) stmt -> RETURN . SEMICOLON
    (69) expression -> . primary
    (70) expression -> . assign
    (71) expression -> . expression arith_op expression
    (72) expression -> . expression bool_op expression
    (73) expression -> . unary_op expression
    (54) primary -> . literal
    (55) primary -> . THIS
    (56) primary -> . SUPER
    (57) primary -> . LPAREN expression RPAREN
    (58) primary -> . NEW ID
    (59) primary -> . NEW ID LPAREN arguments RPAREN
    (60) primary -> . method_invocation
    (61) primary -> . lhs
    (74) assign -> . lhs SETEQUAL expression
    (87) unary_op -> . PLUS
    (88) unary_op -> . MINUS
    (89) unary_op -> . NOT
    (48) literal -> . INTEGER
    (49) literal -> . FLOAT
    (50) literal -> . STRING
    (51) literal -> . NULL
    (52) literal -> . FALSE
    (53) literal -> . TRUE
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (64) lhs -> . field_access
    (65) field_access -> . primary DOT ID
    (66) field_access -> . ID

    SEMICOLON       shift and go to state 101
    THIS            shift and go to state 68
    SUPER           shift and go to state 69
    LPAREN          shift and go to state 49
    NEW             shift and go to state 70
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    NOT             shift and go to state 95
    INTEGER         shift and go to state 71
    FLOAT           shift and go to state 96
    STRING          shift and go to state 72
    NULL            shift and go to state 73
    FALSE           shift and go to state 74
    TRUE            shift and go to state 75
    ID              shift and go to state 90

    expression                     shift and go to state 100
    primary                        shift and go to state 87
    assign                         shift and go to state 88
    unary_op                       shift and go to state 89
    literal                        shift and go to state 67
    method_invocation              shift and go to state 91
    lhs                            shift and go to state 92
    field_access                   shift and go to state 63

state 55

    (43) stmt -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 102


state 56

    (44) stmt -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 103


state 57

    (45) stmt -> block .

    RCURLY          reduce using rule 45 (stmt -> block .)
    ELSE            reduce using rule 45 (stmt -> block .)


state 58

    (46) stmt -> var_decl .

    RCURLY          reduce using rule 46 (stmt -> var_decl .)
    ELSE            reduce using rule 46 (stmt -> var_decl .)


state 59

    (90) stmt_expression -> assign .

    SEMICOLON       reduce using rule 90 (stmt_expression -> assign .)
    RPAREN          reduce using rule 90 (stmt_expression -> assign .)


state 60

    (91) stmt_expression -> method_invocation .
    (60) primary -> method_invocation .

    SEMICOLON       reduce using rule 91 (stmt_expression -> method_invocation .)
    RPAREN          reduce using rule 91 (stmt_expression -> method_invocation .)
    DOT             reduce using rule 60 (primary -> method_invocation .)


state 61

    (17) var_decl -> type . variables SEMICOLON
    (22) variables -> . variable
    (23) variables -> . variable COMMA variables
    (24) variable -> . ID

    ID              shift and go to state 78

    variables                      shift and go to state 32
    variable                       shift and go to state 33

state 62

    (74) assign -> lhs . SETEQUAL expression
    (61) primary -> lhs .

    SETEQUAL        shift and go to state 104
    DOT             reduce using rule 61 (primary -> lhs .)


state 63

    (67) method_invocation -> field_access . LPAREN arguments RPAREN
    (68) method_invocation -> field_access . LPAREN RPAREN
    (64) lhs -> field_access .

    LPAREN          shift and go to state 105
    SETEQUAL        reduce using rule 64 (lhs -> field_access .)
    DOT             reduce using rule 64 (lhs -> field_access .)
    RPAREN          reduce using rule 64 (lhs -> field_access .)
    PLUS            reduce using rule 64 (lhs -> field_access .)
    MINUS           reduce using rule 64 (lhs -> field_access .)
    TIMES           reduce using rule 64 (lhs -> field_access .)
    DIVIDE          reduce using rule 64 (lhs -> field_access .)
    GREATER         reduce using rule 64 (lhs -> field_access .)
    LESS            reduce using rule 64 (lhs -> field_access .)
    GREATEREQ       reduce using rule 64 (lhs -> field_access .)
    LESSEQ          reduce using rule 64 (lhs -> field_access .)
    EQUAL           reduce using rule 64 (lhs -> field_access .)
    NOTEQUAL        reduce using rule 64 (lhs -> field_access .)
    AND             reduce using rule 64 (lhs -> field_access .)
    OR              reduce using rule 64 (lhs -> field_access .)
    SEMICOLON       reduce using rule 64 (lhs -> field_access .)
    COMMA           reduce using rule 64 (lhs -> field_access .)


state 64

    (19) type -> FLOAT .
    (49) literal -> FLOAT .

    ID              reduce using rule 19 (type -> FLOAT .)
    DOT             reduce using rule 49 (literal -> FLOAT .)


state 65

    (21) type -> ID .
    (66) field_access -> ID .

    ID              reduce using rule 21 (type -> ID .)
    LPAREN          reduce using rule 66 (field_access -> ID .)
    SETEQUAL        reduce using rule 66 (field_access -> ID .)
    DOT             reduce using rule 66 (field_access -> ID .)


state 66

    (65) field_access -> primary . DOT ID

    DOT             shift and go to state 106


state 67

    (54) primary -> literal .

    DOT             reduce using rule 54 (primary -> literal .)
    RPAREN          reduce using rule 54 (primary -> literal .)
    PLUS            reduce using rule 54 (primary -> literal .)
    MINUS           reduce using rule 54 (primary -> literal .)
    TIMES           reduce using rule 54 (primary -> literal .)
    DIVIDE          reduce using rule 54 (primary -> literal .)
    GREATER         reduce using rule 54 (primary -> literal .)
    LESS            reduce using rule 54 (primary -> literal .)
    GREATEREQ       reduce using rule 54 (primary -> literal .)
    LESSEQ          reduce using rule 54 (primary -> literal .)
    EQUAL           reduce using rule 54 (primary -> literal .)
    NOTEQUAL        reduce using rule 54 (primary -> literal .)
    AND             reduce using rule 54 (primary -> literal .)
    OR              reduce using rule 54 (primary -> literal .)
    SEMICOLON       reduce using rule 54 (primary -> literal .)
    COMMA           reduce using rule 54 (primary -> literal .)


state 68

    (55) primary -> THIS .

    DOT             reduce using rule 55 (primary -> THIS .)
    RPAREN          reduce using rule 55 (primary -> THIS .)
    PLUS            reduce using rule 55 (primary -> THIS .)
    MINUS           reduce using rule 55 (primary -> THIS .)
    TIMES           reduce using rule 55 (primary -> THIS .)
    DIVIDE          reduce using rule 55 (primary -> THIS .)
    GREATER         reduce using rule 55 (primary -> THIS .)
    LESS            reduce using rule 55 (primary -> THIS .)
    GREATEREQ       reduce using rule 55 (primary -> THIS .)
    LESSEQ          reduce using rule 55 (primary -> THIS .)
    EQUAL           reduce using rule 55 (primary -> THIS .)
    NOTEQUAL        reduce using rule 55 (primary -> THIS .)
    AND             reduce using rule 55 (primary -> THIS .)
    OR              reduce using rule 55 (primary -> THIS .)
    SEMICOLON       reduce using rule 55 (primary -> THIS .)
    COMMA           reduce using rule 55 (primary -> THIS .)


state 69

    (56) primary -> SUPER .

    DOT             reduce using rule 56 (primary -> SUPER .)
    RPAREN          reduce using rule 56 (primary -> SUPER .)
    PLUS            reduce using rule 56 (primary -> SUPER .)
    MINUS           reduce using rule 56 (primary -> SUPER .)
    TIMES           reduce using rule 56 (primary -> SUPER .)
    DIVIDE          reduce using rule 56 (primary -> SUPER .)
    GREATER         reduce using rule 56 (primary -> SUPER .)
    LESS            reduce using rule 56 (primary -> SUPER .)
    GREATEREQ       reduce using rule 56 (primary -> SUPER .)
    LESSEQ          reduce using rule 56 (primary -> SUPER .)
    EQUAL           reduce using rule 56 (primary -> SUPER .)
    NOTEQUAL        reduce using rule 56 (primary -> SUPER .)
    AND             reduce using rule 56 (primary -> SUPER .)
    OR              reduce using rule 56 (primary -> SUPER .)
    SEMICOLON       reduce using rule 56 (primary -> SUPER .)
    COMMA           reduce using rule 56 (primary -> SUPER .)


state 70

    (58) primary -> NEW . ID
    (59) primary -> NEW . ID LPAREN arguments RPAREN

    ID              shift and go to state 107


state 71

    (48) literal -> INTEGER .

    DOT             reduce using rule 48 (literal -> INTEGER .)
    RPAREN          reduce using rule 48 (literal -> INTEGER .)
    PLUS            reduce using rule 48 (literal -> INTEGER .)
    MINUS           reduce using rule 48 (literal -> INTEGER .)
    TIMES           reduce using rule 48 (literal -> INTEGER .)
    DIVIDE          reduce using rule 48 (literal -> INTEGER .)
    GREATER         reduce using rule 48 (literal -> INTEGER .)
    LESS            reduce using rule 48 (literal -> INTEGER .)
    GREATEREQ       reduce using rule 48 (literal -> INTEGER .)
    LESSEQ          reduce using rule 48 (literal -> INTEGER .)
    EQUAL           reduce using rule 48 (literal -> INTEGER .)
    NOTEQUAL        reduce using rule 48 (literal -> INTEGER .)
    AND             reduce using rule 48 (literal -> INTEGER .)
    OR              reduce using rule 48 (literal -> INTEGER .)
    SEMICOLON       reduce using rule 48 (literal -> INTEGER .)
    COMMA           reduce using rule 48 (literal -> INTEGER .)


state 72

    (50) literal -> STRING .

    DOT             reduce using rule 50 (literal -> STRING .)
    RPAREN          reduce using rule 50 (literal -> STRING .)
    PLUS            reduce using rule 50 (literal -> STRING .)
    MINUS           reduce using rule 50 (literal -> STRING .)
    TIMES           reduce using rule 50 (literal -> STRING .)
    DIVIDE          reduce using rule 50 (literal -> STRING .)
    GREATER         reduce using rule 50 (literal -> STRING .)
    LESS            reduce using rule 50 (literal -> STRING .)
    GREATEREQ       reduce using rule 50 (literal -> STRING .)
    LESSEQ          reduce using rule 50 (literal -> STRING .)
    EQUAL           reduce using rule 50 (literal -> STRING .)
    NOTEQUAL        reduce using rule 50 (literal -> STRING .)
    AND             reduce using rule 50 (literal -> STRING .)
    OR              reduce using rule 50 (literal -> STRING .)
    SEMICOLON       reduce using rule 50 (literal -> STRING .)
    COMMA           reduce using rule 50 (literal -> STRING .)


state 73

    (51) literal -> NULL .

    DOT             reduce using rule 51 (literal -> NULL .)
    RPAREN          reduce using rule 51 (literal -> NULL .)
    PLUS            reduce using rule 51 (literal -> NULL .)
    MINUS           reduce using rule 51 (literal -> NULL .)
    TIMES           reduce using rule 51 (literal -> NULL .)
    DIVIDE          reduce using rule 51 (literal -> NULL .)
    GREATER         reduce using rule 51 (literal -> NULL .)
    LESS            reduce using rule 51 (literal -> NULL .)
    GREATEREQ       reduce using rule 51 (literal -> NULL .)
    LESSEQ          reduce using rule 51 (literal -> NULL .)
    EQUAL           reduce using rule 51 (literal -> NULL .)
    NOTEQUAL        reduce using rule 51 (literal -> NULL .)
    AND             reduce using rule 51 (literal -> NULL .)
    OR              reduce using rule 51 (literal -> NULL .)
    SEMICOLON       reduce using rule 51 (literal -> NULL .)
    COMMA           reduce using rule 51 (literal -> NULL .)


state 74

    (52) literal -> FALSE .

    DOT             reduce using rule 52 (literal -> FALSE .)
    RPAREN          reduce using rule 52 (literal -> FALSE .)
    PLUS            reduce using rule 52 (literal -> FALSE .)
    MINUS           reduce using rule 52 (literal -> FALSE .)
    TIMES           reduce using rule 52 (literal -> FALSE .)
    DIVIDE          reduce using rule 52 (literal -> FALSE .)
    GREATER         reduce using rule 52 (literal -> FALSE .)
    LESS            reduce using rule 52 (literal -> FALSE .)
    GREATEREQ       reduce using rule 52 (literal -> FALSE .)
    LESSEQ          reduce using rule 52 (literal -> FALSE .)
    EQUAL           reduce using rule 52 (literal -> FALSE .)
    NOTEQUAL        reduce using rule 52 (literal -> FALSE .)
    AND             reduce using rule 52 (literal -> FALSE .)
    OR              reduce using rule 52 (literal -> FALSE .)
    SEMICOLON       reduce using rule 52 (literal -> FALSE .)
    COMMA           reduce using rule 52 (literal -> FALSE .)


state 75

    (53) literal -> TRUE .

    DOT             reduce using rule 53 (literal -> TRUE .)
    RPAREN          reduce using rule 53 (literal -> TRUE .)
    PLUS            reduce using rule 53 (literal -> TRUE .)
    MINUS           reduce using rule 53 (literal -> TRUE .)
    TIMES           reduce using rule 53 (literal -> TRUE .)
    DIVIDE          reduce using rule 53 (literal -> TRUE .)
    GREATER         reduce using rule 53 (literal -> TRUE .)
    LESS            reduce using rule 53 (literal -> TRUE .)
    GREATEREQ       reduce using rule 53 (literal -> TRUE .)
    LESSEQ          reduce using rule 53 (literal -> TRUE .)
    EQUAL           reduce using rule 53 (literal -> TRUE .)
    NOTEQUAL        reduce using rule 53 (literal -> TRUE .)
    AND             reduce using rule 53 (literal -> TRUE .)
    OR              reduce using rule 53 (literal -> TRUE .)
    SEMICOLON       reduce using rule 53 (literal -> TRUE .)
    COMMA           reduce using rule 53 (literal -> TRUE .)


state 76

    (32) formals -> formal_param COMMA . formals
    (31) formals -> . formal_param
    (32) formals -> . formal_param COMMA formals
    (33) formal_param -> . type variable
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 34

    formal_param                   shift and go to state 39
    formals                        shift and go to state 108
    type                           shift and go to state 40

state 77

    (33) formal_param -> type variable .

    COMMA           reduce using rule 33 (formal_param -> type variable .)
    LCURLY          reduce using rule 33 (formal_param -> type variable .)
    RCURLY          reduce using rule 33 (formal_param -> type variable .)
    PUBLIC          reduce using rule 33 (formal_param -> type variable .)
    PRIVATE         reduce using rule 33 (formal_param -> type variable .)
    VOID            reduce using rule 33 (formal_param -> type variable .)
    ID              reduce using rule 33 (formal_param -> type variable .)
    INT             reduce using rule 33 (formal_param -> type variable .)
    FLOAT           reduce using rule 33 (formal_param -> type variable .)
    BOOLEAN         reduce using rule 33 (formal_param -> type variable .)
    RPAREN          reduce using rule 33 (formal_param -> type variable .)


state 78

    (24) variable -> ID .

    COMMA           reduce using rule 24 (variable -> ID .)
    LCURLY          reduce using rule 24 (variable -> ID .)
    RCURLY          reduce using rule 24 (variable -> ID .)
    PUBLIC          reduce using rule 24 (variable -> ID .)
    PRIVATE         reduce using rule 24 (variable -> ID .)
    VOID            reduce using rule 24 (variable -> ID .)
    ID              reduce using rule 24 (variable -> ID .)
    INT             reduce using rule 24 (variable -> ID .)
    FLOAT           reduce using rule 24 (variable -> ID .)
    BOOLEAN         reduce using rule 24 (variable -> ID .)
    RPAREN          reduce using rule 24 (variable -> ID .)
    SEMICOLON       reduce using rule 24 (variable -> ID .)


state 79

    (27) method_decl -> modifier VOID ID LPAREN . RPAREN block
    (28) method_decl -> modifier VOID ID LPAREN . formals RPAREN block
    (31) formals -> . formal_param
    (32) formals -> . formal_param COMMA formals
    (33) formal_param -> . type variable
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    RPAREN          shift and go to state 109
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 34

    formals                        shift and go to state 110
    formal_param                   shift and go to state 39
    type                           shift and go to state 40

state 80

    (3) class_decl -> CLASS ID EXTENDS ID LCURLY class_body RCURLY .

    $end            reduce using rule 3 (class_decl -> CLASS ID EXTENDS ID LCURLY class_body RCURLY .)


state 81

    (25) method_decl -> modifier type ID LPAREN RPAREN . block
    (34) block -> . LCURLY stmt RCURLY
    (35) block -> . empty
    (92) empty -> .

    LCURLY          shift and go to state 37
    RCURLY          reduce using rule 92 (empty -> .)
    PUBLIC          reduce using rule 92 (empty -> .)
    PRIVATE         reduce using rule 92 (empty -> .)
    VOID            reduce using rule 92 (empty -> .)
    ID              reduce using rule 92 (empty -> .)
    INT             reduce using rule 92 (empty -> .)
    FLOAT           reduce using rule 92 (empty -> .)
    BOOLEAN         reduce using rule 92 (empty -> .)

    block                          shift and go to state 111
    empty                          shift and go to state 38

state 82

    (26) method_decl -> modifier type ID LPAREN formals . RPAREN block

    RPAREN          shift and go to state 112


state 83

    (23) variables -> variable COMMA variables .

    SEMICOLON       reduce using rule 23 (variables -> variable COMMA variables .)


state 84

    (34) block -> LCURLY stmt RCURLY .

    RCURLY          reduce using rule 34 (block -> LCURLY stmt RCURLY .)
    PUBLIC          reduce using rule 34 (block -> LCURLY stmt RCURLY .)
    PRIVATE         reduce using rule 34 (block -> LCURLY stmt RCURLY .)
    VOID            reduce using rule 34 (block -> LCURLY stmt RCURLY .)
    ID              reduce using rule 34 (block -> LCURLY stmt RCURLY .)
    INT             reduce using rule 34 (block -> LCURLY stmt RCURLY .)
    FLOAT           reduce using rule 34 (block -> LCURLY stmt RCURLY .)
    BOOLEAN         reduce using rule 34 (block -> LCURLY stmt RCURLY .)
    ELSE            reduce using rule 34 (block -> LCURLY stmt RCURLY .)


state 85

    (36) stmt -> IF LPAREN . expression RPAREN stmt
    (37) stmt -> IF LPAREN . expression RPAREN stmt ELSE stmt
    (69) expression -> . primary
    (70) expression -> . assign
    (71) expression -> . expression arith_op expression
    (72) expression -> . expression bool_op expression
    (73) expression -> . unary_op expression
    (54) primary -> . literal
    (55) primary -> . THIS
    (56) primary -> . SUPER
    (57) primary -> . LPAREN expression RPAREN
    (58) primary -> . NEW ID
    (59) primary -> . NEW ID LPAREN arguments RPAREN
    (60) primary -> . method_invocation
    (61) primary -> . lhs
    (74) assign -> . lhs SETEQUAL expression
    (87) unary_op -> . PLUS
    (88) unary_op -> . MINUS
    (89) unary_op -> . NOT
    (48) literal -> . INTEGER
    (49) literal -> . FLOAT
    (50) literal -> . STRING
    (51) literal -> . NULL
    (52) literal -> . FALSE
    (53) literal -> . TRUE
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (64) lhs -> . field_access
    (65) field_access -> . primary DOT ID
    (66) field_access -> . ID

    THIS            shift and go to state 68
    SUPER           shift and go to state 69
    LPAREN          shift and go to state 49
    NEW             shift and go to state 70
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    NOT             shift and go to state 95
    INTEGER         shift and go to state 71
    FLOAT           shift and go to state 96
    STRING          shift and go to state 72
    NULL            shift and go to state 73
    FALSE           shift and go to state 74
    TRUE            shift and go to state 75
    ID              shift and go to state 90

    expression                     shift and go to state 113
    primary                        shift and go to state 87
    assign                         shift and go to state 88
    unary_op                       shift and go to state 89
    literal                        shift and go to state 67
    method_invocation              shift and go to state 91
    lhs                            shift and go to state 92
    field_access                   shift and go to state 63

state 86

    (57) primary -> LPAREN expression . RPAREN
    (71) expression -> expression . arith_op expression
    (72) expression -> expression . bool_op expression
    (75) arith_op -> . PLUS
    (76) arith_op -> . MINUS
    (77) arith_op -> . TIMES
    (78) arith_op -> . DIVIDE
    (79) bool_op -> . GREATER
    (80) bool_op -> . LESS
    (81) bool_op -> . GREATEREQ
    (82) bool_op -> . LESSEQ
    (83) bool_op -> . EQUAL
    (84) bool_op -> . NOTEQUAL
    (85) bool_op -> . AND
    (86) bool_op -> . OR

    RPAREN          shift and go to state 114
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120
    GREATER         shift and go to state 121
    LESS            shift and go to state 122
    GREATEREQ       shift and go to state 123
    LESSEQ          shift and go to state 124
    EQUAL           shift and go to state 125
    NOTEQUAL        shift and go to state 126
    AND             shift and go to state 127
    OR              shift and go to state 128

    arith_op                       shift and go to state 115
    bool_op                        shift and go to state 116

state 87

    (69) expression -> primary .
    (65) field_access -> primary . DOT ID

    RPAREN          reduce using rule 69 (expression -> primary .)
    PLUS            reduce using rule 69 (expression -> primary .)
    MINUS           reduce using rule 69 (expression -> primary .)
    TIMES           reduce using rule 69 (expression -> primary .)
    DIVIDE          reduce using rule 69 (expression -> primary .)
    GREATER         reduce using rule 69 (expression -> primary .)
    LESS            reduce using rule 69 (expression -> primary .)
    GREATEREQ       reduce using rule 69 (expression -> primary .)
    LESSEQ          reduce using rule 69 (expression -> primary .)
    EQUAL           reduce using rule 69 (expression -> primary .)
    NOTEQUAL        reduce using rule 69 (expression -> primary .)
    AND             reduce using rule 69 (expression -> primary .)
    OR              reduce using rule 69 (expression -> primary .)
    SEMICOLON       reduce using rule 69 (expression -> primary .)
    COMMA           reduce using rule 69 (expression -> primary .)
    DOT             shift and go to state 106


state 88

    (70) expression -> assign .

    RPAREN          reduce using rule 70 (expression -> assign .)
    PLUS            reduce using rule 70 (expression -> assign .)
    MINUS           reduce using rule 70 (expression -> assign .)
    TIMES           reduce using rule 70 (expression -> assign .)
    DIVIDE          reduce using rule 70 (expression -> assign .)
    GREATER         reduce using rule 70 (expression -> assign .)
    LESS            reduce using rule 70 (expression -> assign .)
    GREATEREQ       reduce using rule 70 (expression -> assign .)
    LESSEQ          reduce using rule 70 (expression -> assign .)
    EQUAL           reduce using rule 70 (expression -> assign .)
    NOTEQUAL        reduce using rule 70 (expression -> assign .)
    AND             reduce using rule 70 (expression -> assign .)
    OR              reduce using rule 70 (expression -> assign .)
    SEMICOLON       reduce using rule 70 (expression -> assign .)
    COMMA           reduce using rule 70 (expression -> assign .)


state 89

    (73) expression -> unary_op . expression
    (69) expression -> . primary
    (70) expression -> . assign
    (71) expression -> . expression arith_op expression
    (72) expression -> . expression bool_op expression
    (73) expression -> . unary_op expression
    (54) primary -> . literal
    (55) primary -> . THIS
    (56) primary -> . SUPER
    (57) primary -> . LPAREN expression RPAREN
    (58) primary -> . NEW ID
    (59) primary -> . NEW ID LPAREN arguments RPAREN
    (60) primary -> . method_invocation
    (61) primary -> . lhs
    (74) assign -> . lhs SETEQUAL expression
    (87) unary_op -> . PLUS
    (88) unary_op -> . MINUS
    (89) unary_op -> . NOT
    (48) literal -> . INTEGER
    (49) literal -> . FLOAT
    (50) literal -> . STRING
    (51) literal -> . NULL
    (52) literal -> . FALSE
    (53) literal -> . TRUE
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (64) lhs -> . field_access
    (65) field_access -> . primary DOT ID
    (66) field_access -> . ID

    THIS            shift and go to state 68
    SUPER           shift and go to state 69
    LPAREN          shift and go to state 49
    NEW             shift and go to state 70
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    NOT             shift and go to state 95
    INTEGER         shift and go to state 71
    FLOAT           shift and go to state 96
    STRING          shift and go to state 72
    NULL            shift and go to state 73
    FALSE           shift and go to state 74
    TRUE            shift and go to state 75
    ID              shift and go to state 90

    unary_op                       shift and go to state 89
    expression                     shift and go to state 129
    primary                        shift and go to state 87
    assign                         shift and go to state 88
    literal                        shift and go to state 67
    method_invocation              shift and go to state 91
    lhs                            shift and go to state 92
    field_access                   shift and go to state 63

state 90

    (66) field_access -> ID .

    LPAREN          reduce using rule 66 (field_access -> ID .)
    SETEQUAL        reduce using rule 66 (field_access -> ID .)
    DOT             reduce using rule 66 (field_access -> ID .)
    RPAREN          reduce using rule 66 (field_access -> ID .)
    PLUS            reduce using rule 66 (field_access -> ID .)
    MINUS           reduce using rule 66 (field_access -> ID .)
    TIMES           reduce using rule 66 (field_access -> ID .)
    DIVIDE          reduce using rule 66 (field_access -> ID .)
    GREATER         reduce using rule 66 (field_access -> ID .)
    LESS            reduce using rule 66 (field_access -> ID .)
    GREATEREQ       reduce using rule 66 (field_access -> ID .)
    LESSEQ          reduce using rule 66 (field_access -> ID .)
    EQUAL           reduce using rule 66 (field_access -> ID .)
    NOTEQUAL        reduce using rule 66 (field_access -> ID .)
    AND             reduce using rule 66 (field_access -> ID .)
    OR              reduce using rule 66 (field_access -> ID .)
    SEMICOLON       reduce using rule 66 (field_access -> ID .)
    COMMA           reduce using rule 66 (field_access -> ID .)


state 91

    (60) primary -> method_invocation .

    DOT             reduce using rule 60 (primary -> method_invocation .)
    RPAREN          reduce using rule 60 (primary -> method_invocation .)
    PLUS            reduce using rule 60 (primary -> method_invocation .)
    MINUS           reduce using rule 60 (primary -> method_invocation .)
    TIMES           reduce using rule 60 (primary -> method_invocation .)
    DIVIDE          reduce using rule 60 (primary -> method_invocation .)
    GREATER         reduce using rule 60 (primary -> method_invocation .)
    LESS            reduce using rule 60 (primary -> method_invocation .)
    GREATEREQ       reduce using rule 60 (primary -> method_invocation .)
    LESSEQ          reduce using rule 60 (primary -> method_invocation .)
    EQUAL           reduce using rule 60 (primary -> method_invocation .)
    NOTEQUAL        reduce using rule 60 (primary -> method_invocation .)
    AND             reduce using rule 60 (primary -> method_invocation .)
    OR              reduce using rule 60 (primary -> method_invocation .)
    SEMICOLON       reduce using rule 60 (primary -> method_invocation .)
    COMMA           reduce using rule 60 (primary -> method_invocation .)


state 92

    (61) primary -> lhs .
    (74) assign -> lhs . SETEQUAL expression

    DOT             reduce using rule 61 (primary -> lhs .)
    RPAREN          reduce using rule 61 (primary -> lhs .)
    PLUS            reduce using rule 61 (primary -> lhs .)
    MINUS           reduce using rule 61 (primary -> lhs .)
    TIMES           reduce using rule 61 (primary -> lhs .)
    DIVIDE          reduce using rule 61 (primary -> lhs .)
    GREATER         reduce using rule 61 (primary -> lhs .)
    LESS            reduce using rule 61 (primary -> lhs .)
    GREATEREQ       reduce using rule 61 (primary -> lhs .)
    LESSEQ          reduce using rule 61 (primary -> lhs .)
    EQUAL           reduce using rule 61 (primary -> lhs .)
    NOTEQUAL        reduce using rule 61 (primary -> lhs .)
    AND             reduce using rule 61 (primary -> lhs .)
    OR              reduce using rule 61 (primary -> lhs .)
    SEMICOLON       reduce using rule 61 (primary -> lhs .)
    COMMA           reduce using rule 61 (primary -> lhs .)
    SETEQUAL        shift and go to state 104


state 93

    (87) unary_op -> PLUS .

    THIS            reduce using rule 87 (unary_op -> PLUS .)
    SUPER           reduce using rule 87 (unary_op -> PLUS .)
    LPAREN          reduce using rule 87 (unary_op -> PLUS .)
    NEW             reduce using rule 87 (unary_op -> PLUS .)
    PLUS            reduce using rule 87 (unary_op -> PLUS .)
    MINUS           reduce using rule 87 (unary_op -> PLUS .)
    NOT             reduce using rule 87 (unary_op -> PLUS .)
    INTEGER         reduce using rule 87 (unary_op -> PLUS .)
    FLOAT           reduce using rule 87 (unary_op -> PLUS .)
    STRING          reduce using rule 87 (unary_op -> PLUS .)
    NULL            reduce using rule 87 (unary_op -> PLUS .)
    FALSE           reduce using rule 87 (unary_op -> PLUS .)
    TRUE            reduce using rule 87 (unary_op -> PLUS .)
    ID              reduce using rule 87 (unary_op -> PLUS .)


state 94

    (88) unary_op -> MINUS .

    THIS            reduce using rule 88 (unary_op -> MINUS .)
    SUPER           reduce using rule 88 (unary_op -> MINUS .)
    LPAREN          reduce using rule 88 (unary_op -> MINUS .)
    NEW             reduce using rule 88 (unary_op -> MINUS .)
    PLUS            reduce using rule 88 (unary_op -> MINUS .)
    MINUS           reduce using rule 88 (unary_op -> MINUS .)
    NOT             reduce using rule 88 (unary_op -> MINUS .)
    INTEGER         reduce using rule 88 (unary_op -> MINUS .)
    FLOAT           reduce using rule 88 (unary_op -> MINUS .)
    STRING          reduce using rule 88 (unary_op -> MINUS .)
    NULL            reduce using rule 88 (unary_op -> MINUS .)
    FALSE           reduce using rule 88 (unary_op -> MINUS .)
    TRUE            reduce using rule 88 (unary_op -> MINUS .)
    ID              reduce using rule 88 (unary_op -> MINUS .)


state 95

    (89) unary_op -> NOT .

    THIS            reduce using rule 89 (unary_op -> NOT .)
    SUPER           reduce using rule 89 (unary_op -> NOT .)
    LPAREN          reduce using rule 89 (unary_op -> NOT .)
    NEW             reduce using rule 89 (unary_op -> NOT .)
    PLUS            reduce using rule 89 (unary_op -> NOT .)
    MINUS           reduce using rule 89 (unary_op -> NOT .)
    NOT             reduce using rule 89 (unary_op -> NOT .)
    INTEGER         reduce using rule 89 (unary_op -> NOT .)
    FLOAT           reduce using rule 89 (unary_op -> NOT .)
    STRING          reduce using rule 89 (unary_op -> NOT .)
    NULL            reduce using rule 89 (unary_op -> NOT .)
    FALSE           reduce using rule 89 (unary_op -> NOT .)
    TRUE            reduce using rule 89 (unary_op -> NOT .)
    ID              reduce using rule 89 (unary_op -> NOT .)


state 96

    (49) literal -> FLOAT .

    DOT             reduce using rule 49 (literal -> FLOAT .)
    RPAREN          reduce using rule 49 (literal -> FLOAT .)
    PLUS            reduce using rule 49 (literal -> FLOAT .)
    MINUS           reduce using rule 49 (literal -> FLOAT .)
    TIMES           reduce using rule 49 (literal -> FLOAT .)
    DIVIDE          reduce using rule 49 (literal -> FLOAT .)
    GREATER         reduce using rule 49 (literal -> FLOAT .)
    LESS            reduce using rule 49 (literal -> FLOAT .)
    GREATEREQ       reduce using rule 49 (literal -> FLOAT .)
    LESSEQ          reduce using rule 49 (literal -> FLOAT .)
    EQUAL           reduce using rule 49 (literal -> FLOAT .)
    NOTEQUAL        reduce using rule 49 (literal -> FLOAT .)
    AND             reduce using rule 49 (literal -> FLOAT .)
    OR              reduce using rule 49 (literal -> FLOAT .)
    SEMICOLON       reduce using rule 49 (literal -> FLOAT .)
    COMMA           reduce using rule 49 (literal -> FLOAT .)


state 97

    (38) stmt -> WHILE LPAREN . expression RPAREN stmt
    (69) expression -> . primary
    (70) expression -> . assign
    (71) expression -> . expression arith_op expression
    (72) expression -> . expression bool_op expression
    (73) expression -> . unary_op expression
    (54) primary -> . literal
    (55) primary -> . THIS
    (56) primary -> . SUPER
    (57) primary -> . LPAREN expression RPAREN
    (58) primary -> . NEW ID
    (59) primary -> . NEW ID LPAREN arguments RPAREN
    (60) primary -> . method_invocation
    (61) primary -> . lhs
    (74) assign -> . lhs SETEQUAL expression
    (87) unary_op -> . PLUS
    (88) unary_op -> . MINUS
    (89) unary_op -> . NOT
    (48) literal -> . INTEGER
    (49) literal -> . FLOAT
    (50) literal -> . STRING
    (51) literal -> . NULL
    (52) literal -> . FALSE
    (53) literal -> . TRUE
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (64) lhs -> . field_access
    (65) field_access -> . primary DOT ID
    (66) field_access -> . ID

    THIS            shift and go to state 68
    SUPER           shift and go to state 69
    LPAREN          shift and go to state 49
    NEW             shift and go to state 70
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    NOT             shift and go to state 95
    INTEGER         shift and go to state 71
    FLOAT           shift and go to state 96
    STRING          shift and go to state 72
    NULL            shift and go to state 73
    FALSE           shift and go to state 74
    TRUE            shift and go to state 75
    ID              shift and go to state 90

    expression                     shift and go to state 130
    primary                        shift and go to state 87
    assign                         shift and go to state 88
    unary_op                       shift and go to state 89
    literal                        shift and go to state 67
    method_invocation              shift and go to state 91
    lhs                            shift and go to state 92
    field_access                   shift and go to state 63

state 98

    (39) stmt -> FOR LPAREN . stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (90) stmt_expression -> . assign
    (91) stmt_expression -> . method_invocation
    (74) assign -> . lhs SETEQUAL expression
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (64) lhs -> . field_access
    (65) field_access -> . primary DOT ID
    (66) field_access -> . ID
    (54) primary -> . literal
    (55) primary -> . THIS
    (56) primary -> . SUPER
    (57) primary -> . LPAREN expression RPAREN
    (58) primary -> . NEW ID
    (59) primary -> . NEW ID LPAREN arguments RPAREN
    (60) primary -> . method_invocation
    (61) primary -> . lhs
    (48) literal -> . INTEGER
    (49) literal -> . FLOAT
    (50) literal -> . STRING
    (51) literal -> . NULL
    (52) literal -> . FALSE
    (53) literal -> . TRUE

    ID              shift and go to state 90
    THIS            shift and go to state 68
    SUPER           shift and go to state 69
    LPAREN          shift and go to state 49
    NEW             shift and go to state 70
    INTEGER         shift and go to state 71
    FLOAT           shift and go to state 96
    STRING          shift and go to state 72
    NULL            shift and go to state 73
    FALSE           shift and go to state 74
    TRUE            shift and go to state 75

    stmt_expression                shift and go to state 131
    assign                         shift and go to state 59
    method_invocation              shift and go to state 60
    lhs                            shift and go to state 62
    field_access                   shift and go to state 63
    primary                        shift and go to state 66
    literal                        shift and go to state 67

state 99

    (42) stmt -> stmt_expression SEMICOLON .

    RCURLY          reduce using rule 42 (stmt -> stmt_expression SEMICOLON .)
    ELSE            reduce using rule 42 (stmt -> stmt_expression SEMICOLON .)


state 100

    (40) stmt -> RETURN expression . SEMICOLON
    (71) expression -> expression . arith_op expression
    (72) expression -> expression . bool_op expression
    (75) arith_op -> . PLUS
    (76) arith_op -> . MINUS
    (77) arith_op -> . TIMES
    (78) arith_op -> . DIVIDE
    (79) bool_op -> . GREATER
    (80) bool_op -> . LESS
    (81) bool_op -> . GREATEREQ
    (82) bool_op -> . LESSEQ
    (83) bool_op -> . EQUAL
    (84) bool_op -> . NOTEQUAL
    (85) bool_op -> . AND
    (86) bool_op -> . OR

    SEMICOLON       shift and go to state 132
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120
    GREATER         shift and go to state 121
    LESS            shift and go to state 122
    GREATEREQ       shift and go to state 123
    LESSEQ          shift and go to state 124
    EQUAL           shift and go to state 125
    NOTEQUAL        shift and go to state 126
    AND             shift and go to state 127
    OR              shift and go to state 128

    arith_op                       shift and go to state 115
    bool_op                        shift and go to state 116

state 101

    (41) stmt -> RETURN SEMICOLON .

    RCURLY          reduce using rule 41 (stmt -> RETURN SEMICOLON .)
    ELSE            reduce using rule 41 (stmt -> RETURN SEMICOLON .)


state 102

    (43) stmt -> BREAK SEMICOLON .

    RCURLY          reduce using rule 43 (stmt -> BREAK SEMICOLON .)
    ELSE            reduce using rule 43 (stmt -> BREAK SEMICOLON .)


state 103

    (44) stmt -> CONTINUE SEMICOLON .

    RCURLY          reduce using rule 44 (stmt -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 44 (stmt -> CONTINUE SEMICOLON .)


state 104

    (74) assign -> lhs SETEQUAL . expression
    (69) expression -> . primary
    (70) expression -> . assign
    (71) expression -> . expression arith_op expression
    (72) expression -> . expression bool_op expression
    (73) expression -> . unary_op expression
    (54) primary -> . literal
    (55) primary -> . THIS
    (56) primary -> . SUPER
    (57) primary -> . LPAREN expression RPAREN
    (58) primary -> . NEW ID
    (59) primary -> . NEW ID LPAREN arguments RPAREN
    (60) primary -> . method_invocation
    (61) primary -> . lhs
    (74) assign -> . lhs SETEQUAL expression
    (87) unary_op -> . PLUS
    (88) unary_op -> . MINUS
    (89) unary_op -> . NOT
    (48) literal -> . INTEGER
    (49) literal -> . FLOAT
    (50) literal -> . STRING
    (51) literal -> . NULL
    (52) literal -> . FALSE
    (53) literal -> . TRUE
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (64) lhs -> . field_access
    (65) field_access -> . primary DOT ID
    (66) field_access -> . ID

    THIS            shift and go to state 68
    SUPER           shift and go to state 69
    LPAREN          shift and go to state 49
    NEW             shift and go to state 70
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    NOT             shift and go to state 95
    INTEGER         shift and go to state 71
    FLOAT           shift and go to state 96
    STRING          shift and go to state 72
    NULL            shift and go to state 73
    FALSE           shift and go to state 74
    TRUE            shift and go to state 75
    ID              shift and go to state 90

    lhs                            shift and go to state 92
    expression                     shift and go to state 133
    primary                        shift and go to state 87
    assign                         shift and go to state 88
    unary_op                       shift and go to state 89
    literal                        shift and go to state 67
    method_invocation              shift and go to state 91
    field_access                   shift and go to state 63

state 105

    (67) method_invocation -> field_access LPAREN . arguments RPAREN
    (68) method_invocation -> field_access LPAREN . RPAREN
    (62) arguments -> . expression
    (63) arguments -> . expression COMMA arguments
    (69) expression -> . primary
    (70) expression -> . assign
    (71) expression -> . expression arith_op expression
    (72) expression -> . expression bool_op expression
    (73) expression -> . unary_op expression
    (54) primary -> . literal
    (55) primary -> . THIS
    (56) primary -> . SUPER
    (57) primary -> . LPAREN expression RPAREN
    (58) primary -> . NEW ID
    (59) primary -> . NEW ID LPAREN arguments RPAREN
    (60) primary -> . method_invocation
    (61) primary -> . lhs
    (74) assign -> . lhs SETEQUAL expression
    (87) unary_op -> . PLUS
    (88) unary_op -> . MINUS
    (89) unary_op -> . NOT
    (48) literal -> . INTEGER
    (49) literal -> . FLOAT
    (50) literal -> . STRING
    (51) literal -> . NULL
    (52) literal -> . FALSE
    (53) literal -> . TRUE
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (64) lhs -> . field_access
    (65) field_access -> . primary DOT ID
    (66) field_access -> . ID

    RPAREN          shift and go to state 135
    THIS            shift and go to state 68
    SUPER           shift and go to state 69
    LPAREN          shift and go to state 49
    NEW             shift and go to state 70
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    NOT             shift and go to state 95
    INTEGER         shift and go to state 71
    FLOAT           shift and go to state 96
    STRING          shift and go to state 72
    NULL            shift and go to state 73
    FALSE           shift and go to state 74
    TRUE            shift and go to state 75
    ID              shift and go to state 90

    field_access                   shift and go to state 63
    arguments                      shift and go to state 134
    expression                     shift and go to state 136
    primary                        shift and go to state 87
    assign                         shift and go to state 88
    unary_op                       shift and go to state 89
    literal                        shift and go to state 67
    method_invocation              shift and go to state 91
    lhs                            shift and go to state 92

state 106

    (65) field_access -> primary DOT . ID

    ID              shift and go to state 137


state 107

    (58) primary -> NEW ID .
    (59) primary -> NEW ID . LPAREN arguments RPAREN

    DOT             reduce using rule 58 (primary -> NEW ID .)
    RPAREN          reduce using rule 58 (primary -> NEW ID .)
    PLUS            reduce using rule 58 (primary -> NEW ID .)
    MINUS           reduce using rule 58 (primary -> NEW ID .)
    TIMES           reduce using rule 58 (primary -> NEW ID .)
    DIVIDE          reduce using rule 58 (primary -> NEW ID .)
    GREATER         reduce using rule 58 (primary -> NEW ID .)
    LESS            reduce using rule 58 (primary -> NEW ID .)
    GREATEREQ       reduce using rule 58 (primary -> NEW ID .)
    LESSEQ          reduce using rule 58 (primary -> NEW ID .)
    EQUAL           reduce using rule 58 (primary -> NEW ID .)
    NOTEQUAL        reduce using rule 58 (primary -> NEW ID .)
    AND             reduce using rule 58 (primary -> NEW ID .)
    OR              reduce using rule 58 (primary -> NEW ID .)
    SEMICOLON       reduce using rule 58 (primary -> NEW ID .)
    COMMA           reduce using rule 58 (primary -> NEW ID .)
    LPAREN          shift and go to state 138


state 108

    (32) formals -> formal_param COMMA formals .

    LCURLY          reduce using rule 32 (formals -> formal_param COMMA formals .)
    RCURLY          reduce using rule 32 (formals -> formal_param COMMA formals .)
    PUBLIC          reduce using rule 32 (formals -> formal_param COMMA formals .)
    PRIVATE         reduce using rule 32 (formals -> formal_param COMMA formals .)
    VOID            reduce using rule 32 (formals -> formal_param COMMA formals .)
    ID              reduce using rule 32 (formals -> formal_param COMMA formals .)
    INT             reduce using rule 32 (formals -> formal_param COMMA formals .)
    FLOAT           reduce using rule 32 (formals -> formal_param COMMA formals .)
    BOOLEAN         reduce using rule 32 (formals -> formal_param COMMA formals .)
    RPAREN          reduce using rule 32 (formals -> formal_param COMMA formals .)


state 109

    (27) method_decl -> modifier VOID ID LPAREN RPAREN . block
    (34) block -> . LCURLY stmt RCURLY
    (35) block -> . empty
    (92) empty -> .

    LCURLY          shift and go to state 37
    RCURLY          reduce using rule 92 (empty -> .)
    PUBLIC          reduce using rule 92 (empty -> .)
    PRIVATE         reduce using rule 92 (empty -> .)
    VOID            reduce using rule 92 (empty -> .)
    ID              reduce using rule 92 (empty -> .)
    INT             reduce using rule 92 (empty -> .)
    FLOAT           reduce using rule 92 (empty -> .)
    BOOLEAN         reduce using rule 92 (empty -> .)

    block                          shift and go to state 139
    empty                          shift and go to state 38

state 110

    (28) method_decl -> modifier VOID ID LPAREN formals . RPAREN block

    RPAREN          shift and go to state 140


state 111

    (25) method_decl -> modifier type ID LPAREN RPAREN block .

    RCURLY          reduce using rule 25 (method_decl -> modifier type ID LPAREN RPAREN block .)
    PUBLIC          reduce using rule 25 (method_decl -> modifier type ID LPAREN RPAREN block .)
    PRIVATE         reduce using rule 25 (method_decl -> modifier type ID LPAREN RPAREN block .)
    VOID            reduce using rule 25 (method_decl -> modifier type ID LPAREN RPAREN block .)
    ID              reduce using rule 25 (method_decl -> modifier type ID LPAREN RPAREN block .)
    INT             reduce using rule 25 (method_decl -> modifier type ID LPAREN RPAREN block .)
    FLOAT           reduce using rule 25 (method_decl -> modifier type ID LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 25 (method_decl -> modifier type ID LPAREN RPAREN block .)


state 112

    (26) method_decl -> modifier type ID LPAREN formals RPAREN . block
    (34) block -> . LCURLY stmt RCURLY
    (35) block -> . empty
    (92) empty -> .

    LCURLY          shift and go to state 37
    RCURLY          reduce using rule 92 (empty -> .)
    PUBLIC          reduce using rule 92 (empty -> .)
    PRIVATE         reduce using rule 92 (empty -> .)
    VOID            reduce using rule 92 (empty -> .)
    ID              reduce using rule 92 (empty -> .)
    INT             reduce using rule 92 (empty -> .)
    FLOAT           reduce using rule 92 (empty -> .)
    BOOLEAN         reduce using rule 92 (empty -> .)

    block                          shift and go to state 141
    empty                          shift and go to state 38

state 113

    (36) stmt -> IF LPAREN expression . RPAREN stmt
    (37) stmt -> IF LPAREN expression . RPAREN stmt ELSE stmt
    (71) expression -> expression . arith_op expression
    (72) expression -> expression . bool_op expression
    (75) arith_op -> . PLUS
    (76) arith_op -> . MINUS
    (77) arith_op -> . TIMES
    (78) arith_op -> . DIVIDE
    (79) bool_op -> . GREATER
    (80) bool_op -> . LESS
    (81) bool_op -> . GREATEREQ
    (82) bool_op -> . LESSEQ
    (83) bool_op -> . EQUAL
    (84) bool_op -> . NOTEQUAL
    (85) bool_op -> . AND
    (86) bool_op -> . OR

    RPAREN          shift and go to state 142
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120
    GREATER         shift and go to state 121
    LESS            shift and go to state 122
    GREATEREQ       shift and go to state 123
    LESSEQ          shift and go to state 124
    EQUAL           shift and go to state 125
    NOTEQUAL        shift and go to state 126
    AND             shift and go to state 127
    OR              shift and go to state 128

    arith_op                       shift and go to state 115
    bool_op                        shift and go to state 116

state 114

    (57) primary -> LPAREN expression RPAREN .

    DOT             reduce using rule 57 (primary -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 57 (primary -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 57 (primary -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 57 (primary -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 57 (primary -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 57 (primary -> LPAREN expression RPAREN .)
    GREATER         reduce using rule 57 (primary -> LPAREN expression RPAREN .)
    LESS            reduce using rule 57 (primary -> LPAREN expression RPAREN .)
    GREATEREQ       reduce using rule 57 (primary -> LPAREN expression RPAREN .)
    LESSEQ          reduce using rule 57 (primary -> LPAREN expression RPAREN .)
    EQUAL           reduce using rule 57 (primary -> LPAREN expression RPAREN .)
    NOTEQUAL        reduce using rule 57 (primary -> LPAREN expression RPAREN .)
    AND             reduce using rule 57 (primary -> LPAREN expression RPAREN .)
    OR              reduce using rule 57 (primary -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 57 (primary -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 57 (primary -> LPAREN expression RPAREN .)


state 115

    (71) expression -> expression arith_op . expression
    (69) expression -> . primary
    (70) expression -> . assign
    (71) expression -> . expression arith_op expression
    (72) expression -> . expression bool_op expression
    (73) expression -> . unary_op expression
    (54) primary -> . literal
    (55) primary -> . THIS
    (56) primary -> . SUPER
    (57) primary -> . LPAREN expression RPAREN
    (58) primary -> . NEW ID
    (59) primary -> . NEW ID LPAREN arguments RPAREN
    (60) primary -> . method_invocation
    (61) primary -> . lhs
    (74) assign -> . lhs SETEQUAL expression
    (87) unary_op -> . PLUS
    (88) unary_op -> . MINUS
    (89) unary_op -> . NOT
    (48) literal -> . INTEGER
    (49) literal -> . FLOAT
    (50) literal -> . STRING
    (51) literal -> . NULL
    (52) literal -> . FALSE
    (53) literal -> . TRUE
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (64) lhs -> . field_access
    (65) field_access -> . primary DOT ID
    (66) field_access -> . ID

    THIS            shift and go to state 68
    SUPER           shift and go to state 69
    LPAREN          shift and go to state 49
    NEW             shift and go to state 70
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    NOT             shift and go to state 95
    INTEGER         shift and go to state 71
    FLOAT           shift and go to state 96
    STRING          shift and go to state 72
    NULL            shift and go to state 73
    FALSE           shift and go to state 74
    TRUE            shift and go to state 75
    ID              shift and go to state 90

    expression                     shift and go to state 143
    primary                        shift and go to state 87
    assign                         shift and go to state 88
    unary_op                       shift and go to state 89
    literal                        shift and go to state 67
    method_invocation              shift and go to state 91
    lhs                            shift and go to state 92
    field_access                   shift and go to state 63

state 116

    (72) expression -> expression bool_op . expression
    (69) expression -> . primary
    (70) expression -> . assign
    (71) expression -> . expression arith_op expression
    (72) expression -> . expression bool_op expression
    (73) expression -> . unary_op expression
    (54) primary -> . literal
    (55) primary -> . THIS
    (56) primary -> . SUPER
    (57) primary -> . LPAREN expression RPAREN
    (58) primary -> . NEW ID
    (59) primary -> . NEW ID LPAREN arguments RPAREN
    (60) primary -> . method_invocation
    (61) primary -> . lhs
    (74) assign -> . lhs SETEQUAL expression
    (87) unary_op -> . PLUS
    (88) unary_op -> . MINUS
    (89) unary_op -> . NOT
    (48) literal -> . INTEGER
    (49) literal -> . FLOAT
    (50) literal -> . STRING
    (51) literal -> . NULL
    (52) literal -> . FALSE
    (53) literal -> . TRUE
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (64) lhs -> . field_access
    (65) field_access -> . primary DOT ID
    (66) field_access -> . ID

    THIS            shift and go to state 68
    SUPER           shift and go to state 69
    LPAREN          shift and go to state 49
    NEW             shift and go to state 70
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    NOT             shift and go to state 95
    INTEGER         shift and go to state 71
    FLOAT           shift and go to state 96
    STRING          shift and go to state 72
    NULL            shift and go to state 73
    FALSE           shift and go to state 74
    TRUE            shift and go to state 75
    ID              shift and go to state 90

    expression                     shift and go to state 144
    primary                        shift and go to state 87
    assign                         shift and go to state 88
    unary_op                       shift and go to state 89
    literal                        shift and go to state 67
    method_invocation              shift and go to state 91
    lhs                            shift and go to state 92
    field_access                   shift and go to state 63

state 117

    (75) arith_op -> PLUS .

    THIS            reduce using rule 75 (arith_op -> PLUS .)
    SUPER           reduce using rule 75 (arith_op -> PLUS .)
    LPAREN          reduce using rule 75 (arith_op -> PLUS .)
    NEW             reduce using rule 75 (arith_op -> PLUS .)
    PLUS            reduce using rule 75 (arith_op -> PLUS .)
    MINUS           reduce using rule 75 (arith_op -> PLUS .)
    NOT             reduce using rule 75 (arith_op -> PLUS .)
    INTEGER         reduce using rule 75 (arith_op -> PLUS .)
    FLOAT           reduce using rule 75 (arith_op -> PLUS .)
    STRING          reduce using rule 75 (arith_op -> PLUS .)
    NULL            reduce using rule 75 (arith_op -> PLUS .)
    FALSE           reduce using rule 75 (arith_op -> PLUS .)
    TRUE            reduce using rule 75 (arith_op -> PLUS .)
    ID              reduce using rule 75 (arith_op -> PLUS .)


state 118

    (76) arith_op -> MINUS .

    THIS            reduce using rule 76 (arith_op -> MINUS .)
    SUPER           reduce using rule 76 (arith_op -> MINUS .)
    LPAREN          reduce using rule 76 (arith_op -> MINUS .)
    NEW             reduce using rule 76 (arith_op -> MINUS .)
    PLUS            reduce using rule 76 (arith_op -> MINUS .)
    MINUS           reduce using rule 76 (arith_op -> MINUS .)
    NOT             reduce using rule 76 (arith_op -> MINUS .)
    INTEGER         reduce using rule 76 (arith_op -> MINUS .)
    FLOAT           reduce using rule 76 (arith_op -> MINUS .)
    STRING          reduce using rule 76 (arith_op -> MINUS .)
    NULL            reduce using rule 76 (arith_op -> MINUS .)
    FALSE           reduce using rule 76 (arith_op -> MINUS .)
    TRUE            reduce using rule 76 (arith_op -> MINUS .)
    ID              reduce using rule 76 (arith_op -> MINUS .)


state 119

    (77) arith_op -> TIMES .

    THIS            reduce using rule 77 (arith_op -> TIMES .)
    SUPER           reduce using rule 77 (arith_op -> TIMES .)
    LPAREN          reduce using rule 77 (arith_op -> TIMES .)
    NEW             reduce using rule 77 (arith_op -> TIMES .)
    PLUS            reduce using rule 77 (arith_op -> TIMES .)
    MINUS           reduce using rule 77 (arith_op -> TIMES .)
    NOT             reduce using rule 77 (arith_op -> TIMES .)
    INTEGER         reduce using rule 77 (arith_op -> TIMES .)
    FLOAT           reduce using rule 77 (arith_op -> TIMES .)
    STRING          reduce using rule 77 (arith_op -> TIMES .)
    NULL            reduce using rule 77 (arith_op -> TIMES .)
    FALSE           reduce using rule 77 (arith_op -> TIMES .)
    TRUE            reduce using rule 77 (arith_op -> TIMES .)
    ID              reduce using rule 77 (arith_op -> TIMES .)


state 120

    (78) arith_op -> DIVIDE .

    THIS            reduce using rule 78 (arith_op -> DIVIDE .)
    SUPER           reduce using rule 78 (arith_op -> DIVIDE .)
    LPAREN          reduce using rule 78 (arith_op -> DIVIDE .)
    NEW             reduce using rule 78 (arith_op -> DIVIDE .)
    PLUS            reduce using rule 78 (arith_op -> DIVIDE .)
    MINUS           reduce using rule 78 (arith_op -> DIVIDE .)
    NOT             reduce using rule 78 (arith_op -> DIVIDE .)
    INTEGER         reduce using rule 78 (arith_op -> DIVIDE .)
    FLOAT           reduce using rule 78 (arith_op -> DIVIDE .)
    STRING          reduce using rule 78 (arith_op -> DIVIDE .)
    NULL            reduce using rule 78 (arith_op -> DIVIDE .)
    FALSE           reduce using rule 78 (arith_op -> DIVIDE .)
    TRUE            reduce using rule 78 (arith_op -> DIVIDE .)
    ID              reduce using rule 78 (arith_op -> DIVIDE .)


state 121

    (79) bool_op -> GREATER .

    THIS            reduce using rule 79 (bool_op -> GREATER .)
    SUPER           reduce using rule 79 (bool_op -> GREATER .)
    LPAREN          reduce using rule 79 (bool_op -> GREATER .)
    NEW             reduce using rule 79 (bool_op -> GREATER .)
    PLUS            reduce using rule 79 (bool_op -> GREATER .)
    MINUS           reduce using rule 79 (bool_op -> GREATER .)
    NOT             reduce using rule 79 (bool_op -> GREATER .)
    INTEGER         reduce using rule 79 (bool_op -> GREATER .)
    FLOAT           reduce using rule 79 (bool_op -> GREATER .)
    STRING          reduce using rule 79 (bool_op -> GREATER .)
    NULL            reduce using rule 79 (bool_op -> GREATER .)
    FALSE           reduce using rule 79 (bool_op -> GREATER .)
    TRUE            reduce using rule 79 (bool_op -> GREATER .)
    ID              reduce using rule 79 (bool_op -> GREATER .)


state 122

    (80) bool_op -> LESS .

    THIS            reduce using rule 80 (bool_op -> LESS .)
    SUPER           reduce using rule 80 (bool_op -> LESS .)
    LPAREN          reduce using rule 80 (bool_op -> LESS .)
    NEW             reduce using rule 80 (bool_op -> LESS .)
    PLUS            reduce using rule 80 (bool_op -> LESS .)
    MINUS           reduce using rule 80 (bool_op -> LESS .)
    NOT             reduce using rule 80 (bool_op -> LESS .)
    INTEGER         reduce using rule 80 (bool_op -> LESS .)
    FLOAT           reduce using rule 80 (bool_op -> LESS .)
    STRING          reduce using rule 80 (bool_op -> LESS .)
    NULL            reduce using rule 80 (bool_op -> LESS .)
    FALSE           reduce using rule 80 (bool_op -> LESS .)
    TRUE            reduce using rule 80 (bool_op -> LESS .)
    ID              reduce using rule 80 (bool_op -> LESS .)


state 123

    (81) bool_op -> GREATEREQ .

    THIS            reduce using rule 81 (bool_op -> GREATEREQ .)
    SUPER           reduce using rule 81 (bool_op -> GREATEREQ .)
    LPAREN          reduce using rule 81 (bool_op -> GREATEREQ .)
    NEW             reduce using rule 81 (bool_op -> GREATEREQ .)
    PLUS            reduce using rule 81 (bool_op -> GREATEREQ .)
    MINUS           reduce using rule 81 (bool_op -> GREATEREQ .)
    NOT             reduce using rule 81 (bool_op -> GREATEREQ .)
    INTEGER         reduce using rule 81 (bool_op -> GREATEREQ .)
    FLOAT           reduce using rule 81 (bool_op -> GREATEREQ .)
    STRING          reduce using rule 81 (bool_op -> GREATEREQ .)
    NULL            reduce using rule 81 (bool_op -> GREATEREQ .)
    FALSE           reduce using rule 81 (bool_op -> GREATEREQ .)
    TRUE            reduce using rule 81 (bool_op -> GREATEREQ .)
    ID              reduce using rule 81 (bool_op -> GREATEREQ .)


state 124

    (82) bool_op -> LESSEQ .

    THIS            reduce using rule 82 (bool_op -> LESSEQ .)
    SUPER           reduce using rule 82 (bool_op -> LESSEQ .)
    LPAREN          reduce using rule 82 (bool_op -> LESSEQ .)
    NEW             reduce using rule 82 (bool_op -> LESSEQ .)
    PLUS            reduce using rule 82 (bool_op -> LESSEQ .)
    MINUS           reduce using rule 82 (bool_op -> LESSEQ .)
    NOT             reduce using rule 82 (bool_op -> LESSEQ .)
    INTEGER         reduce using rule 82 (bool_op -> LESSEQ .)
    FLOAT           reduce using rule 82 (bool_op -> LESSEQ .)
    STRING          reduce using rule 82 (bool_op -> LESSEQ .)
    NULL            reduce using rule 82 (bool_op -> LESSEQ .)
    FALSE           reduce using rule 82 (bool_op -> LESSEQ .)
    TRUE            reduce using rule 82 (bool_op -> LESSEQ .)
    ID              reduce using rule 82 (bool_op -> LESSEQ .)


state 125

    (83) bool_op -> EQUAL .

    THIS            reduce using rule 83 (bool_op -> EQUAL .)
    SUPER           reduce using rule 83 (bool_op -> EQUAL .)
    LPAREN          reduce using rule 83 (bool_op -> EQUAL .)
    NEW             reduce using rule 83 (bool_op -> EQUAL .)
    PLUS            reduce using rule 83 (bool_op -> EQUAL .)
    MINUS           reduce using rule 83 (bool_op -> EQUAL .)
    NOT             reduce using rule 83 (bool_op -> EQUAL .)
    INTEGER         reduce using rule 83 (bool_op -> EQUAL .)
    FLOAT           reduce using rule 83 (bool_op -> EQUAL .)
    STRING          reduce using rule 83 (bool_op -> EQUAL .)
    NULL            reduce using rule 83 (bool_op -> EQUAL .)
    FALSE           reduce using rule 83 (bool_op -> EQUAL .)
    TRUE            reduce using rule 83 (bool_op -> EQUAL .)
    ID              reduce using rule 83 (bool_op -> EQUAL .)


state 126

    (84) bool_op -> NOTEQUAL .

    THIS            reduce using rule 84 (bool_op -> NOTEQUAL .)
    SUPER           reduce using rule 84 (bool_op -> NOTEQUAL .)
    LPAREN          reduce using rule 84 (bool_op -> NOTEQUAL .)
    NEW             reduce using rule 84 (bool_op -> NOTEQUAL .)
    PLUS            reduce using rule 84 (bool_op -> NOTEQUAL .)
    MINUS           reduce using rule 84 (bool_op -> NOTEQUAL .)
    NOT             reduce using rule 84 (bool_op -> NOTEQUAL .)
    INTEGER         reduce using rule 84 (bool_op -> NOTEQUAL .)
    FLOAT           reduce using rule 84 (bool_op -> NOTEQUAL .)
    STRING          reduce using rule 84 (bool_op -> NOTEQUAL .)
    NULL            reduce using rule 84 (bool_op -> NOTEQUAL .)
    FALSE           reduce using rule 84 (bool_op -> NOTEQUAL .)
    TRUE            reduce using rule 84 (bool_op -> NOTEQUAL .)
    ID              reduce using rule 84 (bool_op -> NOTEQUAL .)


state 127

    (85) bool_op -> AND .

    THIS            reduce using rule 85 (bool_op -> AND .)
    SUPER           reduce using rule 85 (bool_op -> AND .)
    LPAREN          reduce using rule 85 (bool_op -> AND .)
    NEW             reduce using rule 85 (bool_op -> AND .)
    PLUS            reduce using rule 85 (bool_op -> AND .)
    MINUS           reduce using rule 85 (bool_op -> AND .)
    NOT             reduce using rule 85 (bool_op -> AND .)
    INTEGER         reduce using rule 85 (bool_op -> AND .)
    FLOAT           reduce using rule 85 (bool_op -> AND .)
    STRING          reduce using rule 85 (bool_op -> AND .)
    NULL            reduce using rule 85 (bool_op -> AND .)
    FALSE           reduce using rule 85 (bool_op -> AND .)
    TRUE            reduce using rule 85 (bool_op -> AND .)
    ID              reduce using rule 85 (bool_op -> AND .)


state 128

    (86) bool_op -> OR .

    THIS            reduce using rule 86 (bool_op -> OR .)
    SUPER           reduce using rule 86 (bool_op -> OR .)
    LPAREN          reduce using rule 86 (bool_op -> OR .)
    NEW             reduce using rule 86 (bool_op -> OR .)
    PLUS            reduce using rule 86 (bool_op -> OR .)
    MINUS           reduce using rule 86 (bool_op -> OR .)
    NOT             reduce using rule 86 (bool_op -> OR .)
    INTEGER         reduce using rule 86 (bool_op -> OR .)
    FLOAT           reduce using rule 86 (bool_op -> OR .)
    STRING          reduce using rule 86 (bool_op -> OR .)
    NULL            reduce using rule 86 (bool_op -> OR .)
    FALSE           reduce using rule 86 (bool_op -> OR .)
    TRUE            reduce using rule 86 (bool_op -> OR .)
    ID              reduce using rule 86 (bool_op -> OR .)


state 129

    (73) expression -> unary_op expression .
    (71) expression -> expression . arith_op expression
    (72) expression -> expression . bool_op expression
    (75) arith_op -> . PLUS
    (76) arith_op -> . MINUS
    (77) arith_op -> . TIMES
    (78) arith_op -> . DIVIDE
    (79) bool_op -> . GREATER
    (80) bool_op -> . LESS
    (81) bool_op -> . GREATEREQ
    (82) bool_op -> . LESSEQ
    (83) bool_op -> . EQUAL
    (84) bool_op -> . NOTEQUAL
    (85) bool_op -> . AND
    (86) bool_op -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 73 (expression -> unary_op expression .)
    SEMICOLON       reduce using rule 73 (expression -> unary_op expression .)
    COMMA           reduce using rule 73 (expression -> unary_op expression .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120
    GREATER         shift and go to state 121
    LESS            shift and go to state 122
    GREATEREQ       shift and go to state 123
    LESSEQ          shift and go to state 124
    EQUAL           shift and go to state 125
    NOTEQUAL        shift and go to state 126
    AND             shift and go to state 127
    OR              shift and go to state 128

  ! PLUS            [ reduce using rule 73 (expression -> unary_op expression .) ]
  ! MINUS           [ reduce using rule 73 (expression -> unary_op expression .) ]
  ! TIMES           [ reduce using rule 73 (expression -> unary_op expression .) ]
  ! DIVIDE          [ reduce using rule 73 (expression -> unary_op expression .) ]
  ! GREATER         [ reduce using rule 73 (expression -> unary_op expression .) ]
  ! LESS            [ reduce using rule 73 (expression -> unary_op expression .) ]
  ! GREATEREQ       [ reduce using rule 73 (expression -> unary_op expression .) ]
  ! LESSEQ          [ reduce using rule 73 (expression -> unary_op expression .) ]
  ! EQUAL           [ reduce using rule 73 (expression -> unary_op expression .) ]
  ! NOTEQUAL        [ reduce using rule 73 (expression -> unary_op expression .) ]
  ! AND             [ reduce using rule 73 (expression -> unary_op expression .) ]
  ! OR              [ reduce using rule 73 (expression -> unary_op expression .) ]

    arith_op                       shift and go to state 115
    bool_op                        shift and go to state 116

state 130

    (38) stmt -> WHILE LPAREN expression . RPAREN stmt
    (71) expression -> expression . arith_op expression
    (72) expression -> expression . bool_op expression
    (75) arith_op -> . PLUS
    (76) arith_op -> . MINUS
    (77) arith_op -> . TIMES
    (78) arith_op -> . DIVIDE
    (79) bool_op -> . GREATER
    (80) bool_op -> . LESS
    (81) bool_op -> . GREATEREQ
    (82) bool_op -> . LESSEQ
    (83) bool_op -> . EQUAL
    (84) bool_op -> . NOTEQUAL
    (85) bool_op -> . AND
    (86) bool_op -> . OR

    RPAREN          shift and go to state 145
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120
    GREATER         shift and go to state 121
    LESS            shift and go to state 122
    GREATEREQ       shift and go to state 123
    LESSEQ          shift and go to state 124
    EQUAL           shift and go to state 125
    NOTEQUAL        shift and go to state 126
    AND             shift and go to state 127
    OR              shift and go to state 128

    arith_op                       shift and go to state 115
    bool_op                        shift and go to state 116

state 131

    (39) stmt -> FOR LPAREN stmt_expression . SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt

    SEMICOLON       shift and go to state 146


state 132

    (40) stmt -> RETURN expression SEMICOLON .

    RCURLY          reduce using rule 40 (stmt -> RETURN expression SEMICOLON .)
    ELSE            reduce using rule 40 (stmt -> RETURN expression SEMICOLON .)


state 133

    (74) assign -> lhs SETEQUAL expression .
    (71) expression -> expression . arith_op expression
    (72) expression -> expression . bool_op expression
    (75) arith_op -> . PLUS
    (76) arith_op -> . MINUS
    (77) arith_op -> . TIMES
    (78) arith_op -> . DIVIDE
    (79) bool_op -> . GREATER
    (80) bool_op -> . LESS
    (81) bool_op -> . GREATEREQ
    (82) bool_op -> . LESSEQ
    (83) bool_op -> . EQUAL
    (84) bool_op -> . NOTEQUAL
    (85) bool_op -> . AND
    (86) bool_op -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 74 (assign -> lhs SETEQUAL expression .)
    RPAREN          reduce using rule 74 (assign -> lhs SETEQUAL expression .)
    COMMA           reduce using rule 74 (assign -> lhs SETEQUAL expression .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120
    GREATER         shift and go to state 121
    LESS            shift and go to state 122
    GREATEREQ       shift and go to state 123
    LESSEQ          shift and go to state 124
    EQUAL           shift and go to state 125
    NOTEQUAL        shift and go to state 126
    AND             shift and go to state 127
    OR              shift and go to state 128

  ! PLUS            [ reduce using rule 74 (assign -> lhs SETEQUAL expression .) ]
  ! MINUS           [ reduce using rule 74 (assign -> lhs SETEQUAL expression .) ]
  ! TIMES           [ reduce using rule 74 (assign -> lhs SETEQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 74 (assign -> lhs SETEQUAL expression .) ]
  ! GREATER         [ reduce using rule 74 (assign -> lhs SETEQUAL expression .) ]
  ! LESS            [ reduce using rule 74 (assign -> lhs SETEQUAL expression .) ]
  ! GREATEREQ       [ reduce using rule 74 (assign -> lhs SETEQUAL expression .) ]
  ! LESSEQ          [ reduce using rule 74 (assign -> lhs SETEQUAL expression .) ]
  ! EQUAL           [ reduce using rule 74 (assign -> lhs SETEQUAL expression .) ]
  ! NOTEQUAL        [ reduce using rule 74 (assign -> lhs SETEQUAL expression .) ]
  ! AND             [ reduce using rule 74 (assign -> lhs SETEQUAL expression .) ]
  ! OR              [ reduce using rule 74 (assign -> lhs SETEQUAL expression .) ]

    arith_op                       shift and go to state 115
    bool_op                        shift and go to state 116

state 134

    (67) method_invocation -> field_access LPAREN arguments . RPAREN

    RPAREN          shift and go to state 147


state 135

    (68) method_invocation -> field_access LPAREN RPAREN .

    SEMICOLON       reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    DOT             reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    RPAREN          reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    PLUS            reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    MINUS           reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    TIMES           reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    DIVIDE          reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    GREATER         reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    LESS            reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    GREATEREQ       reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    LESSEQ          reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    EQUAL           reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    NOTEQUAL        reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    AND             reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    OR              reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    COMMA           reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)


state 136

    (62) arguments -> expression .
    (63) arguments -> expression . COMMA arguments
    (71) expression -> expression . arith_op expression
    (72) expression -> expression . bool_op expression
    (75) arith_op -> . PLUS
    (76) arith_op -> . MINUS
    (77) arith_op -> . TIMES
    (78) arith_op -> . DIVIDE
    (79) bool_op -> . GREATER
    (80) bool_op -> . LESS
    (81) bool_op -> . GREATEREQ
    (82) bool_op -> . LESSEQ
    (83) bool_op -> . EQUAL
    (84) bool_op -> . NOTEQUAL
    (85) bool_op -> . AND
    (86) bool_op -> . OR

    RPAREN          reduce using rule 62 (arguments -> expression .)
    COMMA           shift and go to state 148
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120
    GREATER         shift and go to state 121
    LESS            shift and go to state 122
    GREATEREQ       shift and go to state 123
    LESSEQ          shift and go to state 124
    EQUAL           shift and go to state 125
    NOTEQUAL        shift and go to state 126
    AND             shift and go to state 127
    OR              shift and go to state 128

    arith_op                       shift and go to state 115
    bool_op                        shift and go to state 116

state 137

    (65) field_access -> primary DOT ID .

    LPAREN          reduce using rule 65 (field_access -> primary DOT ID .)
    SETEQUAL        reduce using rule 65 (field_access -> primary DOT ID .)
    DOT             reduce using rule 65 (field_access -> primary DOT ID .)
    RPAREN          reduce using rule 65 (field_access -> primary DOT ID .)
    PLUS            reduce using rule 65 (field_access -> primary DOT ID .)
    MINUS           reduce using rule 65 (field_access -> primary DOT ID .)
    TIMES           reduce using rule 65 (field_access -> primary DOT ID .)
    DIVIDE          reduce using rule 65 (field_access -> primary DOT ID .)
    GREATER         reduce using rule 65 (field_access -> primary DOT ID .)
    LESS            reduce using rule 65 (field_access -> primary DOT ID .)
    GREATEREQ       reduce using rule 65 (field_access -> primary DOT ID .)
    LESSEQ          reduce using rule 65 (field_access -> primary DOT ID .)
    EQUAL           reduce using rule 65 (field_access -> primary DOT ID .)
    NOTEQUAL        reduce using rule 65 (field_access -> primary DOT ID .)
    AND             reduce using rule 65 (field_access -> primary DOT ID .)
    OR              reduce using rule 65 (field_access -> primary DOT ID .)
    SEMICOLON       reduce using rule 65 (field_access -> primary DOT ID .)
    COMMA           reduce using rule 65 (field_access -> primary DOT ID .)


state 138

    (59) primary -> NEW ID LPAREN . arguments RPAREN
    (62) arguments -> . expression
    (63) arguments -> . expression COMMA arguments
    (69) expression -> . primary
    (70) expression -> . assign
    (71) expression -> . expression arith_op expression
    (72) expression -> . expression bool_op expression
    (73) expression -> . unary_op expression
    (54) primary -> . literal
    (55) primary -> . THIS
    (56) primary -> . SUPER
    (57) primary -> . LPAREN expression RPAREN
    (58) primary -> . NEW ID
    (59) primary -> . NEW ID LPAREN arguments RPAREN
    (60) primary -> . method_invocation
    (61) primary -> . lhs
    (74) assign -> . lhs SETEQUAL expression
    (87) unary_op -> . PLUS
    (88) unary_op -> . MINUS
    (89) unary_op -> . NOT
    (48) literal -> . INTEGER
    (49) literal -> . FLOAT
    (50) literal -> . STRING
    (51) literal -> . NULL
    (52) literal -> . FALSE
    (53) literal -> . TRUE
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (64) lhs -> . field_access
    (65) field_access -> . primary DOT ID
    (66) field_access -> . ID

    THIS            shift and go to state 68
    SUPER           shift and go to state 69
    LPAREN          shift and go to state 49
    NEW             shift and go to state 70
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    NOT             shift and go to state 95
    INTEGER         shift and go to state 71
    FLOAT           shift and go to state 96
    STRING          shift and go to state 72
    NULL            shift and go to state 73
    FALSE           shift and go to state 74
    TRUE            shift and go to state 75
    ID              shift and go to state 90

    arguments                      shift and go to state 149
    expression                     shift and go to state 136
    primary                        shift and go to state 87
    assign                         shift and go to state 88
    unary_op                       shift and go to state 89
    literal                        shift and go to state 67
    method_invocation              shift and go to state 91
    lhs                            shift and go to state 92
    field_access                   shift and go to state 63

state 139

    (27) method_decl -> modifier VOID ID LPAREN RPAREN block .

    RCURLY          reduce using rule 27 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    PUBLIC          reduce using rule 27 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    PRIVATE         reduce using rule 27 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    VOID            reduce using rule 27 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    ID              reduce using rule 27 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    INT             reduce using rule 27 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    FLOAT           reduce using rule 27 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 27 (method_decl -> modifier VOID ID LPAREN RPAREN block .)


state 140

    (28) method_decl -> modifier VOID ID LPAREN formals RPAREN . block
    (34) block -> . LCURLY stmt RCURLY
    (35) block -> . empty
    (92) empty -> .

    LCURLY          shift and go to state 37
    RCURLY          reduce using rule 92 (empty -> .)
    PUBLIC          reduce using rule 92 (empty -> .)
    PRIVATE         reduce using rule 92 (empty -> .)
    VOID            reduce using rule 92 (empty -> .)
    ID              reduce using rule 92 (empty -> .)
    INT             reduce using rule 92 (empty -> .)
    FLOAT           reduce using rule 92 (empty -> .)
    BOOLEAN         reduce using rule 92 (empty -> .)

    block                          shift and go to state 150
    empty                          shift and go to state 38

state 141

    (26) method_decl -> modifier type ID LPAREN formals RPAREN block .

    RCURLY          reduce using rule 26 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    PUBLIC          reduce using rule 26 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 26 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    VOID            reduce using rule 26 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    ID              reduce using rule 26 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    INT             reduce using rule 26 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 26 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 26 (method_decl -> modifier type ID LPAREN formals RPAREN block .)


state 142

    (36) stmt -> IF LPAREN expression RPAREN . stmt
    (37) stmt -> IF LPAREN expression RPAREN . stmt ELSE stmt
    (36) stmt -> . IF LPAREN expression RPAREN stmt
    (37) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (38) stmt -> . WHILE LPAREN expression RPAREN stmt
    (39) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (40) stmt -> . RETURN expression SEMICOLON
    (41) stmt -> . RETURN SEMICOLON
    (42) stmt -> . stmt_expression SEMICOLON
    (43) stmt -> . BREAK SEMICOLON
    (44) stmt -> . CONTINUE SEMICOLON
    (45) stmt -> . block
    (46) stmt -> . var_decl
    (47) stmt -> . SEMICOLON
    (90) stmt_expression -> . assign
    (91) stmt_expression -> . method_invocation
    (34) block -> . LCURLY stmt RCURLY
    (35) block -> . empty
    (17) var_decl -> . type variables SEMICOLON
    (74) assign -> . lhs SETEQUAL expression
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (92) empty -> .
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (64) lhs -> . field_access
    (65) field_access -> . primary DOT ID
    (66) field_access -> . ID
    (54) primary -> . literal
    (55) primary -> . THIS
    (56) primary -> . SUPER
    (57) primary -> . LPAREN expression RPAREN
    (58) primary -> . NEW ID
    (59) primary -> . NEW ID LPAREN arguments RPAREN
    (60) primary -> . method_invocation
    (61) primary -> . lhs
    (48) literal -> . INTEGER
    (49) literal -> . FLOAT
    (50) literal -> . STRING
    (51) literal -> . NULL
    (52) literal -> . FALSE
    (53) literal -> . TRUE

    IF              shift and go to state 48
    WHILE           shift and go to state 50
    FOR             shift and go to state 51
    RETURN          shift and go to state 54
    BREAK           shift and go to state 55
    CONTINUE        shift and go to state 56
    SEMICOLON       shift and go to state 53
    LCURLY          shift and go to state 37
    ELSE            reduce using rule 92 (empty -> .)
    RCURLY          reduce using rule 92 (empty -> .)
    INT             shift and go to state 25
    FLOAT           shift and go to state 64
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 65
    THIS            shift and go to state 68
    SUPER           shift and go to state 69
    LPAREN          shift and go to state 49
    NEW             shift and go to state 70
    INTEGER         shift and go to state 71
    STRING          shift and go to state 72
    NULL            shift and go to state 73
    FALSE           shift and go to state 74
    TRUE            shift and go to state 75

    stmt                           shift and go to state 151
    stmt_expression                shift and go to state 52
    block                          shift and go to state 57
    var_decl                       shift and go to state 58
    assign                         shift and go to state 59
    method_invocation              shift and go to state 60
    empty                          shift and go to state 38
    type                           shift and go to state 61
    lhs                            shift and go to state 62
    field_access                   shift and go to state 63
    primary                        shift and go to state 66
    literal                        shift and go to state 67

state 143

    (71) expression -> expression arith_op expression .
    (71) expression -> expression . arith_op expression
    (72) expression -> expression . bool_op expression
    (75) arith_op -> . PLUS
    (76) arith_op -> . MINUS
    (77) arith_op -> . TIMES
    (78) arith_op -> . DIVIDE
    (79) bool_op -> . GREATER
    (80) bool_op -> . LESS
    (81) bool_op -> . GREATEREQ
    (82) bool_op -> . LESSEQ
    (83) bool_op -> . EQUAL
    (84) bool_op -> . NOTEQUAL
    (85) bool_op -> . AND
    (86) bool_op -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 71 (expression -> expression arith_op expression .)
    SEMICOLON       reduce using rule 71 (expression -> expression arith_op expression .)
    COMMA           reduce using rule 71 (expression -> expression arith_op expression .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120
    GREATER         shift and go to state 121
    LESS            shift and go to state 122
    GREATEREQ       shift and go to state 123
    LESSEQ          shift and go to state 124
    EQUAL           shift and go to state 125
    NOTEQUAL        shift and go to state 126
    AND             shift and go to state 127
    OR              shift and go to state 128

  ! PLUS            [ reduce using rule 71 (expression -> expression arith_op expression .) ]
  ! MINUS           [ reduce using rule 71 (expression -> expression arith_op expression .) ]
  ! TIMES           [ reduce using rule 71 (expression -> expression arith_op expression .) ]
  ! DIVIDE          [ reduce using rule 71 (expression -> expression arith_op expression .) ]
  ! GREATER         [ reduce using rule 71 (expression -> expression arith_op expression .) ]
  ! LESS            [ reduce using rule 71 (expression -> expression arith_op expression .) ]
  ! GREATEREQ       [ reduce using rule 71 (expression -> expression arith_op expression .) ]
  ! LESSEQ          [ reduce using rule 71 (expression -> expression arith_op expression .) ]
  ! EQUAL           [ reduce using rule 71 (expression -> expression arith_op expression .) ]
  ! NOTEQUAL        [ reduce using rule 71 (expression -> expression arith_op expression .) ]
  ! AND             [ reduce using rule 71 (expression -> expression arith_op expression .) ]
  ! OR              [ reduce using rule 71 (expression -> expression arith_op expression .) ]

    arith_op                       shift and go to state 115
    bool_op                        shift and go to state 116

state 144

    (72) expression -> expression bool_op expression .
    (71) expression -> expression . arith_op expression
    (72) expression -> expression . bool_op expression
    (75) arith_op -> . PLUS
    (76) arith_op -> . MINUS
    (77) arith_op -> . TIMES
    (78) arith_op -> . DIVIDE
    (79) bool_op -> . GREATER
    (80) bool_op -> . LESS
    (81) bool_op -> . GREATEREQ
    (82) bool_op -> . LESSEQ
    (83) bool_op -> . EQUAL
    (84) bool_op -> . NOTEQUAL
    (85) bool_op -> . AND
    (86) bool_op -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 72 (expression -> expression bool_op expression .)
    SEMICOLON       reduce using rule 72 (expression -> expression bool_op expression .)
    COMMA           reduce using rule 72 (expression -> expression bool_op expression .)
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120
    GREATER         shift and go to state 121
    LESS            shift and go to state 122
    GREATEREQ       shift and go to state 123
    LESSEQ          shift and go to state 124
    EQUAL           shift and go to state 125
    NOTEQUAL        shift and go to state 126
    AND             shift and go to state 127
    OR              shift and go to state 128

  ! PLUS            [ reduce using rule 72 (expression -> expression bool_op expression .) ]
  ! MINUS           [ reduce using rule 72 (expression -> expression bool_op expression .) ]
  ! TIMES           [ reduce using rule 72 (expression -> expression bool_op expression .) ]
  ! DIVIDE          [ reduce using rule 72 (expression -> expression bool_op expression .) ]
  ! GREATER         [ reduce using rule 72 (expression -> expression bool_op expression .) ]
  ! LESS            [ reduce using rule 72 (expression -> expression bool_op expression .) ]
  ! GREATEREQ       [ reduce using rule 72 (expression -> expression bool_op expression .) ]
  ! LESSEQ          [ reduce using rule 72 (expression -> expression bool_op expression .) ]
  ! EQUAL           [ reduce using rule 72 (expression -> expression bool_op expression .) ]
  ! NOTEQUAL        [ reduce using rule 72 (expression -> expression bool_op expression .) ]
  ! AND             [ reduce using rule 72 (expression -> expression bool_op expression .) ]
  ! OR              [ reduce using rule 72 (expression -> expression bool_op expression .) ]

    bool_op                        shift and go to state 116
    arith_op                       shift and go to state 115

state 145

    (38) stmt -> WHILE LPAREN expression RPAREN . stmt
    (36) stmt -> . IF LPAREN expression RPAREN stmt
    (37) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (38) stmt -> . WHILE LPAREN expression RPAREN stmt
    (39) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (40) stmt -> . RETURN expression SEMICOLON
    (41) stmt -> . RETURN SEMICOLON
    (42) stmt -> . stmt_expression SEMICOLON
    (43) stmt -> . BREAK SEMICOLON
    (44) stmt -> . CONTINUE SEMICOLON
    (45) stmt -> . block
    (46) stmt -> . var_decl
    (47) stmt -> . SEMICOLON
    (90) stmt_expression -> . assign
    (91) stmt_expression -> . method_invocation
    (34) block -> . LCURLY stmt RCURLY
    (35) block -> . empty
    (17) var_decl -> . type variables SEMICOLON
    (74) assign -> . lhs SETEQUAL expression
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (92) empty -> .
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (64) lhs -> . field_access
    (65) field_access -> . primary DOT ID
    (66) field_access -> . ID
    (54) primary -> . literal
    (55) primary -> . THIS
    (56) primary -> . SUPER
    (57) primary -> . LPAREN expression RPAREN
    (58) primary -> . NEW ID
    (59) primary -> . NEW ID LPAREN arguments RPAREN
    (60) primary -> . method_invocation
    (61) primary -> . lhs
    (48) literal -> . INTEGER
    (49) literal -> . FLOAT
    (50) literal -> . STRING
    (51) literal -> . NULL
    (52) literal -> . FALSE
    (53) literal -> . TRUE

    IF              shift and go to state 48
    WHILE           shift and go to state 50
    FOR             shift and go to state 51
    RETURN          shift and go to state 54
    BREAK           shift and go to state 55
    CONTINUE        shift and go to state 56
    SEMICOLON       shift and go to state 53
    LCURLY          shift and go to state 37
    ELSE            reduce using rule 92 (empty -> .)
    RCURLY          reduce using rule 92 (empty -> .)
    INT             shift and go to state 25
    FLOAT           shift and go to state 64
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 65
    THIS            shift and go to state 68
    SUPER           shift and go to state 69
    LPAREN          shift and go to state 49
    NEW             shift and go to state 70
    INTEGER         shift and go to state 71
    STRING          shift and go to state 72
    NULL            shift and go to state 73
    FALSE           shift and go to state 74
    TRUE            shift and go to state 75

    stmt                           shift and go to state 152
    stmt_expression                shift and go to state 52
    block                          shift and go to state 57
    var_decl                       shift and go to state 58
    assign                         shift and go to state 59
    method_invocation              shift and go to state 60
    empty                          shift and go to state 38
    type                           shift and go to state 61
    lhs                            shift and go to state 62
    field_access                   shift and go to state 63
    primary                        shift and go to state 66
    literal                        shift and go to state 67

state 146

    (39) stmt -> FOR LPAREN stmt_expression SEMICOLON . expression SEMICOLON stmt_expression RPAREN stmt
    (69) expression -> . primary
    (70) expression -> . assign
    (71) expression -> . expression arith_op expression
    (72) expression -> . expression bool_op expression
    (73) expression -> . unary_op expression
    (54) primary -> . literal
    (55) primary -> . THIS
    (56) primary -> . SUPER
    (57) primary -> . LPAREN expression RPAREN
    (58) primary -> . NEW ID
    (59) primary -> . NEW ID LPAREN arguments RPAREN
    (60) primary -> . method_invocation
    (61) primary -> . lhs
    (74) assign -> . lhs SETEQUAL expression
    (87) unary_op -> . PLUS
    (88) unary_op -> . MINUS
    (89) unary_op -> . NOT
    (48) literal -> . INTEGER
    (49) literal -> . FLOAT
    (50) literal -> . STRING
    (51) literal -> . NULL
    (52) literal -> . FALSE
    (53) literal -> . TRUE
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (64) lhs -> . field_access
    (65) field_access -> . primary DOT ID
    (66) field_access -> . ID

    THIS            shift and go to state 68
    SUPER           shift and go to state 69
    LPAREN          shift and go to state 49
    NEW             shift and go to state 70
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    NOT             shift and go to state 95
    INTEGER         shift and go to state 71
    FLOAT           shift and go to state 96
    STRING          shift and go to state 72
    NULL            shift and go to state 73
    FALSE           shift and go to state 74
    TRUE            shift and go to state 75
    ID              shift and go to state 90

    expression                     shift and go to state 153
    primary                        shift and go to state 87
    assign                         shift and go to state 88
    unary_op                       shift and go to state 89
    literal                        shift and go to state 67
    method_invocation              shift and go to state 91
    lhs                            shift and go to state 92
    field_access                   shift and go to state 63

state 147

    (67) method_invocation -> field_access LPAREN arguments RPAREN .

    SEMICOLON       reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    DOT             reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    PLUS            reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    MINUS           reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    TIMES           reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    GREATER         reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    LESS            reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    GREATEREQ       reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    LESSEQ          reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    EQUAL           reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    NOTEQUAL        reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    AND             reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    OR              reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    COMMA           reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)


state 148

    (63) arguments -> expression COMMA . arguments
    (62) arguments -> . expression
    (63) arguments -> . expression COMMA arguments
    (69) expression -> . primary
    (70) expression -> . assign
    (71) expression -> . expression arith_op expression
    (72) expression -> . expression bool_op expression
    (73) expression -> . unary_op expression
    (54) primary -> . literal
    (55) primary -> . THIS
    (56) primary -> . SUPER
    (57) primary -> . LPAREN expression RPAREN
    (58) primary -> . NEW ID
    (59) primary -> . NEW ID LPAREN arguments RPAREN
    (60) primary -> . method_invocation
    (61) primary -> . lhs
    (74) assign -> . lhs SETEQUAL expression
    (87) unary_op -> . PLUS
    (88) unary_op -> . MINUS
    (89) unary_op -> . NOT
    (48) literal -> . INTEGER
    (49) literal -> . FLOAT
    (50) literal -> . STRING
    (51) literal -> . NULL
    (52) literal -> . FALSE
    (53) literal -> . TRUE
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (64) lhs -> . field_access
    (65) field_access -> . primary DOT ID
    (66) field_access -> . ID

    THIS            shift and go to state 68
    SUPER           shift and go to state 69
    LPAREN          shift and go to state 49
    NEW             shift and go to state 70
    PLUS            shift and go to state 93
    MINUS           shift and go to state 94
    NOT             shift and go to state 95
    INTEGER         shift and go to state 71
    FLOAT           shift and go to state 96
    STRING          shift and go to state 72
    NULL            shift and go to state 73
    FALSE           shift and go to state 74
    TRUE            shift and go to state 75
    ID              shift and go to state 90

    expression                     shift and go to state 136
    arguments                      shift and go to state 154
    primary                        shift and go to state 87
    assign                         shift and go to state 88
    unary_op                       shift and go to state 89
    literal                        shift and go to state 67
    method_invocation              shift and go to state 91
    lhs                            shift and go to state 92
    field_access                   shift and go to state 63

state 149

    (59) primary -> NEW ID LPAREN arguments . RPAREN

    RPAREN          shift and go to state 155


state 150

    (28) method_decl -> modifier VOID ID LPAREN formals RPAREN block .

    RCURLY          reduce using rule 28 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    PUBLIC          reduce using rule 28 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 28 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    VOID            reduce using rule 28 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    ID              reduce using rule 28 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    INT             reduce using rule 28 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 28 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 28 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)


state 151

    (36) stmt -> IF LPAREN expression RPAREN stmt .
    (37) stmt -> IF LPAREN expression RPAREN stmt . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    RCURLY          reduce using rule 36 (stmt -> IF LPAREN expression RPAREN stmt .)
    ELSE            shift and go to state 156

  ! ELSE            [ reduce using rule 36 (stmt -> IF LPAREN expression RPAREN stmt .) ]


state 152

    (38) stmt -> WHILE LPAREN expression RPAREN stmt .

    RCURLY          reduce using rule 38 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    ELSE            reduce using rule 38 (stmt -> WHILE LPAREN expression RPAREN stmt .)


state 153

    (39) stmt -> FOR LPAREN stmt_expression SEMICOLON expression . SEMICOLON stmt_expression RPAREN stmt
    (71) expression -> expression . arith_op expression
    (72) expression -> expression . bool_op expression
    (75) arith_op -> . PLUS
    (76) arith_op -> . MINUS
    (77) arith_op -> . TIMES
    (78) arith_op -> . DIVIDE
    (79) bool_op -> . GREATER
    (80) bool_op -> . LESS
    (81) bool_op -> . GREATEREQ
    (82) bool_op -> . LESSEQ
    (83) bool_op -> . EQUAL
    (84) bool_op -> . NOTEQUAL
    (85) bool_op -> . AND
    (86) bool_op -> . OR

    SEMICOLON       shift and go to state 157
    PLUS            shift and go to state 117
    MINUS           shift and go to state 118
    TIMES           shift and go to state 119
    DIVIDE          shift and go to state 120
    GREATER         shift and go to state 121
    LESS            shift and go to state 122
    GREATEREQ       shift and go to state 123
    LESSEQ          shift and go to state 124
    EQUAL           shift and go to state 125
    NOTEQUAL        shift and go to state 126
    AND             shift and go to state 127
    OR              shift and go to state 128

    arith_op                       shift and go to state 115
    bool_op                        shift and go to state 116

state 154

    (63) arguments -> expression COMMA arguments .

    RPAREN          reduce using rule 63 (arguments -> expression COMMA arguments .)


state 155

    (59) primary -> NEW ID LPAREN arguments RPAREN .

    DOT             reduce using rule 59 (primary -> NEW ID LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 59 (primary -> NEW ID LPAREN arguments RPAREN .)
    PLUS            reduce using rule 59 (primary -> NEW ID LPAREN arguments RPAREN .)
    MINUS           reduce using rule 59 (primary -> NEW ID LPAREN arguments RPAREN .)
    TIMES           reduce using rule 59 (primary -> NEW ID LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 59 (primary -> NEW ID LPAREN arguments RPAREN .)
    GREATER         reduce using rule 59 (primary -> NEW ID LPAREN arguments RPAREN .)
    LESS            reduce using rule 59 (primary -> NEW ID LPAREN arguments RPAREN .)
    GREATEREQ       reduce using rule 59 (primary -> NEW ID LPAREN arguments RPAREN .)
    LESSEQ          reduce using rule 59 (primary -> NEW ID LPAREN arguments RPAREN .)
    EQUAL           reduce using rule 59 (primary -> NEW ID LPAREN arguments RPAREN .)
    NOTEQUAL        reduce using rule 59 (primary -> NEW ID LPAREN arguments RPAREN .)
    AND             reduce using rule 59 (primary -> NEW ID LPAREN arguments RPAREN .)
    OR              reduce using rule 59 (primary -> NEW ID LPAREN arguments RPAREN .)
    SEMICOLON       reduce using rule 59 (primary -> NEW ID LPAREN arguments RPAREN .)
    COMMA           reduce using rule 59 (primary -> NEW ID LPAREN arguments RPAREN .)


state 156

    (37) stmt -> IF LPAREN expression RPAREN stmt ELSE . stmt
    (36) stmt -> . IF LPAREN expression RPAREN stmt
    (37) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (38) stmt -> . WHILE LPAREN expression RPAREN stmt
    (39) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (40) stmt -> . RETURN expression SEMICOLON
    (41) stmt -> . RETURN SEMICOLON
    (42) stmt -> . stmt_expression SEMICOLON
    (43) stmt -> . BREAK SEMICOLON
    (44) stmt -> . CONTINUE SEMICOLON
    (45) stmt -> . block
    (46) stmt -> . var_decl
    (47) stmt -> . SEMICOLON
    (90) stmt_expression -> . assign
    (91) stmt_expression -> . method_invocation
    (34) block -> . LCURLY stmt RCURLY
    (35) block -> . empty
    (17) var_decl -> . type variables SEMICOLON
    (74) assign -> . lhs SETEQUAL expression
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (92) empty -> .
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (64) lhs -> . field_access
    (65) field_access -> . primary DOT ID
    (66) field_access -> . ID
    (54) primary -> . literal
    (55) primary -> . THIS
    (56) primary -> . SUPER
    (57) primary -> . LPAREN expression RPAREN
    (58) primary -> . NEW ID
    (59) primary -> . NEW ID LPAREN arguments RPAREN
    (60) primary -> . method_invocation
    (61) primary -> . lhs
    (48) literal -> . INTEGER
    (49) literal -> . FLOAT
    (50) literal -> . STRING
    (51) literal -> . NULL
    (52) literal -> . FALSE
    (53) literal -> . TRUE

    IF              shift and go to state 48
    WHILE           shift and go to state 50
    FOR             shift and go to state 51
    RETURN          shift and go to state 54
    BREAK           shift and go to state 55
    CONTINUE        shift and go to state 56
    SEMICOLON       shift and go to state 53
    LCURLY          shift and go to state 37
    ELSE            reduce using rule 92 (empty -> .)
    RCURLY          reduce using rule 92 (empty -> .)
    INT             shift and go to state 25
    FLOAT           shift and go to state 64
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 65
    THIS            shift and go to state 68
    SUPER           shift and go to state 69
    LPAREN          shift and go to state 49
    NEW             shift and go to state 70
    INTEGER         shift and go to state 71
    STRING          shift and go to state 72
    NULL            shift and go to state 73
    FALSE           shift and go to state 74
    TRUE            shift and go to state 75

    stmt                           shift and go to state 158
    stmt_expression                shift and go to state 52
    block                          shift and go to state 57
    var_decl                       shift and go to state 58
    assign                         shift and go to state 59
    method_invocation              shift and go to state 60
    empty                          shift and go to state 38
    type                           shift and go to state 61
    lhs                            shift and go to state 62
    field_access                   shift and go to state 63
    primary                        shift and go to state 66
    literal                        shift and go to state 67

state 157

    (39) stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON . stmt_expression RPAREN stmt
    (90) stmt_expression -> . assign
    (91) stmt_expression -> . method_invocation
    (74) assign -> . lhs SETEQUAL expression
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (64) lhs -> . field_access
    (65) field_access -> . primary DOT ID
    (66) field_access -> . ID
    (54) primary -> . literal
    (55) primary -> . THIS
    (56) primary -> . SUPER
    (57) primary -> . LPAREN expression RPAREN
    (58) primary -> . NEW ID
    (59) primary -> . NEW ID LPAREN arguments RPAREN
    (60) primary -> . method_invocation
    (61) primary -> . lhs
    (48) literal -> . INTEGER
    (49) literal -> . FLOAT
    (50) literal -> . STRING
    (51) literal -> . NULL
    (52) literal -> . FALSE
    (53) literal -> . TRUE

    ID              shift and go to state 90
    THIS            shift and go to state 68
    SUPER           shift and go to state 69
    LPAREN          shift and go to state 49
    NEW             shift and go to state 70
    INTEGER         shift and go to state 71
    FLOAT           shift and go to state 96
    STRING          shift and go to state 72
    NULL            shift and go to state 73
    FALSE           shift and go to state 74
    TRUE            shift and go to state 75

    stmt_expression                shift and go to state 159
    assign                         shift and go to state 59
    method_invocation              shift and go to state 60
    lhs                            shift and go to state 62
    field_access                   shift and go to state 63
    primary                        shift and go to state 66
    literal                        shift and go to state 67

state 158

    (37) stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .

    RCURLY          reduce using rule 37 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    ELSE            reduce using rule 37 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)


state 159

    (39) stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression . RPAREN stmt

    RPAREN          shift and go to state 160


state 160

    (39) stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN . stmt
    (36) stmt -> . IF LPAREN expression RPAREN stmt
    (37) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (38) stmt -> . WHILE LPAREN expression RPAREN stmt
    (39) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (40) stmt -> . RETURN expression SEMICOLON
    (41) stmt -> . RETURN SEMICOLON
    (42) stmt -> . stmt_expression SEMICOLON
    (43) stmt -> . BREAK SEMICOLON
    (44) stmt -> . CONTINUE SEMICOLON
    (45) stmt -> . block
    (46) stmt -> . var_decl
    (47) stmt -> . SEMICOLON
    (90) stmt_expression -> . assign
    (91) stmt_expression -> . method_invocation
    (34) block -> . LCURLY stmt RCURLY
    (35) block -> . empty
    (17) var_decl -> . type variables SEMICOLON
    (74) assign -> . lhs SETEQUAL expression
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (92) empty -> .
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (64) lhs -> . field_access
    (65) field_access -> . primary DOT ID
    (66) field_access -> . ID
    (54) primary -> . literal
    (55) primary -> . THIS
    (56) primary -> . SUPER
    (57) primary -> . LPAREN expression RPAREN
    (58) primary -> . NEW ID
    (59) primary -> . NEW ID LPAREN arguments RPAREN
    (60) primary -> . method_invocation
    (61) primary -> . lhs
    (48) literal -> . INTEGER
    (49) literal -> . FLOAT
    (50) literal -> . STRING
    (51) literal -> . NULL
    (52) literal -> . FALSE
    (53) literal -> . TRUE

    IF              shift and go to state 48
    WHILE           shift and go to state 50
    FOR             shift and go to state 51
    RETURN          shift and go to state 54
    BREAK           shift and go to state 55
    CONTINUE        shift and go to state 56
    SEMICOLON       shift and go to state 53
    LCURLY          shift and go to state 37
    ELSE            reduce using rule 92 (empty -> .)
    RCURLY          reduce using rule 92 (empty -> .)
    INT             shift and go to state 25
    FLOAT           shift and go to state 64
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 65
    THIS            shift and go to state 68
    SUPER           shift and go to state 69
    LPAREN          shift and go to state 49
    NEW             shift and go to state 70
    INTEGER         shift and go to state 71
    STRING          shift and go to state 72
    NULL            shift and go to state 73
    FALSE           shift and go to state 74
    TRUE            shift and go to state 75

    stmt_expression                shift and go to state 52
    stmt                           shift and go to state 161
    block                          shift and go to state 57
    var_decl                       shift and go to state 58
    assign                         shift and go to state 59
    method_invocation              shift and go to state 60
    empty                          shift and go to state 38
    type                           shift and go to state 61
    lhs                            shift and go to state 62
    field_access                   shift and go to state 63
    primary                        shift and go to state 66
    literal                        shift and go to state 67

state 161

    (39) stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .

    RCURLY          reduce using rule 39 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    ELSE            reduce using rule 39 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PUBLIC in state 5 resolved as shift
WARNING: shift/reduce conflict for PRIVATE in state 5 resolved as shift
WARNING: shift/reduce conflict for INT in state 23 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 23 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 23 resolved as shift
WARNING: shift/reduce conflict for ID in state 23 resolved as shift
WARNING: shift/reduce conflict for PUBLIC in state 30 resolved as shift
WARNING: shift/reduce conflict for PRIVATE in state 30 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 129 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 129 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 129 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 129 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 129 resolved as shift
WARNING: shift/reduce conflict for LESS in state 129 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 129 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 129 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 129 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 129 resolved as shift
WARNING: shift/reduce conflict for AND in state 129 resolved as shift
WARNING: shift/reduce conflict for OR in state 129 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 133 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 133 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 133 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 133 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 133 resolved as shift
WARNING: shift/reduce conflict for LESS in state 133 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 133 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 133 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 133 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 133 resolved as shift
WARNING: shift/reduce conflict for AND in state 133 resolved as shift
WARNING: shift/reduce conflict for OR in state 133 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 143 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 143 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 143 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 143 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 143 resolved as shift
WARNING: shift/reduce conflict for LESS in state 143 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 143 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 143 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 143 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 143 resolved as shift
WARNING: shift/reduce conflict for AND in state 143 resolved as shift
WARNING: shift/reduce conflict for OR in state 143 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 144 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 144 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 144 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 144 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 144 resolved as shift
WARNING: shift/reduce conflict for LESS in state 144 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 144 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 144 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 144 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 144 resolved as shift
WARNING: shift/reduce conflict for AND in state 144 resolved as shift
WARNING: shift/reduce conflict for OR in state 144 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 151 resolved as shift
WARNING: reduce/reduce conflict in state 11 resolved using rule (class_body -> empty)
WARNING: rejected rule (modifier -> empty) in state 11
WARNING: reduce/reduce conflict in state 23 resolved using rule (type -> ID)
WARNING: rejected rule (empty -> <empty>) in state 23
