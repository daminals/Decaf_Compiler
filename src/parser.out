Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BOOL
    DO
    DOUBLE
    ERROR
    LBRACKET
    RBRACKET
    float_const
    int_const
    string_const

Grammar

Rule 0     S' -> start
Rule 1     start -> class_decl
Rule 2     class_decl -> CLASS ID LCURLY class_body RCURLY
Rule 3     class_decl -> CLASS ID EXTENDS ID LCURLY class_body RCURLY
Rule 4     class_body -> field_decl
Rule 5     class_body -> method_decl
Rule 6     class_body -> constructor_decl
Rule 7     class_body -> class_body field_decl
Rule 8     class_body -> class_body method_decl
Rule 9     class_body -> class_body constructor_decl
Rule 10    class_body -> empty
Rule 11    field_decl -> modifier var_decl
Rule 12    modifier -> PUBLIC
Rule 13    modifier -> PRIVATE
Rule 14    modifier -> PUBLIC STATIC
Rule 15    modifier -> PRIVATE STATIC
Rule 16    modifier -> empty
Rule 17    var_decl -> type variables SEMICOLON
Rule 18    type -> INT
Rule 19    type -> FLOAT
Rule 20    type -> BOOLEAN
Rule 21    type -> ID
Rule 22    variables -> variable
Rule 23    variables -> variable COMMA variables
Rule 24    variable -> ID
Rule 25    method_decl -> modifier type ID LPAREN RPAREN block
Rule 26    method_decl -> modifier type ID LPAREN formals RPAREN block
Rule 27    method_decl -> modifier VOID ID LPAREN RPAREN block
Rule 28    method_decl -> modifier VOID ID LPAREN formals RPAREN block
Rule 29    constructor_decl -> modifier ID block
Rule 30    constructor_decl -> modifier ID formals block
Rule 31    formals -> formal_param
Rule 32    formals -> formal_param COMMA formals
Rule 33    formal_param -> type variable
Rule 34    block -> LCURLY stmtlist RCURLY
Rule 35    block -> empty
Rule 36    stmtlist -> stmt
Rule 37    stmtlist -> stmtlist stmt
Rule 38    stmt -> IF LPAREN expression RPAREN stmt
Rule 39    stmt -> IF LPAREN expression RPAREN stmt ELSE stmt
Rule 40    stmt -> WHILE LPAREN expression RPAREN stmt
Rule 41    stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
Rule 42    stmt -> RETURN expression SEMICOLON
Rule 43    stmt -> RETURN SEMICOLON
Rule 44    stmt -> stmt_expression SEMICOLON
Rule 45    stmt -> BREAK SEMICOLON
Rule 46    stmt -> CONTINUE SEMICOLON
Rule 47    stmt -> block
Rule 48    stmt -> var_decl
Rule 49    stmt -> SEMICOLON
Rule 50    literal -> INTEGER
Rule 51    literal -> FLOAT
Rule 52    literal -> STRING
Rule 53    literal -> NULL
Rule 54    literal -> FALSE
Rule 55    literal -> TRUE
Rule 56    primary -> literal
Rule 57    primary -> THIS
Rule 58    primary -> SUPER
Rule 59    primary -> LPAREN expression RPAREN
Rule 60    primary -> NEW ID
Rule 61    primary -> NEW ID LPAREN arguments RPAREN
Rule 62    primary -> method_invocation
Rule 63    primary -> lhs
Rule 64    arguments -> expression
Rule 65    arguments -> expression COMMA arguments
Rule 66    method_invocation -> field_access LPAREN arguments RPAREN
Rule 67    method_invocation -> field_access LPAREN RPAREN
Rule 68    expression -> primary
Rule 69    expression -> assign
Rule 70    expression -> expression arith_op expression
Rule 71    expression -> expression bool_op expression
Rule 72    expression -> unary_op expression
Rule 73    lhs -> field_access
Rule 74    field_access -> primary DOT ID
Rule 75    field_access -> ID
Rule 76    assign -> lhs SETEQUAL expression
Rule 77    arith_op -> PLUS
Rule 78    arith_op -> MINUS
Rule 79    arith_op -> TIMES
Rule 80    arith_op -> DIVIDE
Rule 81    bool_op -> GREATER
Rule 82    bool_op -> LESS
Rule 83    bool_op -> GREATEREQ
Rule 84    bool_op -> LESSEQ
Rule 85    bool_op -> EQUAL
Rule 86    bool_op -> NOTEQUAL
Rule 87    bool_op -> AND
Rule 88    bool_op -> OR
Rule 89    unary_op -> PLUS
Rule 90    unary_op -> MINUS
Rule 91    unary_op -> NOT
Rule 92    stmt_expression -> assign
Rule 93    stmt_expression -> method_invocation
Rule 94    empty -> <empty>

Terminals, with rules where they appear

AND                  : 87
BOOL                 : 
BOOLEAN              : 20
BREAK                : 45
CLASS                : 2 3
COMMA                : 23 32 65
CONTINUE             : 46
DIVIDE               : 80
DO                   : 
DOT                  : 74
DOUBLE               : 
ELSE                 : 39
EQUAL                : 85
ERROR                : 
EXTENDS              : 3
FALSE                : 54
FLOAT                : 19 51
FOR                  : 41
GREATER              : 81
GREATEREQ            : 83
ID                   : 2 3 3 21 24 25 26 27 28 29 30 60 61 74 75
IF                   : 38 39
INT                  : 18
INTEGER              : 50
LBRACKET             : 
LCURLY               : 2 3 34
LESS                 : 82
LESSEQ               : 84
LPAREN               : 25 26 27 28 38 39 40 41 59 61 66 67
MINUS                : 78 90
NEW                  : 60 61
NOT                  : 91
NOTEQUAL             : 86
NULL                 : 53
OR                   : 88
PLUS                 : 77 89
PRIVATE              : 13 15
PUBLIC               : 12 14
RBRACKET             : 
RCURLY               : 2 3 34
RETURN               : 42 43
RPAREN               : 25 26 27 28 38 39 40 41 59 61 66 67
SEMICOLON            : 17 41 41 42 43 44 45 46 49
SETEQUAL             : 76
STATIC               : 14 15
STRING               : 52
SUPER                : 58
THIS                 : 57
TIMES                : 79
TRUE                 : 55
VOID                 : 27 28
WHILE                : 40
error                : 
float_const          : 
int_const            : 
string_const         : 

Nonterminals, with rules where they appear

arguments            : 61 65 66
arith_op             : 70
assign               : 69 92
block                : 25 26 27 28 29 30 47
bool_op              : 71
class_body           : 2 3 7 8 9
class_decl           : 1
constructor_decl     : 6 9
empty                : 10 16 35
expression           : 38 39 40 41 42 59 64 65 70 70 71 71 72 76
field_access         : 66 67 73
field_decl           : 4 7
formal_param         : 31 32
formals              : 26 28 30 32
lhs                  : 63 76
literal              : 56
method_decl          : 5 8
method_invocation    : 62 93
modifier             : 11 25 26 27 28 29 30
primary              : 68 74
start                : 0
stmt                 : 36 37 38 39 39 40 41
stmt_expression      : 41 41 44
stmtlist             : 34 37
type                 : 17 25 26 33
unary_op             : 72
var_decl             : 11 48
variable             : 22 23 33
variables            : 17 23

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . class_decl
    (2) class_decl -> . CLASS ID LCURLY class_body RCURLY
    (3) class_decl -> . CLASS ID EXTENDS ID LCURLY class_body RCURLY

    CLASS           shift and go to state 3

    start                          shift and go to state 1
    class_decl                     shift and go to state 2

state 1

    (0) S' -> start .



state 2

    (1) start -> class_decl .

    $end            reduce using rule 1 (start -> class_decl .)


state 3

    (2) class_decl -> CLASS . ID LCURLY class_body RCURLY
    (3) class_decl -> CLASS . ID EXTENDS ID LCURLY class_body RCURLY

    ID              shift and go to state 4


state 4

    (2) class_decl -> CLASS ID . LCURLY class_body RCURLY
    (3) class_decl -> CLASS ID . EXTENDS ID LCURLY class_body RCURLY

    LCURLY          shift and go to state 5
    EXTENDS         shift and go to state 6


state 5

    (2) class_decl -> CLASS ID LCURLY . class_body RCURLY
    (4) class_body -> . field_decl
    (5) class_body -> . method_decl
    (6) class_body -> . constructor_decl
    (7) class_body -> . class_body field_decl
    (8) class_body -> . class_body method_decl
    (9) class_body -> . class_body constructor_decl
    (10) class_body -> . empty
    (11) field_decl -> . modifier var_decl
    (25) method_decl -> . modifier type ID LPAREN RPAREN block
    (26) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (27) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (28) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (29) constructor_decl -> . modifier ID block
    (30) constructor_decl -> . modifier ID formals block
    (94) empty -> .
    (12) modifier -> . PUBLIC
    (13) modifier -> . PRIVATE
    (14) modifier -> . PUBLIC STATIC
    (15) modifier -> . PRIVATE STATIC
    (16) modifier -> . empty

  ! shift/reduce conflict for PUBLIC resolved as shift
  ! shift/reduce conflict for PRIVATE resolved as shift
    RCURLY          reduce using rule 94 (empty -> .)
    VOID            reduce using rule 94 (empty -> .)
    ID              reduce using rule 94 (empty -> .)
    INT             reduce using rule 94 (empty -> .)
    FLOAT           reduce using rule 94 (empty -> .)
    BOOLEAN         reduce using rule 94 (empty -> .)
    PUBLIC          shift and go to state 13
    PRIVATE         shift and go to state 14

  ! PUBLIC          [ reduce using rule 94 (empty -> .) ]
  ! PRIVATE         [ reduce using rule 94 (empty -> .) ]

    class_body                     shift and go to state 7
    field_decl                     shift and go to state 8
    method_decl                    shift and go to state 9
    constructor_decl               shift and go to state 10
    empty                          shift and go to state 11
    modifier                       shift and go to state 12

state 6

    (3) class_decl -> CLASS ID EXTENDS . ID LCURLY class_body RCURLY

    ID              shift and go to state 15


state 7

    (2) class_decl -> CLASS ID LCURLY class_body . RCURLY
    (7) class_body -> class_body . field_decl
    (8) class_body -> class_body . method_decl
    (9) class_body -> class_body . constructor_decl
    (11) field_decl -> . modifier var_decl
    (25) method_decl -> . modifier type ID LPAREN RPAREN block
    (26) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (27) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (28) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (29) constructor_decl -> . modifier ID block
    (30) constructor_decl -> . modifier ID formals block
    (12) modifier -> . PUBLIC
    (13) modifier -> . PRIVATE
    (14) modifier -> . PUBLIC STATIC
    (15) modifier -> . PRIVATE STATIC
    (16) modifier -> . empty
    (94) empty -> .

    RCURLY          shift and go to state 16
    PUBLIC          shift and go to state 13
    PRIVATE         shift and go to state 14
    VOID            reduce using rule 94 (empty -> .)
    ID              reduce using rule 94 (empty -> .)
    INT             reduce using rule 94 (empty -> .)
    FLOAT           reduce using rule 94 (empty -> .)
    BOOLEAN         reduce using rule 94 (empty -> .)

    field_decl                     shift and go to state 17
    method_decl                    shift and go to state 18
    constructor_decl               shift and go to state 19
    modifier                       shift and go to state 12
    empty                          shift and go to state 20

state 8

    (4) class_body -> field_decl .

    RCURLY          reduce using rule 4 (class_body -> field_decl .)
    PUBLIC          reduce using rule 4 (class_body -> field_decl .)
    PRIVATE         reduce using rule 4 (class_body -> field_decl .)
    VOID            reduce using rule 4 (class_body -> field_decl .)
    ID              reduce using rule 4 (class_body -> field_decl .)
    INT             reduce using rule 4 (class_body -> field_decl .)
    FLOAT           reduce using rule 4 (class_body -> field_decl .)
    BOOLEAN         reduce using rule 4 (class_body -> field_decl .)


state 9

    (5) class_body -> method_decl .

    RCURLY          reduce using rule 5 (class_body -> method_decl .)
    PUBLIC          reduce using rule 5 (class_body -> method_decl .)
    PRIVATE         reduce using rule 5 (class_body -> method_decl .)
    VOID            reduce using rule 5 (class_body -> method_decl .)
    ID              reduce using rule 5 (class_body -> method_decl .)
    INT             reduce using rule 5 (class_body -> method_decl .)
    FLOAT           reduce using rule 5 (class_body -> method_decl .)
    BOOLEAN         reduce using rule 5 (class_body -> method_decl .)


state 10

    (6) class_body -> constructor_decl .

    RCURLY          reduce using rule 6 (class_body -> constructor_decl .)
    PUBLIC          reduce using rule 6 (class_body -> constructor_decl .)
    PRIVATE         reduce using rule 6 (class_body -> constructor_decl .)
    VOID            reduce using rule 6 (class_body -> constructor_decl .)
    ID              reduce using rule 6 (class_body -> constructor_decl .)
    INT             reduce using rule 6 (class_body -> constructor_decl .)
    FLOAT           reduce using rule 6 (class_body -> constructor_decl .)
    BOOLEAN         reduce using rule 6 (class_body -> constructor_decl .)


state 11

    (10) class_body -> empty .
    (16) modifier -> empty .

  ! reduce/reduce conflict for VOID resolved using rule 10 (class_body -> empty .)
  ! reduce/reduce conflict for ID resolved using rule 10 (class_body -> empty .)
  ! reduce/reduce conflict for INT resolved using rule 10 (class_body -> empty .)
  ! reduce/reduce conflict for FLOAT resolved using rule 10 (class_body -> empty .)
  ! reduce/reduce conflict for BOOLEAN resolved using rule 10 (class_body -> empty .)
    RCURLY          reduce using rule 10 (class_body -> empty .)
    PUBLIC          reduce using rule 10 (class_body -> empty .)
    PRIVATE         reduce using rule 10 (class_body -> empty .)
    VOID            reduce using rule 10 (class_body -> empty .)
    ID              reduce using rule 10 (class_body -> empty .)
    INT             reduce using rule 10 (class_body -> empty .)
    FLOAT           reduce using rule 10 (class_body -> empty .)
    BOOLEAN         reduce using rule 10 (class_body -> empty .)

  ! VOID            [ reduce using rule 16 (modifier -> empty .) ]
  ! ID              [ reduce using rule 16 (modifier -> empty .) ]
  ! INT             [ reduce using rule 16 (modifier -> empty .) ]
  ! FLOAT           [ reduce using rule 16 (modifier -> empty .) ]
  ! BOOLEAN         [ reduce using rule 16 (modifier -> empty .) ]


state 12

    (11) field_decl -> modifier . var_decl
    (25) method_decl -> modifier . type ID LPAREN RPAREN block
    (26) method_decl -> modifier . type ID LPAREN formals RPAREN block
    (27) method_decl -> modifier . VOID ID LPAREN RPAREN block
    (28) method_decl -> modifier . VOID ID LPAREN formals RPAREN block
    (29) constructor_decl -> modifier . ID block
    (30) constructor_decl -> modifier . ID formals block
    (17) var_decl -> . type variables SEMICOLON
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    VOID            shift and go to state 24
    ID              shift and go to state 23
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    BOOLEAN         shift and go to state 27

    var_decl                       shift and go to state 21
    type                           shift and go to state 22

state 13

    (12) modifier -> PUBLIC .
    (14) modifier -> PUBLIC . STATIC

    VOID            reduce using rule 12 (modifier -> PUBLIC .)
    ID              reduce using rule 12 (modifier -> PUBLIC .)
    INT             reduce using rule 12 (modifier -> PUBLIC .)
    FLOAT           reduce using rule 12 (modifier -> PUBLIC .)
    BOOLEAN         reduce using rule 12 (modifier -> PUBLIC .)
    STATIC          shift and go to state 28


state 14

    (13) modifier -> PRIVATE .
    (15) modifier -> PRIVATE . STATIC

    VOID            reduce using rule 13 (modifier -> PRIVATE .)
    ID              reduce using rule 13 (modifier -> PRIVATE .)
    INT             reduce using rule 13 (modifier -> PRIVATE .)
    FLOAT           reduce using rule 13 (modifier -> PRIVATE .)
    BOOLEAN         reduce using rule 13 (modifier -> PRIVATE .)
    STATIC          shift and go to state 29


state 15

    (3) class_decl -> CLASS ID EXTENDS ID . LCURLY class_body RCURLY

    LCURLY          shift and go to state 30


state 16

    (2) class_decl -> CLASS ID LCURLY class_body RCURLY .

    $end            reduce using rule 2 (class_decl -> CLASS ID LCURLY class_body RCURLY .)


state 17

    (7) class_body -> class_body field_decl .

    RCURLY          reduce using rule 7 (class_body -> class_body field_decl .)
    PUBLIC          reduce using rule 7 (class_body -> class_body field_decl .)
    PRIVATE         reduce using rule 7 (class_body -> class_body field_decl .)
    VOID            reduce using rule 7 (class_body -> class_body field_decl .)
    ID              reduce using rule 7 (class_body -> class_body field_decl .)
    INT             reduce using rule 7 (class_body -> class_body field_decl .)
    FLOAT           reduce using rule 7 (class_body -> class_body field_decl .)
    BOOLEAN         reduce using rule 7 (class_body -> class_body field_decl .)


state 18

    (8) class_body -> class_body method_decl .

    RCURLY          reduce using rule 8 (class_body -> class_body method_decl .)
    PUBLIC          reduce using rule 8 (class_body -> class_body method_decl .)
    PRIVATE         reduce using rule 8 (class_body -> class_body method_decl .)
    VOID            reduce using rule 8 (class_body -> class_body method_decl .)
    ID              reduce using rule 8 (class_body -> class_body method_decl .)
    INT             reduce using rule 8 (class_body -> class_body method_decl .)
    FLOAT           reduce using rule 8 (class_body -> class_body method_decl .)
    BOOLEAN         reduce using rule 8 (class_body -> class_body method_decl .)


state 19

    (9) class_body -> class_body constructor_decl .

    RCURLY          reduce using rule 9 (class_body -> class_body constructor_decl .)
    PUBLIC          reduce using rule 9 (class_body -> class_body constructor_decl .)
    PRIVATE         reduce using rule 9 (class_body -> class_body constructor_decl .)
    VOID            reduce using rule 9 (class_body -> class_body constructor_decl .)
    ID              reduce using rule 9 (class_body -> class_body constructor_decl .)
    INT             reduce using rule 9 (class_body -> class_body constructor_decl .)
    FLOAT           reduce using rule 9 (class_body -> class_body constructor_decl .)
    BOOLEAN         reduce using rule 9 (class_body -> class_body constructor_decl .)


state 20

    (16) modifier -> empty .

    VOID            reduce using rule 16 (modifier -> empty .)
    ID              reduce using rule 16 (modifier -> empty .)
    INT             reduce using rule 16 (modifier -> empty .)
    FLOAT           reduce using rule 16 (modifier -> empty .)
    BOOLEAN         reduce using rule 16 (modifier -> empty .)


state 21

    (11) field_decl -> modifier var_decl .

    RCURLY          reduce using rule 11 (field_decl -> modifier var_decl .)
    PUBLIC          reduce using rule 11 (field_decl -> modifier var_decl .)
    PRIVATE         reduce using rule 11 (field_decl -> modifier var_decl .)
    VOID            reduce using rule 11 (field_decl -> modifier var_decl .)
    ID              reduce using rule 11 (field_decl -> modifier var_decl .)
    INT             reduce using rule 11 (field_decl -> modifier var_decl .)
    FLOAT           reduce using rule 11 (field_decl -> modifier var_decl .)
    BOOLEAN         reduce using rule 11 (field_decl -> modifier var_decl .)


state 22

    (25) method_decl -> modifier type . ID LPAREN RPAREN block
    (26) method_decl -> modifier type . ID LPAREN formals RPAREN block
    (17) var_decl -> type . variables SEMICOLON
    (22) variables -> . variable
    (23) variables -> . variable COMMA variables
    (24) variable -> . ID

    ID              shift and go to state 31

    variables                      shift and go to state 32
    variable                       shift and go to state 33

state 23

    (29) constructor_decl -> modifier ID . block
    (30) constructor_decl -> modifier ID . formals block
    (21) type -> ID .
    (34) block -> . LCURLY stmtlist RCURLY
    (35) block -> . empty
    (31) formals -> . formal_param
    (32) formals -> . formal_param COMMA formals
    (94) empty -> .
    (33) formal_param -> . type variable
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

  ! reduce/reduce conflict for ID resolved using rule 21 (type -> ID .)
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    LCURLY          shift and go to state 37
    RCURLY          reduce using rule 94 (empty -> .)
    PUBLIC          reduce using rule 94 (empty -> .)
    PRIVATE         reduce using rule 94 (empty -> .)
    VOID            reduce using rule 94 (empty -> .)
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 34

  ! ID              [ reduce using rule 21 (type -> ID .) ]
  ! ID              [ reduce using rule 94 (empty -> .) ]
  ! INT             [ reduce using rule 94 (empty -> .) ]
  ! FLOAT           [ reduce using rule 94 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 94 (empty -> .) ]

    block                          shift and go to state 35
    formals                        shift and go to state 36
    empty                          shift and go to state 38
    formal_param                   shift and go to state 39
    type                           shift and go to state 40

state 24

    (27) method_decl -> modifier VOID . ID LPAREN RPAREN block
    (28) method_decl -> modifier VOID . ID LPAREN formals RPAREN block

    ID              shift and go to state 41


state 25

    (18) type -> INT .

    ID              reduce using rule 18 (type -> INT .)


state 26

    (19) type -> FLOAT .

    ID              reduce using rule 19 (type -> FLOAT .)


state 27

    (20) type -> BOOLEAN .

    ID              reduce using rule 20 (type -> BOOLEAN .)


state 28

    (14) modifier -> PUBLIC STATIC .

    VOID            reduce using rule 14 (modifier -> PUBLIC STATIC .)
    ID              reduce using rule 14 (modifier -> PUBLIC STATIC .)
    INT             reduce using rule 14 (modifier -> PUBLIC STATIC .)
    FLOAT           reduce using rule 14 (modifier -> PUBLIC STATIC .)
    BOOLEAN         reduce using rule 14 (modifier -> PUBLIC STATIC .)


state 29

    (15) modifier -> PRIVATE STATIC .

    VOID            reduce using rule 15 (modifier -> PRIVATE STATIC .)
    ID              reduce using rule 15 (modifier -> PRIVATE STATIC .)
    INT             reduce using rule 15 (modifier -> PRIVATE STATIC .)
    FLOAT           reduce using rule 15 (modifier -> PRIVATE STATIC .)
    BOOLEAN         reduce using rule 15 (modifier -> PRIVATE STATIC .)


state 30

    (3) class_decl -> CLASS ID EXTENDS ID LCURLY . class_body RCURLY
    (4) class_body -> . field_decl
    (5) class_body -> . method_decl
    (6) class_body -> . constructor_decl
    (7) class_body -> . class_body field_decl
    (8) class_body -> . class_body method_decl
    (9) class_body -> . class_body constructor_decl
    (10) class_body -> . empty
    (11) field_decl -> . modifier var_decl
    (25) method_decl -> . modifier type ID LPAREN RPAREN block
    (26) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (27) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (28) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (29) constructor_decl -> . modifier ID block
    (30) constructor_decl -> . modifier ID formals block
    (94) empty -> .
    (12) modifier -> . PUBLIC
    (13) modifier -> . PRIVATE
    (14) modifier -> . PUBLIC STATIC
    (15) modifier -> . PRIVATE STATIC
    (16) modifier -> . empty

  ! shift/reduce conflict for PUBLIC resolved as shift
  ! shift/reduce conflict for PRIVATE resolved as shift
    RCURLY          reduce using rule 94 (empty -> .)
    VOID            reduce using rule 94 (empty -> .)
    ID              reduce using rule 94 (empty -> .)
    INT             reduce using rule 94 (empty -> .)
    FLOAT           reduce using rule 94 (empty -> .)
    BOOLEAN         reduce using rule 94 (empty -> .)
    PUBLIC          shift and go to state 13
    PRIVATE         shift and go to state 14

  ! PUBLIC          [ reduce using rule 94 (empty -> .) ]
  ! PRIVATE         [ reduce using rule 94 (empty -> .) ]

    class_body                     shift and go to state 42
    field_decl                     shift and go to state 8
    method_decl                    shift and go to state 9
    constructor_decl               shift and go to state 10
    empty                          shift and go to state 11
    modifier                       shift and go to state 12

state 31

    (25) method_decl -> modifier type ID . LPAREN RPAREN block
    (26) method_decl -> modifier type ID . LPAREN formals RPAREN block
    (24) variable -> ID .

    LPAREN          shift and go to state 43
    COMMA           reduce using rule 24 (variable -> ID .)
    SEMICOLON       reduce using rule 24 (variable -> ID .)


state 32

    (17) var_decl -> type variables . SEMICOLON

    SEMICOLON       shift and go to state 44


state 33

    (22) variables -> variable .
    (23) variables -> variable . COMMA variables

    SEMICOLON       reduce using rule 22 (variables -> variable .)
    COMMA           shift and go to state 45


state 34

    (21) type -> ID .

    ID              reduce using rule 21 (type -> ID .)


state 35

    (29) constructor_decl -> modifier ID block .

    RCURLY          reduce using rule 29 (constructor_decl -> modifier ID block .)
    PUBLIC          reduce using rule 29 (constructor_decl -> modifier ID block .)
    PRIVATE         reduce using rule 29 (constructor_decl -> modifier ID block .)
    VOID            reduce using rule 29 (constructor_decl -> modifier ID block .)
    ID              reduce using rule 29 (constructor_decl -> modifier ID block .)
    INT             reduce using rule 29 (constructor_decl -> modifier ID block .)
    FLOAT           reduce using rule 29 (constructor_decl -> modifier ID block .)
    BOOLEAN         reduce using rule 29 (constructor_decl -> modifier ID block .)


state 36

    (30) constructor_decl -> modifier ID formals . block
    (34) block -> . LCURLY stmtlist RCURLY
    (35) block -> . empty
    (94) empty -> .

    LCURLY          shift and go to state 37
    RCURLY          reduce using rule 94 (empty -> .)
    PUBLIC          reduce using rule 94 (empty -> .)
    PRIVATE         reduce using rule 94 (empty -> .)
    VOID            reduce using rule 94 (empty -> .)
    ID              reduce using rule 94 (empty -> .)
    INT             reduce using rule 94 (empty -> .)
    FLOAT           reduce using rule 94 (empty -> .)
    BOOLEAN         reduce using rule 94 (empty -> .)

    block                          shift and go to state 46
    empty                          shift and go to state 38

state 37

    (34) block -> LCURLY . stmtlist RCURLY
    (36) stmtlist -> . stmt
    (37) stmtlist -> . stmtlist stmt
    (38) stmt -> . IF LPAREN expression RPAREN stmt
    (39) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (40) stmt -> . WHILE LPAREN expression RPAREN stmt
    (41) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (42) stmt -> . RETURN expression SEMICOLON
    (43) stmt -> . RETURN SEMICOLON
    (44) stmt -> . stmt_expression SEMICOLON
    (45) stmt -> . BREAK SEMICOLON
    (46) stmt -> . CONTINUE SEMICOLON
    (47) stmt -> . block
    (48) stmt -> . var_decl
    (49) stmt -> . SEMICOLON
    (92) stmt_expression -> . assign
    (93) stmt_expression -> . method_invocation
    (34) block -> . LCURLY stmtlist RCURLY
    (35) block -> . empty
    (17) var_decl -> . type variables SEMICOLON
    (76) assign -> . lhs SETEQUAL expression
    (66) method_invocation -> . field_access LPAREN arguments RPAREN
    (67) method_invocation -> . field_access LPAREN RPAREN
    (94) empty -> .
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (73) lhs -> . field_access
    (74) field_access -> . primary DOT ID
    (75) field_access -> . ID
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . LPAREN expression RPAREN
    (60) primary -> . NEW ID
    (61) primary -> . NEW ID LPAREN arguments RPAREN
    (62) primary -> . method_invocation
    (63) primary -> . lhs
    (50) literal -> . INTEGER
    (51) literal -> . FLOAT
    (52) literal -> . STRING
    (53) literal -> . NULL
    (54) literal -> . FALSE
    (55) literal -> . TRUE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    IF              shift and go to state 49
    WHILE           shift and go to state 51
    FOR             shift and go to state 52
    RETURN          shift and go to state 55
    BREAK           shift and go to state 56
    CONTINUE        shift and go to state 57
    SEMICOLON       shift and go to state 54
    LCURLY          shift and go to state 37
    RCURLY          reduce using rule 94 (empty -> .)
    INT             shift and go to state 25
    FLOAT           shift and go to state 65
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 66
    THIS            shift and go to state 69
    SUPER           shift and go to state 70
    LPAREN          shift and go to state 50
    NEW             shift and go to state 71
    INTEGER         shift and go to state 72
    STRING          shift and go to state 73
    NULL            shift and go to state 74
    FALSE           shift and go to state 75
    TRUE            shift and go to state 76

  ! IF              [ reduce using rule 94 (empty -> .) ]
  ! WHILE           [ reduce using rule 94 (empty -> .) ]
  ! FOR             [ reduce using rule 94 (empty -> .) ]
  ! RETURN          [ reduce using rule 94 (empty -> .) ]
  ! BREAK           [ reduce using rule 94 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 94 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 94 (empty -> .) ]
  ! LCURLY          [ reduce using rule 94 (empty -> .) ]
  ! INT             [ reduce using rule 94 (empty -> .) ]
  ! FLOAT           [ reduce using rule 94 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 94 (empty -> .) ]
  ! ID              [ reduce using rule 94 (empty -> .) ]
  ! THIS            [ reduce using rule 94 (empty -> .) ]
  ! SUPER           [ reduce using rule 94 (empty -> .) ]
  ! LPAREN          [ reduce using rule 94 (empty -> .) ]
  ! NEW             [ reduce using rule 94 (empty -> .) ]
  ! INTEGER         [ reduce using rule 94 (empty -> .) ]
  ! STRING          [ reduce using rule 94 (empty -> .) ]
  ! NULL            [ reduce using rule 94 (empty -> .) ]
  ! FALSE           [ reduce using rule 94 (empty -> .) ]
  ! TRUE            [ reduce using rule 94 (empty -> .) ]

    stmtlist                       shift and go to state 47
    stmt                           shift and go to state 48
    stmt_expression                shift and go to state 53
    block                          shift and go to state 58
    var_decl                       shift and go to state 59
    assign                         shift and go to state 60
    method_invocation              shift and go to state 61
    empty                          shift and go to state 38
    type                           shift and go to state 62
    lhs                            shift and go to state 63
    field_access                   shift and go to state 64
    primary                        shift and go to state 67
    literal                        shift and go to state 68

state 38

    (35) block -> empty .

    RCURLY          reduce using rule 35 (block -> empty .)
    PUBLIC          reduce using rule 35 (block -> empty .)
    PRIVATE         reduce using rule 35 (block -> empty .)
    VOID            reduce using rule 35 (block -> empty .)
    ID              reduce using rule 35 (block -> empty .)
    INT             reduce using rule 35 (block -> empty .)
    FLOAT           reduce using rule 35 (block -> empty .)
    BOOLEAN         reduce using rule 35 (block -> empty .)
    IF              reduce using rule 35 (block -> empty .)
    WHILE           reduce using rule 35 (block -> empty .)
    FOR             reduce using rule 35 (block -> empty .)
    RETURN          reduce using rule 35 (block -> empty .)
    BREAK           reduce using rule 35 (block -> empty .)
    CONTINUE        reduce using rule 35 (block -> empty .)
    SEMICOLON       reduce using rule 35 (block -> empty .)
    LCURLY          reduce using rule 35 (block -> empty .)
    THIS            reduce using rule 35 (block -> empty .)
    SUPER           reduce using rule 35 (block -> empty .)
    LPAREN          reduce using rule 35 (block -> empty .)
    NEW             reduce using rule 35 (block -> empty .)
    INTEGER         reduce using rule 35 (block -> empty .)
    STRING          reduce using rule 35 (block -> empty .)
    NULL            reduce using rule 35 (block -> empty .)
    FALSE           reduce using rule 35 (block -> empty .)
    TRUE            reduce using rule 35 (block -> empty .)
    ELSE            reduce using rule 35 (block -> empty .)


state 39

    (31) formals -> formal_param .
    (32) formals -> formal_param . COMMA formals

    LCURLY          reduce using rule 31 (formals -> formal_param .)
    RCURLY          reduce using rule 31 (formals -> formal_param .)
    PUBLIC          reduce using rule 31 (formals -> formal_param .)
    PRIVATE         reduce using rule 31 (formals -> formal_param .)
    VOID            reduce using rule 31 (formals -> formal_param .)
    ID              reduce using rule 31 (formals -> formal_param .)
    INT             reduce using rule 31 (formals -> formal_param .)
    FLOAT           reduce using rule 31 (formals -> formal_param .)
    BOOLEAN         reduce using rule 31 (formals -> formal_param .)
    RPAREN          reduce using rule 31 (formals -> formal_param .)
    COMMA           shift and go to state 77


state 40

    (33) formal_param -> type . variable
    (24) variable -> . ID

    ID              shift and go to state 79

    variable                       shift and go to state 78

state 41

    (27) method_decl -> modifier VOID ID . LPAREN RPAREN block
    (28) method_decl -> modifier VOID ID . LPAREN formals RPAREN block

    LPAREN          shift and go to state 80


state 42

    (3) class_decl -> CLASS ID EXTENDS ID LCURLY class_body . RCURLY
    (7) class_body -> class_body . field_decl
    (8) class_body -> class_body . method_decl
    (9) class_body -> class_body . constructor_decl
    (11) field_decl -> . modifier var_decl
    (25) method_decl -> . modifier type ID LPAREN RPAREN block
    (26) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (27) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (28) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (29) constructor_decl -> . modifier ID block
    (30) constructor_decl -> . modifier ID formals block
    (12) modifier -> . PUBLIC
    (13) modifier -> . PRIVATE
    (14) modifier -> . PUBLIC STATIC
    (15) modifier -> . PRIVATE STATIC
    (16) modifier -> . empty
    (94) empty -> .

    RCURLY          shift and go to state 81
    PUBLIC          shift and go to state 13
    PRIVATE         shift and go to state 14
    VOID            reduce using rule 94 (empty -> .)
    ID              reduce using rule 94 (empty -> .)
    INT             reduce using rule 94 (empty -> .)
    FLOAT           reduce using rule 94 (empty -> .)
    BOOLEAN         reduce using rule 94 (empty -> .)

    field_decl                     shift and go to state 17
    method_decl                    shift and go to state 18
    constructor_decl               shift and go to state 19
    modifier                       shift and go to state 12
    empty                          shift and go to state 20

state 43

    (25) method_decl -> modifier type ID LPAREN . RPAREN block
    (26) method_decl -> modifier type ID LPAREN . formals RPAREN block
    (31) formals -> . formal_param
    (32) formals -> . formal_param COMMA formals
    (33) formal_param -> . type variable
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    RPAREN          shift and go to state 82
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 34

    type                           shift and go to state 40
    formals                        shift and go to state 83
    formal_param                   shift and go to state 39

state 44

    (17) var_decl -> type variables SEMICOLON .

    RCURLY          reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    PUBLIC          reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    PRIVATE         reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    VOID            reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    ID              reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    INT             reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    FLOAT           reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    BOOLEAN         reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    IF              reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    WHILE           reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    FOR             reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    RETURN          reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    BREAK           reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    CONTINUE        reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    SEMICOLON       reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    LCURLY          reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    THIS            reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    SUPER           reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    LPAREN          reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    NEW             reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    INTEGER         reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    STRING          reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    NULL            reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    FALSE           reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    TRUE            reduce using rule 17 (var_decl -> type variables SEMICOLON .)
    ELSE            reduce using rule 17 (var_decl -> type variables SEMICOLON .)


state 45

    (23) variables -> variable COMMA . variables
    (22) variables -> . variable
    (23) variables -> . variable COMMA variables
    (24) variable -> . ID

    ID              shift and go to state 79

    variable                       shift and go to state 33
    variables                      shift and go to state 84

state 46

    (30) constructor_decl -> modifier ID formals block .

    RCURLY          reduce using rule 30 (constructor_decl -> modifier ID formals block .)
    PUBLIC          reduce using rule 30 (constructor_decl -> modifier ID formals block .)
    PRIVATE         reduce using rule 30 (constructor_decl -> modifier ID formals block .)
    VOID            reduce using rule 30 (constructor_decl -> modifier ID formals block .)
    ID              reduce using rule 30 (constructor_decl -> modifier ID formals block .)
    INT             reduce using rule 30 (constructor_decl -> modifier ID formals block .)
    FLOAT           reduce using rule 30 (constructor_decl -> modifier ID formals block .)
    BOOLEAN         reduce using rule 30 (constructor_decl -> modifier ID formals block .)


state 47

    (34) block -> LCURLY stmtlist . RCURLY
    (37) stmtlist -> stmtlist . stmt
    (38) stmt -> . IF LPAREN expression RPAREN stmt
    (39) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (40) stmt -> . WHILE LPAREN expression RPAREN stmt
    (41) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (42) stmt -> . RETURN expression SEMICOLON
    (43) stmt -> . RETURN SEMICOLON
    (44) stmt -> . stmt_expression SEMICOLON
    (45) stmt -> . BREAK SEMICOLON
    (46) stmt -> . CONTINUE SEMICOLON
    (47) stmt -> . block
    (48) stmt -> . var_decl
    (49) stmt -> . SEMICOLON
    (92) stmt_expression -> . assign
    (93) stmt_expression -> . method_invocation
    (34) block -> . LCURLY stmtlist RCURLY
    (35) block -> . empty
    (17) var_decl -> . type variables SEMICOLON
    (76) assign -> . lhs SETEQUAL expression
    (66) method_invocation -> . field_access LPAREN arguments RPAREN
    (67) method_invocation -> . field_access LPAREN RPAREN
    (94) empty -> .
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (73) lhs -> . field_access
    (74) field_access -> . primary DOT ID
    (75) field_access -> . ID
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . LPAREN expression RPAREN
    (60) primary -> . NEW ID
    (61) primary -> . NEW ID LPAREN arguments RPAREN
    (62) primary -> . method_invocation
    (63) primary -> . lhs
    (50) literal -> . INTEGER
    (51) literal -> . FLOAT
    (52) literal -> . STRING
    (53) literal -> . NULL
    (54) literal -> . FALSE
    (55) literal -> . TRUE

  ! shift/reduce conflict for RCURLY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    RCURLY          shift and go to state 85
    IF              shift and go to state 49
    WHILE           shift and go to state 51
    FOR             shift and go to state 52
    RETURN          shift and go to state 55
    BREAK           shift and go to state 56
    CONTINUE        shift and go to state 57
    SEMICOLON       shift and go to state 54
    LCURLY          shift and go to state 37
    INT             shift and go to state 25
    FLOAT           shift and go to state 65
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 66
    THIS            shift and go to state 69
    SUPER           shift and go to state 70
    LPAREN          shift and go to state 50
    NEW             shift and go to state 71
    INTEGER         shift and go to state 72
    STRING          shift and go to state 73
    NULL            shift and go to state 74
    FALSE           shift and go to state 75
    TRUE            shift and go to state 76

  ! RCURLY          [ reduce using rule 94 (empty -> .) ]
  ! IF              [ reduce using rule 94 (empty -> .) ]
  ! WHILE           [ reduce using rule 94 (empty -> .) ]
  ! FOR             [ reduce using rule 94 (empty -> .) ]
  ! RETURN          [ reduce using rule 94 (empty -> .) ]
  ! BREAK           [ reduce using rule 94 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 94 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 94 (empty -> .) ]
  ! LCURLY          [ reduce using rule 94 (empty -> .) ]
  ! INT             [ reduce using rule 94 (empty -> .) ]
  ! FLOAT           [ reduce using rule 94 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 94 (empty -> .) ]
  ! ID              [ reduce using rule 94 (empty -> .) ]
  ! THIS            [ reduce using rule 94 (empty -> .) ]
  ! SUPER           [ reduce using rule 94 (empty -> .) ]
  ! LPAREN          [ reduce using rule 94 (empty -> .) ]
  ! NEW             [ reduce using rule 94 (empty -> .) ]
  ! INTEGER         [ reduce using rule 94 (empty -> .) ]
  ! STRING          [ reduce using rule 94 (empty -> .) ]
  ! NULL            [ reduce using rule 94 (empty -> .) ]
  ! FALSE           [ reduce using rule 94 (empty -> .) ]
  ! TRUE            [ reduce using rule 94 (empty -> .) ]

    stmt                           shift and go to state 86
    stmt_expression                shift and go to state 53
    block                          shift and go to state 58
    var_decl                       shift and go to state 59
    assign                         shift and go to state 60
    method_invocation              shift and go to state 61
    empty                          shift and go to state 38
    type                           shift and go to state 62
    lhs                            shift and go to state 63
    field_access                   shift and go to state 64
    primary                        shift and go to state 67
    literal                        shift and go to state 68

state 48

    (36) stmtlist -> stmt .

    RCURLY          reduce using rule 36 (stmtlist -> stmt .)
    IF              reduce using rule 36 (stmtlist -> stmt .)
    WHILE           reduce using rule 36 (stmtlist -> stmt .)
    FOR             reduce using rule 36 (stmtlist -> stmt .)
    RETURN          reduce using rule 36 (stmtlist -> stmt .)
    BREAK           reduce using rule 36 (stmtlist -> stmt .)
    CONTINUE        reduce using rule 36 (stmtlist -> stmt .)
    SEMICOLON       reduce using rule 36 (stmtlist -> stmt .)
    LCURLY          reduce using rule 36 (stmtlist -> stmt .)
    INT             reduce using rule 36 (stmtlist -> stmt .)
    FLOAT           reduce using rule 36 (stmtlist -> stmt .)
    BOOLEAN         reduce using rule 36 (stmtlist -> stmt .)
    ID              reduce using rule 36 (stmtlist -> stmt .)
    THIS            reduce using rule 36 (stmtlist -> stmt .)
    SUPER           reduce using rule 36 (stmtlist -> stmt .)
    LPAREN          reduce using rule 36 (stmtlist -> stmt .)
    NEW             reduce using rule 36 (stmtlist -> stmt .)
    INTEGER         reduce using rule 36 (stmtlist -> stmt .)
    STRING          reduce using rule 36 (stmtlist -> stmt .)
    NULL            reduce using rule 36 (stmtlist -> stmt .)
    FALSE           reduce using rule 36 (stmtlist -> stmt .)
    TRUE            reduce using rule 36 (stmtlist -> stmt .)


state 49

    (38) stmt -> IF . LPAREN expression RPAREN stmt
    (39) stmt -> IF . LPAREN expression RPAREN stmt ELSE stmt

    LPAREN          shift and go to state 87


state 50

    (59) primary -> LPAREN . expression RPAREN
    (68) expression -> . primary
    (69) expression -> . assign
    (70) expression -> . expression arith_op expression
    (71) expression -> . expression bool_op expression
    (72) expression -> . unary_op expression
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . LPAREN expression RPAREN
    (60) primary -> . NEW ID
    (61) primary -> . NEW ID LPAREN arguments RPAREN
    (62) primary -> . method_invocation
    (63) primary -> . lhs
    (76) assign -> . lhs SETEQUAL expression
    (89) unary_op -> . PLUS
    (90) unary_op -> . MINUS
    (91) unary_op -> . NOT
    (50) literal -> . INTEGER
    (51) literal -> . FLOAT
    (52) literal -> . STRING
    (53) literal -> . NULL
    (54) literal -> . FALSE
    (55) literal -> . TRUE
    (66) method_invocation -> . field_access LPAREN arguments RPAREN
    (67) method_invocation -> . field_access LPAREN RPAREN
    (73) lhs -> . field_access
    (74) field_access -> . primary DOT ID
    (75) field_access -> . ID

    THIS            shift and go to state 69
    SUPER           shift and go to state 70
    LPAREN          shift and go to state 50
    NEW             shift and go to state 71
    PLUS            shift and go to state 95
    MINUS           shift and go to state 96
    NOT             shift and go to state 97
    INTEGER         shift and go to state 72
    FLOAT           shift and go to state 98
    STRING          shift and go to state 73
    NULL            shift and go to state 74
    FALSE           shift and go to state 75
    TRUE            shift and go to state 76
    ID              shift and go to state 92

    expression                     shift and go to state 88
    primary                        shift and go to state 89
    assign                         shift and go to state 90
    unary_op                       shift and go to state 91
    literal                        shift and go to state 68
    method_invocation              shift and go to state 93
    lhs                            shift and go to state 94
    field_access                   shift and go to state 64

state 51

    (40) stmt -> WHILE . LPAREN expression RPAREN stmt

    LPAREN          shift and go to state 99


state 52

    (41) stmt -> FOR . LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt

    LPAREN          shift and go to state 100


state 53

    (44) stmt -> stmt_expression . SEMICOLON

    SEMICOLON       shift and go to state 101


state 54

    (49) stmt -> SEMICOLON .

    RCURLY          reduce using rule 49 (stmt -> SEMICOLON .)
    IF              reduce using rule 49 (stmt -> SEMICOLON .)
    WHILE           reduce using rule 49 (stmt -> SEMICOLON .)
    FOR             reduce using rule 49 (stmt -> SEMICOLON .)
    RETURN          reduce using rule 49 (stmt -> SEMICOLON .)
    BREAK           reduce using rule 49 (stmt -> SEMICOLON .)
    CONTINUE        reduce using rule 49 (stmt -> SEMICOLON .)
    SEMICOLON       reduce using rule 49 (stmt -> SEMICOLON .)
    LCURLY          reduce using rule 49 (stmt -> SEMICOLON .)
    INT             reduce using rule 49 (stmt -> SEMICOLON .)
    FLOAT           reduce using rule 49 (stmt -> SEMICOLON .)
    BOOLEAN         reduce using rule 49 (stmt -> SEMICOLON .)
    ID              reduce using rule 49 (stmt -> SEMICOLON .)
    THIS            reduce using rule 49 (stmt -> SEMICOLON .)
    SUPER           reduce using rule 49 (stmt -> SEMICOLON .)
    LPAREN          reduce using rule 49 (stmt -> SEMICOLON .)
    NEW             reduce using rule 49 (stmt -> SEMICOLON .)
    INTEGER         reduce using rule 49 (stmt -> SEMICOLON .)
    STRING          reduce using rule 49 (stmt -> SEMICOLON .)
    NULL            reduce using rule 49 (stmt -> SEMICOLON .)
    FALSE           reduce using rule 49 (stmt -> SEMICOLON .)
    TRUE            reduce using rule 49 (stmt -> SEMICOLON .)
    ELSE            reduce using rule 49 (stmt -> SEMICOLON .)


state 55

    (42) stmt -> RETURN . expression SEMICOLON
    (43) stmt -> RETURN . SEMICOLON
    (68) expression -> . primary
    (69) expression -> . assign
    (70) expression -> . expression arith_op expression
    (71) expression -> . expression bool_op expression
    (72) expression -> . unary_op expression
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . LPAREN expression RPAREN
    (60) primary -> . NEW ID
    (61) primary -> . NEW ID LPAREN arguments RPAREN
    (62) primary -> . method_invocation
    (63) primary -> . lhs
    (76) assign -> . lhs SETEQUAL expression
    (89) unary_op -> . PLUS
    (90) unary_op -> . MINUS
    (91) unary_op -> . NOT
    (50) literal -> . INTEGER
    (51) literal -> . FLOAT
    (52) literal -> . STRING
    (53) literal -> . NULL
    (54) literal -> . FALSE
    (55) literal -> . TRUE
    (66) method_invocation -> . field_access LPAREN arguments RPAREN
    (67) method_invocation -> . field_access LPAREN RPAREN
    (73) lhs -> . field_access
    (74) field_access -> . primary DOT ID
    (75) field_access -> . ID

    SEMICOLON       shift and go to state 103
    THIS            shift and go to state 69
    SUPER           shift and go to state 70
    LPAREN          shift and go to state 50
    NEW             shift and go to state 71
    PLUS            shift and go to state 95
    MINUS           shift and go to state 96
    NOT             shift and go to state 97
    INTEGER         shift and go to state 72
    FLOAT           shift and go to state 98
    STRING          shift and go to state 73
    NULL            shift and go to state 74
    FALSE           shift and go to state 75
    TRUE            shift and go to state 76
    ID              shift and go to state 92

    expression                     shift and go to state 102
    primary                        shift and go to state 89
    assign                         shift and go to state 90
    unary_op                       shift and go to state 91
    literal                        shift and go to state 68
    method_invocation              shift and go to state 93
    lhs                            shift and go to state 94
    field_access                   shift and go to state 64

state 56

    (45) stmt -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 104


state 57

    (46) stmt -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 105


state 58

    (47) stmt -> block .

    RCURLY          reduce using rule 47 (stmt -> block .)
    IF              reduce using rule 47 (stmt -> block .)
    WHILE           reduce using rule 47 (stmt -> block .)
    FOR             reduce using rule 47 (stmt -> block .)
    RETURN          reduce using rule 47 (stmt -> block .)
    BREAK           reduce using rule 47 (stmt -> block .)
    CONTINUE        reduce using rule 47 (stmt -> block .)
    SEMICOLON       reduce using rule 47 (stmt -> block .)
    LCURLY          reduce using rule 47 (stmt -> block .)
    INT             reduce using rule 47 (stmt -> block .)
    FLOAT           reduce using rule 47 (stmt -> block .)
    BOOLEAN         reduce using rule 47 (stmt -> block .)
    ID              reduce using rule 47 (stmt -> block .)
    THIS            reduce using rule 47 (stmt -> block .)
    SUPER           reduce using rule 47 (stmt -> block .)
    LPAREN          reduce using rule 47 (stmt -> block .)
    NEW             reduce using rule 47 (stmt -> block .)
    INTEGER         reduce using rule 47 (stmt -> block .)
    STRING          reduce using rule 47 (stmt -> block .)
    NULL            reduce using rule 47 (stmt -> block .)
    FALSE           reduce using rule 47 (stmt -> block .)
    TRUE            reduce using rule 47 (stmt -> block .)
    ELSE            reduce using rule 47 (stmt -> block .)


state 59

    (48) stmt -> var_decl .

    RCURLY          reduce using rule 48 (stmt -> var_decl .)
    IF              reduce using rule 48 (stmt -> var_decl .)
    WHILE           reduce using rule 48 (stmt -> var_decl .)
    FOR             reduce using rule 48 (stmt -> var_decl .)
    RETURN          reduce using rule 48 (stmt -> var_decl .)
    BREAK           reduce using rule 48 (stmt -> var_decl .)
    CONTINUE        reduce using rule 48 (stmt -> var_decl .)
    SEMICOLON       reduce using rule 48 (stmt -> var_decl .)
    LCURLY          reduce using rule 48 (stmt -> var_decl .)
    INT             reduce using rule 48 (stmt -> var_decl .)
    FLOAT           reduce using rule 48 (stmt -> var_decl .)
    BOOLEAN         reduce using rule 48 (stmt -> var_decl .)
    ID              reduce using rule 48 (stmt -> var_decl .)
    THIS            reduce using rule 48 (stmt -> var_decl .)
    SUPER           reduce using rule 48 (stmt -> var_decl .)
    LPAREN          reduce using rule 48 (stmt -> var_decl .)
    NEW             reduce using rule 48 (stmt -> var_decl .)
    INTEGER         reduce using rule 48 (stmt -> var_decl .)
    STRING          reduce using rule 48 (stmt -> var_decl .)
    NULL            reduce using rule 48 (stmt -> var_decl .)
    FALSE           reduce using rule 48 (stmt -> var_decl .)
    TRUE            reduce using rule 48 (stmt -> var_decl .)
    ELSE            reduce using rule 48 (stmt -> var_decl .)


state 60

    (92) stmt_expression -> assign .

    SEMICOLON       reduce using rule 92 (stmt_expression -> assign .)
    RPAREN          reduce using rule 92 (stmt_expression -> assign .)


state 61

    (93) stmt_expression -> method_invocation .
    (62) primary -> method_invocation .

    SEMICOLON       reduce using rule 93 (stmt_expression -> method_invocation .)
    RPAREN          reduce using rule 93 (stmt_expression -> method_invocation .)
    DOT             reduce using rule 62 (primary -> method_invocation .)


state 62

    (17) var_decl -> type . variables SEMICOLON
    (22) variables -> . variable
    (23) variables -> . variable COMMA variables
    (24) variable -> . ID

    ID              shift and go to state 79

    variables                      shift and go to state 32
    variable                       shift and go to state 33

state 63

    (76) assign -> lhs . SETEQUAL expression
    (63) primary -> lhs .

    SETEQUAL        shift and go to state 106
    DOT             reduce using rule 63 (primary -> lhs .)


state 64

    (66) method_invocation -> field_access . LPAREN arguments RPAREN
    (67) method_invocation -> field_access . LPAREN RPAREN
    (73) lhs -> field_access .

    LPAREN          shift and go to state 107
    SETEQUAL        reduce using rule 73 (lhs -> field_access .)
    DOT             reduce using rule 73 (lhs -> field_access .)
    RPAREN          reduce using rule 73 (lhs -> field_access .)
    PLUS            reduce using rule 73 (lhs -> field_access .)
    MINUS           reduce using rule 73 (lhs -> field_access .)
    TIMES           reduce using rule 73 (lhs -> field_access .)
    DIVIDE          reduce using rule 73 (lhs -> field_access .)
    GREATER         reduce using rule 73 (lhs -> field_access .)
    LESS            reduce using rule 73 (lhs -> field_access .)
    GREATEREQ       reduce using rule 73 (lhs -> field_access .)
    LESSEQ          reduce using rule 73 (lhs -> field_access .)
    EQUAL           reduce using rule 73 (lhs -> field_access .)
    NOTEQUAL        reduce using rule 73 (lhs -> field_access .)
    AND             reduce using rule 73 (lhs -> field_access .)
    OR              reduce using rule 73 (lhs -> field_access .)
    SEMICOLON       reduce using rule 73 (lhs -> field_access .)
    COMMA           reduce using rule 73 (lhs -> field_access .)


state 65

    (19) type -> FLOAT .
    (51) literal -> FLOAT .

    ID              reduce using rule 19 (type -> FLOAT .)
    DOT             reduce using rule 51 (literal -> FLOAT .)


state 66

    (21) type -> ID .
    (75) field_access -> ID .

    ID              reduce using rule 21 (type -> ID .)
    LPAREN          reduce using rule 75 (field_access -> ID .)
    SETEQUAL        reduce using rule 75 (field_access -> ID .)
    DOT             reduce using rule 75 (field_access -> ID .)


state 67

    (74) field_access -> primary . DOT ID

    DOT             shift and go to state 108


state 68

    (56) primary -> literal .

    DOT             reduce using rule 56 (primary -> literal .)
    RPAREN          reduce using rule 56 (primary -> literal .)
    PLUS            reduce using rule 56 (primary -> literal .)
    MINUS           reduce using rule 56 (primary -> literal .)
    TIMES           reduce using rule 56 (primary -> literal .)
    DIVIDE          reduce using rule 56 (primary -> literal .)
    GREATER         reduce using rule 56 (primary -> literal .)
    LESS            reduce using rule 56 (primary -> literal .)
    GREATEREQ       reduce using rule 56 (primary -> literal .)
    LESSEQ          reduce using rule 56 (primary -> literal .)
    EQUAL           reduce using rule 56 (primary -> literal .)
    NOTEQUAL        reduce using rule 56 (primary -> literal .)
    AND             reduce using rule 56 (primary -> literal .)
    OR              reduce using rule 56 (primary -> literal .)
    SEMICOLON       reduce using rule 56 (primary -> literal .)
    COMMA           reduce using rule 56 (primary -> literal .)


state 69

    (57) primary -> THIS .

    DOT             reduce using rule 57 (primary -> THIS .)
    RPAREN          reduce using rule 57 (primary -> THIS .)
    PLUS            reduce using rule 57 (primary -> THIS .)
    MINUS           reduce using rule 57 (primary -> THIS .)
    TIMES           reduce using rule 57 (primary -> THIS .)
    DIVIDE          reduce using rule 57 (primary -> THIS .)
    GREATER         reduce using rule 57 (primary -> THIS .)
    LESS            reduce using rule 57 (primary -> THIS .)
    GREATEREQ       reduce using rule 57 (primary -> THIS .)
    LESSEQ          reduce using rule 57 (primary -> THIS .)
    EQUAL           reduce using rule 57 (primary -> THIS .)
    NOTEQUAL        reduce using rule 57 (primary -> THIS .)
    AND             reduce using rule 57 (primary -> THIS .)
    OR              reduce using rule 57 (primary -> THIS .)
    SEMICOLON       reduce using rule 57 (primary -> THIS .)
    COMMA           reduce using rule 57 (primary -> THIS .)


state 70

    (58) primary -> SUPER .

    DOT             reduce using rule 58 (primary -> SUPER .)
    RPAREN          reduce using rule 58 (primary -> SUPER .)
    PLUS            reduce using rule 58 (primary -> SUPER .)
    MINUS           reduce using rule 58 (primary -> SUPER .)
    TIMES           reduce using rule 58 (primary -> SUPER .)
    DIVIDE          reduce using rule 58 (primary -> SUPER .)
    GREATER         reduce using rule 58 (primary -> SUPER .)
    LESS            reduce using rule 58 (primary -> SUPER .)
    GREATEREQ       reduce using rule 58 (primary -> SUPER .)
    LESSEQ          reduce using rule 58 (primary -> SUPER .)
    EQUAL           reduce using rule 58 (primary -> SUPER .)
    NOTEQUAL        reduce using rule 58 (primary -> SUPER .)
    AND             reduce using rule 58 (primary -> SUPER .)
    OR              reduce using rule 58 (primary -> SUPER .)
    SEMICOLON       reduce using rule 58 (primary -> SUPER .)
    COMMA           reduce using rule 58 (primary -> SUPER .)


state 71

    (60) primary -> NEW . ID
    (61) primary -> NEW . ID LPAREN arguments RPAREN

    ID              shift and go to state 109


state 72

    (50) literal -> INTEGER .

    DOT             reduce using rule 50 (literal -> INTEGER .)
    RPAREN          reduce using rule 50 (literal -> INTEGER .)
    PLUS            reduce using rule 50 (literal -> INTEGER .)
    MINUS           reduce using rule 50 (literal -> INTEGER .)
    TIMES           reduce using rule 50 (literal -> INTEGER .)
    DIVIDE          reduce using rule 50 (literal -> INTEGER .)
    GREATER         reduce using rule 50 (literal -> INTEGER .)
    LESS            reduce using rule 50 (literal -> INTEGER .)
    GREATEREQ       reduce using rule 50 (literal -> INTEGER .)
    LESSEQ          reduce using rule 50 (literal -> INTEGER .)
    EQUAL           reduce using rule 50 (literal -> INTEGER .)
    NOTEQUAL        reduce using rule 50 (literal -> INTEGER .)
    AND             reduce using rule 50 (literal -> INTEGER .)
    OR              reduce using rule 50 (literal -> INTEGER .)
    SEMICOLON       reduce using rule 50 (literal -> INTEGER .)
    COMMA           reduce using rule 50 (literal -> INTEGER .)


state 73

    (52) literal -> STRING .

    DOT             reduce using rule 52 (literal -> STRING .)
    RPAREN          reduce using rule 52 (literal -> STRING .)
    PLUS            reduce using rule 52 (literal -> STRING .)
    MINUS           reduce using rule 52 (literal -> STRING .)
    TIMES           reduce using rule 52 (literal -> STRING .)
    DIVIDE          reduce using rule 52 (literal -> STRING .)
    GREATER         reduce using rule 52 (literal -> STRING .)
    LESS            reduce using rule 52 (literal -> STRING .)
    GREATEREQ       reduce using rule 52 (literal -> STRING .)
    LESSEQ          reduce using rule 52 (literal -> STRING .)
    EQUAL           reduce using rule 52 (literal -> STRING .)
    NOTEQUAL        reduce using rule 52 (literal -> STRING .)
    AND             reduce using rule 52 (literal -> STRING .)
    OR              reduce using rule 52 (literal -> STRING .)
    SEMICOLON       reduce using rule 52 (literal -> STRING .)
    COMMA           reduce using rule 52 (literal -> STRING .)


state 74

    (53) literal -> NULL .

    DOT             reduce using rule 53 (literal -> NULL .)
    RPAREN          reduce using rule 53 (literal -> NULL .)
    PLUS            reduce using rule 53 (literal -> NULL .)
    MINUS           reduce using rule 53 (literal -> NULL .)
    TIMES           reduce using rule 53 (literal -> NULL .)
    DIVIDE          reduce using rule 53 (literal -> NULL .)
    GREATER         reduce using rule 53 (literal -> NULL .)
    LESS            reduce using rule 53 (literal -> NULL .)
    GREATEREQ       reduce using rule 53 (literal -> NULL .)
    LESSEQ          reduce using rule 53 (literal -> NULL .)
    EQUAL           reduce using rule 53 (literal -> NULL .)
    NOTEQUAL        reduce using rule 53 (literal -> NULL .)
    AND             reduce using rule 53 (literal -> NULL .)
    OR              reduce using rule 53 (literal -> NULL .)
    SEMICOLON       reduce using rule 53 (literal -> NULL .)
    COMMA           reduce using rule 53 (literal -> NULL .)


state 75

    (54) literal -> FALSE .

    DOT             reduce using rule 54 (literal -> FALSE .)
    RPAREN          reduce using rule 54 (literal -> FALSE .)
    PLUS            reduce using rule 54 (literal -> FALSE .)
    MINUS           reduce using rule 54 (literal -> FALSE .)
    TIMES           reduce using rule 54 (literal -> FALSE .)
    DIVIDE          reduce using rule 54 (literal -> FALSE .)
    GREATER         reduce using rule 54 (literal -> FALSE .)
    LESS            reduce using rule 54 (literal -> FALSE .)
    GREATEREQ       reduce using rule 54 (literal -> FALSE .)
    LESSEQ          reduce using rule 54 (literal -> FALSE .)
    EQUAL           reduce using rule 54 (literal -> FALSE .)
    NOTEQUAL        reduce using rule 54 (literal -> FALSE .)
    AND             reduce using rule 54 (literal -> FALSE .)
    OR              reduce using rule 54 (literal -> FALSE .)
    SEMICOLON       reduce using rule 54 (literal -> FALSE .)
    COMMA           reduce using rule 54 (literal -> FALSE .)


state 76

    (55) literal -> TRUE .

    DOT             reduce using rule 55 (literal -> TRUE .)
    RPAREN          reduce using rule 55 (literal -> TRUE .)
    PLUS            reduce using rule 55 (literal -> TRUE .)
    MINUS           reduce using rule 55 (literal -> TRUE .)
    TIMES           reduce using rule 55 (literal -> TRUE .)
    DIVIDE          reduce using rule 55 (literal -> TRUE .)
    GREATER         reduce using rule 55 (literal -> TRUE .)
    LESS            reduce using rule 55 (literal -> TRUE .)
    GREATEREQ       reduce using rule 55 (literal -> TRUE .)
    LESSEQ          reduce using rule 55 (literal -> TRUE .)
    EQUAL           reduce using rule 55 (literal -> TRUE .)
    NOTEQUAL        reduce using rule 55 (literal -> TRUE .)
    AND             reduce using rule 55 (literal -> TRUE .)
    OR              reduce using rule 55 (literal -> TRUE .)
    SEMICOLON       reduce using rule 55 (literal -> TRUE .)
    COMMA           reduce using rule 55 (literal -> TRUE .)


state 77

    (32) formals -> formal_param COMMA . formals
    (31) formals -> . formal_param
    (32) formals -> . formal_param COMMA formals
    (33) formal_param -> . type variable
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 34

    formal_param                   shift and go to state 39
    formals                        shift and go to state 110
    type                           shift and go to state 40

state 78

    (33) formal_param -> type variable .

    COMMA           reduce using rule 33 (formal_param -> type variable .)
    LCURLY          reduce using rule 33 (formal_param -> type variable .)
    RCURLY          reduce using rule 33 (formal_param -> type variable .)
    PUBLIC          reduce using rule 33 (formal_param -> type variable .)
    PRIVATE         reduce using rule 33 (formal_param -> type variable .)
    VOID            reduce using rule 33 (formal_param -> type variable .)
    ID              reduce using rule 33 (formal_param -> type variable .)
    INT             reduce using rule 33 (formal_param -> type variable .)
    FLOAT           reduce using rule 33 (formal_param -> type variable .)
    BOOLEAN         reduce using rule 33 (formal_param -> type variable .)
    RPAREN          reduce using rule 33 (formal_param -> type variable .)


state 79

    (24) variable -> ID .

    COMMA           reduce using rule 24 (variable -> ID .)
    LCURLY          reduce using rule 24 (variable -> ID .)
    RCURLY          reduce using rule 24 (variable -> ID .)
    PUBLIC          reduce using rule 24 (variable -> ID .)
    PRIVATE         reduce using rule 24 (variable -> ID .)
    VOID            reduce using rule 24 (variable -> ID .)
    ID              reduce using rule 24 (variable -> ID .)
    INT             reduce using rule 24 (variable -> ID .)
    FLOAT           reduce using rule 24 (variable -> ID .)
    BOOLEAN         reduce using rule 24 (variable -> ID .)
    RPAREN          reduce using rule 24 (variable -> ID .)
    SEMICOLON       reduce using rule 24 (variable -> ID .)


state 80

    (27) method_decl -> modifier VOID ID LPAREN . RPAREN block
    (28) method_decl -> modifier VOID ID LPAREN . formals RPAREN block
    (31) formals -> . formal_param
    (32) formals -> . formal_param COMMA formals
    (33) formal_param -> . type variable
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID

    RPAREN          shift and go to state 111
    INT             shift and go to state 25
    FLOAT           shift and go to state 26
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 34

    formals                        shift and go to state 112
    formal_param                   shift and go to state 39
    type                           shift and go to state 40

state 81

    (3) class_decl -> CLASS ID EXTENDS ID LCURLY class_body RCURLY .

    $end            reduce using rule 3 (class_decl -> CLASS ID EXTENDS ID LCURLY class_body RCURLY .)


state 82

    (25) method_decl -> modifier type ID LPAREN RPAREN . block
    (34) block -> . LCURLY stmtlist RCURLY
    (35) block -> . empty
    (94) empty -> .

    LCURLY          shift and go to state 37
    RCURLY          reduce using rule 94 (empty -> .)
    PUBLIC          reduce using rule 94 (empty -> .)
    PRIVATE         reduce using rule 94 (empty -> .)
    VOID            reduce using rule 94 (empty -> .)
    ID              reduce using rule 94 (empty -> .)
    INT             reduce using rule 94 (empty -> .)
    FLOAT           reduce using rule 94 (empty -> .)
    BOOLEAN         reduce using rule 94 (empty -> .)

    block                          shift and go to state 113
    empty                          shift and go to state 38

state 83

    (26) method_decl -> modifier type ID LPAREN formals . RPAREN block

    RPAREN          shift and go to state 114


state 84

    (23) variables -> variable COMMA variables .

    SEMICOLON       reduce using rule 23 (variables -> variable COMMA variables .)


state 85

    (34) block -> LCURLY stmtlist RCURLY .

    RCURLY          reduce using rule 34 (block -> LCURLY stmtlist RCURLY .)
    PUBLIC          reduce using rule 34 (block -> LCURLY stmtlist RCURLY .)
    PRIVATE         reduce using rule 34 (block -> LCURLY stmtlist RCURLY .)
    VOID            reduce using rule 34 (block -> LCURLY stmtlist RCURLY .)
    ID              reduce using rule 34 (block -> LCURLY stmtlist RCURLY .)
    INT             reduce using rule 34 (block -> LCURLY stmtlist RCURLY .)
    FLOAT           reduce using rule 34 (block -> LCURLY stmtlist RCURLY .)
    BOOLEAN         reduce using rule 34 (block -> LCURLY stmtlist RCURLY .)
    IF              reduce using rule 34 (block -> LCURLY stmtlist RCURLY .)
    WHILE           reduce using rule 34 (block -> LCURLY stmtlist RCURLY .)
    FOR             reduce using rule 34 (block -> LCURLY stmtlist RCURLY .)
    RETURN          reduce using rule 34 (block -> LCURLY stmtlist RCURLY .)
    BREAK           reduce using rule 34 (block -> LCURLY stmtlist RCURLY .)
    CONTINUE        reduce using rule 34 (block -> LCURLY stmtlist RCURLY .)
    SEMICOLON       reduce using rule 34 (block -> LCURLY stmtlist RCURLY .)
    LCURLY          reduce using rule 34 (block -> LCURLY stmtlist RCURLY .)
    THIS            reduce using rule 34 (block -> LCURLY stmtlist RCURLY .)
    SUPER           reduce using rule 34 (block -> LCURLY stmtlist RCURLY .)
    LPAREN          reduce using rule 34 (block -> LCURLY stmtlist RCURLY .)
    NEW             reduce using rule 34 (block -> LCURLY stmtlist RCURLY .)
    INTEGER         reduce using rule 34 (block -> LCURLY stmtlist RCURLY .)
    STRING          reduce using rule 34 (block -> LCURLY stmtlist RCURLY .)
    NULL            reduce using rule 34 (block -> LCURLY stmtlist RCURLY .)
    FALSE           reduce using rule 34 (block -> LCURLY stmtlist RCURLY .)
    TRUE            reduce using rule 34 (block -> LCURLY stmtlist RCURLY .)
    ELSE            reduce using rule 34 (block -> LCURLY stmtlist RCURLY .)


state 86

    (37) stmtlist -> stmtlist stmt .

    RCURLY          reduce using rule 37 (stmtlist -> stmtlist stmt .)
    IF              reduce using rule 37 (stmtlist -> stmtlist stmt .)
    WHILE           reduce using rule 37 (stmtlist -> stmtlist stmt .)
    FOR             reduce using rule 37 (stmtlist -> stmtlist stmt .)
    RETURN          reduce using rule 37 (stmtlist -> stmtlist stmt .)
    BREAK           reduce using rule 37 (stmtlist -> stmtlist stmt .)
    CONTINUE        reduce using rule 37 (stmtlist -> stmtlist stmt .)
    SEMICOLON       reduce using rule 37 (stmtlist -> stmtlist stmt .)
    LCURLY          reduce using rule 37 (stmtlist -> stmtlist stmt .)
    INT             reduce using rule 37 (stmtlist -> stmtlist stmt .)
    FLOAT           reduce using rule 37 (stmtlist -> stmtlist stmt .)
    BOOLEAN         reduce using rule 37 (stmtlist -> stmtlist stmt .)
    ID              reduce using rule 37 (stmtlist -> stmtlist stmt .)
    THIS            reduce using rule 37 (stmtlist -> stmtlist stmt .)
    SUPER           reduce using rule 37 (stmtlist -> stmtlist stmt .)
    LPAREN          reduce using rule 37 (stmtlist -> stmtlist stmt .)
    NEW             reduce using rule 37 (stmtlist -> stmtlist stmt .)
    INTEGER         reduce using rule 37 (stmtlist -> stmtlist stmt .)
    STRING          reduce using rule 37 (stmtlist -> stmtlist stmt .)
    NULL            reduce using rule 37 (stmtlist -> stmtlist stmt .)
    FALSE           reduce using rule 37 (stmtlist -> stmtlist stmt .)
    TRUE            reduce using rule 37 (stmtlist -> stmtlist stmt .)


state 87

    (38) stmt -> IF LPAREN . expression RPAREN stmt
    (39) stmt -> IF LPAREN . expression RPAREN stmt ELSE stmt
    (68) expression -> . primary
    (69) expression -> . assign
    (70) expression -> . expression arith_op expression
    (71) expression -> . expression bool_op expression
    (72) expression -> . unary_op expression
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . LPAREN expression RPAREN
    (60) primary -> . NEW ID
    (61) primary -> . NEW ID LPAREN arguments RPAREN
    (62) primary -> . method_invocation
    (63) primary -> . lhs
    (76) assign -> . lhs SETEQUAL expression
    (89) unary_op -> . PLUS
    (90) unary_op -> . MINUS
    (91) unary_op -> . NOT
    (50) literal -> . INTEGER
    (51) literal -> . FLOAT
    (52) literal -> . STRING
    (53) literal -> . NULL
    (54) literal -> . FALSE
    (55) literal -> . TRUE
    (66) method_invocation -> . field_access LPAREN arguments RPAREN
    (67) method_invocation -> . field_access LPAREN RPAREN
    (73) lhs -> . field_access
    (74) field_access -> . primary DOT ID
    (75) field_access -> . ID

    THIS            shift and go to state 69
    SUPER           shift and go to state 70
    LPAREN          shift and go to state 50
    NEW             shift and go to state 71
    PLUS            shift and go to state 95
    MINUS           shift and go to state 96
    NOT             shift and go to state 97
    INTEGER         shift and go to state 72
    FLOAT           shift and go to state 98
    STRING          shift and go to state 73
    NULL            shift and go to state 74
    FALSE           shift and go to state 75
    TRUE            shift and go to state 76
    ID              shift and go to state 92

    expression                     shift and go to state 115
    primary                        shift and go to state 89
    assign                         shift and go to state 90
    unary_op                       shift and go to state 91
    literal                        shift and go to state 68
    method_invocation              shift and go to state 93
    lhs                            shift and go to state 94
    field_access                   shift and go to state 64

state 88

    (59) primary -> LPAREN expression . RPAREN
    (70) expression -> expression . arith_op expression
    (71) expression -> expression . bool_op expression
    (77) arith_op -> . PLUS
    (78) arith_op -> . MINUS
    (79) arith_op -> . TIMES
    (80) arith_op -> . DIVIDE
    (81) bool_op -> . GREATER
    (82) bool_op -> . LESS
    (83) bool_op -> . GREATEREQ
    (84) bool_op -> . LESSEQ
    (85) bool_op -> . EQUAL
    (86) bool_op -> . NOTEQUAL
    (87) bool_op -> . AND
    (88) bool_op -> . OR

    RPAREN          shift and go to state 116
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    TIMES           shift and go to state 121
    DIVIDE          shift and go to state 122
    GREATER         shift and go to state 123
    LESS            shift and go to state 124
    GREATEREQ       shift and go to state 125
    LESSEQ          shift and go to state 126
    EQUAL           shift and go to state 127
    NOTEQUAL        shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130

    arith_op                       shift and go to state 117
    bool_op                        shift and go to state 118

state 89

    (68) expression -> primary .
    (74) field_access -> primary . DOT ID

    RPAREN          reduce using rule 68 (expression -> primary .)
    PLUS            reduce using rule 68 (expression -> primary .)
    MINUS           reduce using rule 68 (expression -> primary .)
    TIMES           reduce using rule 68 (expression -> primary .)
    DIVIDE          reduce using rule 68 (expression -> primary .)
    GREATER         reduce using rule 68 (expression -> primary .)
    LESS            reduce using rule 68 (expression -> primary .)
    GREATEREQ       reduce using rule 68 (expression -> primary .)
    LESSEQ          reduce using rule 68 (expression -> primary .)
    EQUAL           reduce using rule 68 (expression -> primary .)
    NOTEQUAL        reduce using rule 68 (expression -> primary .)
    AND             reduce using rule 68 (expression -> primary .)
    OR              reduce using rule 68 (expression -> primary .)
    SEMICOLON       reduce using rule 68 (expression -> primary .)
    COMMA           reduce using rule 68 (expression -> primary .)
    DOT             shift and go to state 108


state 90

    (69) expression -> assign .

    RPAREN          reduce using rule 69 (expression -> assign .)
    PLUS            reduce using rule 69 (expression -> assign .)
    MINUS           reduce using rule 69 (expression -> assign .)
    TIMES           reduce using rule 69 (expression -> assign .)
    DIVIDE          reduce using rule 69 (expression -> assign .)
    GREATER         reduce using rule 69 (expression -> assign .)
    LESS            reduce using rule 69 (expression -> assign .)
    GREATEREQ       reduce using rule 69 (expression -> assign .)
    LESSEQ          reduce using rule 69 (expression -> assign .)
    EQUAL           reduce using rule 69 (expression -> assign .)
    NOTEQUAL        reduce using rule 69 (expression -> assign .)
    AND             reduce using rule 69 (expression -> assign .)
    OR              reduce using rule 69 (expression -> assign .)
    SEMICOLON       reduce using rule 69 (expression -> assign .)
    COMMA           reduce using rule 69 (expression -> assign .)


state 91

    (72) expression -> unary_op . expression
    (68) expression -> . primary
    (69) expression -> . assign
    (70) expression -> . expression arith_op expression
    (71) expression -> . expression bool_op expression
    (72) expression -> . unary_op expression
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . LPAREN expression RPAREN
    (60) primary -> . NEW ID
    (61) primary -> . NEW ID LPAREN arguments RPAREN
    (62) primary -> . method_invocation
    (63) primary -> . lhs
    (76) assign -> . lhs SETEQUAL expression
    (89) unary_op -> . PLUS
    (90) unary_op -> . MINUS
    (91) unary_op -> . NOT
    (50) literal -> . INTEGER
    (51) literal -> . FLOAT
    (52) literal -> . STRING
    (53) literal -> . NULL
    (54) literal -> . FALSE
    (55) literal -> . TRUE
    (66) method_invocation -> . field_access LPAREN arguments RPAREN
    (67) method_invocation -> . field_access LPAREN RPAREN
    (73) lhs -> . field_access
    (74) field_access -> . primary DOT ID
    (75) field_access -> . ID

    THIS            shift and go to state 69
    SUPER           shift and go to state 70
    LPAREN          shift and go to state 50
    NEW             shift and go to state 71
    PLUS            shift and go to state 95
    MINUS           shift and go to state 96
    NOT             shift and go to state 97
    INTEGER         shift and go to state 72
    FLOAT           shift and go to state 98
    STRING          shift and go to state 73
    NULL            shift and go to state 74
    FALSE           shift and go to state 75
    TRUE            shift and go to state 76
    ID              shift and go to state 92

    unary_op                       shift and go to state 91
    expression                     shift and go to state 131
    primary                        shift and go to state 89
    assign                         shift and go to state 90
    literal                        shift and go to state 68
    method_invocation              shift and go to state 93
    lhs                            shift and go to state 94
    field_access                   shift and go to state 64

state 92

    (75) field_access -> ID .

    LPAREN          reduce using rule 75 (field_access -> ID .)
    SETEQUAL        reduce using rule 75 (field_access -> ID .)
    DOT             reduce using rule 75 (field_access -> ID .)
    RPAREN          reduce using rule 75 (field_access -> ID .)
    PLUS            reduce using rule 75 (field_access -> ID .)
    MINUS           reduce using rule 75 (field_access -> ID .)
    TIMES           reduce using rule 75 (field_access -> ID .)
    DIVIDE          reduce using rule 75 (field_access -> ID .)
    GREATER         reduce using rule 75 (field_access -> ID .)
    LESS            reduce using rule 75 (field_access -> ID .)
    GREATEREQ       reduce using rule 75 (field_access -> ID .)
    LESSEQ          reduce using rule 75 (field_access -> ID .)
    EQUAL           reduce using rule 75 (field_access -> ID .)
    NOTEQUAL        reduce using rule 75 (field_access -> ID .)
    AND             reduce using rule 75 (field_access -> ID .)
    OR              reduce using rule 75 (field_access -> ID .)
    SEMICOLON       reduce using rule 75 (field_access -> ID .)
    COMMA           reduce using rule 75 (field_access -> ID .)


state 93

    (62) primary -> method_invocation .

    DOT             reduce using rule 62 (primary -> method_invocation .)
    RPAREN          reduce using rule 62 (primary -> method_invocation .)
    PLUS            reduce using rule 62 (primary -> method_invocation .)
    MINUS           reduce using rule 62 (primary -> method_invocation .)
    TIMES           reduce using rule 62 (primary -> method_invocation .)
    DIVIDE          reduce using rule 62 (primary -> method_invocation .)
    GREATER         reduce using rule 62 (primary -> method_invocation .)
    LESS            reduce using rule 62 (primary -> method_invocation .)
    GREATEREQ       reduce using rule 62 (primary -> method_invocation .)
    LESSEQ          reduce using rule 62 (primary -> method_invocation .)
    EQUAL           reduce using rule 62 (primary -> method_invocation .)
    NOTEQUAL        reduce using rule 62 (primary -> method_invocation .)
    AND             reduce using rule 62 (primary -> method_invocation .)
    OR              reduce using rule 62 (primary -> method_invocation .)
    SEMICOLON       reduce using rule 62 (primary -> method_invocation .)
    COMMA           reduce using rule 62 (primary -> method_invocation .)


state 94

    (63) primary -> lhs .
    (76) assign -> lhs . SETEQUAL expression

    DOT             reduce using rule 63 (primary -> lhs .)
    RPAREN          reduce using rule 63 (primary -> lhs .)
    PLUS            reduce using rule 63 (primary -> lhs .)
    MINUS           reduce using rule 63 (primary -> lhs .)
    TIMES           reduce using rule 63 (primary -> lhs .)
    DIVIDE          reduce using rule 63 (primary -> lhs .)
    GREATER         reduce using rule 63 (primary -> lhs .)
    LESS            reduce using rule 63 (primary -> lhs .)
    GREATEREQ       reduce using rule 63 (primary -> lhs .)
    LESSEQ          reduce using rule 63 (primary -> lhs .)
    EQUAL           reduce using rule 63 (primary -> lhs .)
    NOTEQUAL        reduce using rule 63 (primary -> lhs .)
    AND             reduce using rule 63 (primary -> lhs .)
    OR              reduce using rule 63 (primary -> lhs .)
    SEMICOLON       reduce using rule 63 (primary -> lhs .)
    COMMA           reduce using rule 63 (primary -> lhs .)
    SETEQUAL        shift and go to state 106


state 95

    (89) unary_op -> PLUS .

    THIS            reduce using rule 89 (unary_op -> PLUS .)
    SUPER           reduce using rule 89 (unary_op -> PLUS .)
    LPAREN          reduce using rule 89 (unary_op -> PLUS .)
    NEW             reduce using rule 89 (unary_op -> PLUS .)
    PLUS            reduce using rule 89 (unary_op -> PLUS .)
    MINUS           reduce using rule 89 (unary_op -> PLUS .)
    NOT             reduce using rule 89 (unary_op -> PLUS .)
    INTEGER         reduce using rule 89 (unary_op -> PLUS .)
    FLOAT           reduce using rule 89 (unary_op -> PLUS .)
    STRING          reduce using rule 89 (unary_op -> PLUS .)
    NULL            reduce using rule 89 (unary_op -> PLUS .)
    FALSE           reduce using rule 89 (unary_op -> PLUS .)
    TRUE            reduce using rule 89 (unary_op -> PLUS .)
    ID              reduce using rule 89 (unary_op -> PLUS .)


state 96

    (90) unary_op -> MINUS .

    THIS            reduce using rule 90 (unary_op -> MINUS .)
    SUPER           reduce using rule 90 (unary_op -> MINUS .)
    LPAREN          reduce using rule 90 (unary_op -> MINUS .)
    NEW             reduce using rule 90 (unary_op -> MINUS .)
    PLUS            reduce using rule 90 (unary_op -> MINUS .)
    MINUS           reduce using rule 90 (unary_op -> MINUS .)
    NOT             reduce using rule 90 (unary_op -> MINUS .)
    INTEGER         reduce using rule 90 (unary_op -> MINUS .)
    FLOAT           reduce using rule 90 (unary_op -> MINUS .)
    STRING          reduce using rule 90 (unary_op -> MINUS .)
    NULL            reduce using rule 90 (unary_op -> MINUS .)
    FALSE           reduce using rule 90 (unary_op -> MINUS .)
    TRUE            reduce using rule 90 (unary_op -> MINUS .)
    ID              reduce using rule 90 (unary_op -> MINUS .)


state 97

    (91) unary_op -> NOT .

    THIS            reduce using rule 91 (unary_op -> NOT .)
    SUPER           reduce using rule 91 (unary_op -> NOT .)
    LPAREN          reduce using rule 91 (unary_op -> NOT .)
    NEW             reduce using rule 91 (unary_op -> NOT .)
    PLUS            reduce using rule 91 (unary_op -> NOT .)
    MINUS           reduce using rule 91 (unary_op -> NOT .)
    NOT             reduce using rule 91 (unary_op -> NOT .)
    INTEGER         reduce using rule 91 (unary_op -> NOT .)
    FLOAT           reduce using rule 91 (unary_op -> NOT .)
    STRING          reduce using rule 91 (unary_op -> NOT .)
    NULL            reduce using rule 91 (unary_op -> NOT .)
    FALSE           reduce using rule 91 (unary_op -> NOT .)
    TRUE            reduce using rule 91 (unary_op -> NOT .)
    ID              reduce using rule 91 (unary_op -> NOT .)


state 98

    (51) literal -> FLOAT .

    DOT             reduce using rule 51 (literal -> FLOAT .)
    RPAREN          reduce using rule 51 (literal -> FLOAT .)
    PLUS            reduce using rule 51 (literal -> FLOAT .)
    MINUS           reduce using rule 51 (literal -> FLOAT .)
    TIMES           reduce using rule 51 (literal -> FLOAT .)
    DIVIDE          reduce using rule 51 (literal -> FLOAT .)
    GREATER         reduce using rule 51 (literal -> FLOAT .)
    LESS            reduce using rule 51 (literal -> FLOAT .)
    GREATEREQ       reduce using rule 51 (literal -> FLOAT .)
    LESSEQ          reduce using rule 51 (literal -> FLOAT .)
    EQUAL           reduce using rule 51 (literal -> FLOAT .)
    NOTEQUAL        reduce using rule 51 (literal -> FLOAT .)
    AND             reduce using rule 51 (literal -> FLOAT .)
    OR              reduce using rule 51 (literal -> FLOAT .)
    SEMICOLON       reduce using rule 51 (literal -> FLOAT .)
    COMMA           reduce using rule 51 (literal -> FLOAT .)


state 99

    (40) stmt -> WHILE LPAREN . expression RPAREN stmt
    (68) expression -> . primary
    (69) expression -> . assign
    (70) expression -> . expression arith_op expression
    (71) expression -> . expression bool_op expression
    (72) expression -> . unary_op expression
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . LPAREN expression RPAREN
    (60) primary -> . NEW ID
    (61) primary -> . NEW ID LPAREN arguments RPAREN
    (62) primary -> . method_invocation
    (63) primary -> . lhs
    (76) assign -> . lhs SETEQUAL expression
    (89) unary_op -> . PLUS
    (90) unary_op -> . MINUS
    (91) unary_op -> . NOT
    (50) literal -> . INTEGER
    (51) literal -> . FLOAT
    (52) literal -> . STRING
    (53) literal -> . NULL
    (54) literal -> . FALSE
    (55) literal -> . TRUE
    (66) method_invocation -> . field_access LPAREN arguments RPAREN
    (67) method_invocation -> . field_access LPAREN RPAREN
    (73) lhs -> . field_access
    (74) field_access -> . primary DOT ID
    (75) field_access -> . ID

    THIS            shift and go to state 69
    SUPER           shift and go to state 70
    LPAREN          shift and go to state 50
    NEW             shift and go to state 71
    PLUS            shift and go to state 95
    MINUS           shift and go to state 96
    NOT             shift and go to state 97
    INTEGER         shift and go to state 72
    FLOAT           shift and go to state 98
    STRING          shift and go to state 73
    NULL            shift and go to state 74
    FALSE           shift and go to state 75
    TRUE            shift and go to state 76
    ID              shift and go to state 92

    expression                     shift and go to state 132
    primary                        shift and go to state 89
    assign                         shift and go to state 90
    unary_op                       shift and go to state 91
    literal                        shift and go to state 68
    method_invocation              shift and go to state 93
    lhs                            shift and go to state 94
    field_access                   shift and go to state 64

state 100

    (41) stmt -> FOR LPAREN . stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (92) stmt_expression -> . assign
    (93) stmt_expression -> . method_invocation
    (76) assign -> . lhs SETEQUAL expression
    (66) method_invocation -> . field_access LPAREN arguments RPAREN
    (67) method_invocation -> . field_access LPAREN RPAREN
    (73) lhs -> . field_access
    (74) field_access -> . primary DOT ID
    (75) field_access -> . ID
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . LPAREN expression RPAREN
    (60) primary -> . NEW ID
    (61) primary -> . NEW ID LPAREN arguments RPAREN
    (62) primary -> . method_invocation
    (63) primary -> . lhs
    (50) literal -> . INTEGER
    (51) literal -> . FLOAT
    (52) literal -> . STRING
    (53) literal -> . NULL
    (54) literal -> . FALSE
    (55) literal -> . TRUE

    ID              shift and go to state 92
    THIS            shift and go to state 69
    SUPER           shift and go to state 70
    LPAREN          shift and go to state 50
    NEW             shift and go to state 71
    INTEGER         shift and go to state 72
    FLOAT           shift and go to state 98
    STRING          shift and go to state 73
    NULL            shift and go to state 74
    FALSE           shift and go to state 75
    TRUE            shift and go to state 76

    stmt_expression                shift and go to state 133
    assign                         shift and go to state 60
    method_invocation              shift and go to state 61
    lhs                            shift and go to state 63
    field_access                   shift and go to state 64
    primary                        shift and go to state 67
    literal                        shift and go to state 68

state 101

    (44) stmt -> stmt_expression SEMICOLON .

    RCURLY          reduce using rule 44 (stmt -> stmt_expression SEMICOLON .)
    IF              reduce using rule 44 (stmt -> stmt_expression SEMICOLON .)
    WHILE           reduce using rule 44 (stmt -> stmt_expression SEMICOLON .)
    FOR             reduce using rule 44 (stmt -> stmt_expression SEMICOLON .)
    RETURN          reduce using rule 44 (stmt -> stmt_expression SEMICOLON .)
    BREAK           reduce using rule 44 (stmt -> stmt_expression SEMICOLON .)
    CONTINUE        reduce using rule 44 (stmt -> stmt_expression SEMICOLON .)
    SEMICOLON       reduce using rule 44 (stmt -> stmt_expression SEMICOLON .)
    LCURLY          reduce using rule 44 (stmt -> stmt_expression SEMICOLON .)
    INT             reduce using rule 44 (stmt -> stmt_expression SEMICOLON .)
    FLOAT           reduce using rule 44 (stmt -> stmt_expression SEMICOLON .)
    BOOLEAN         reduce using rule 44 (stmt -> stmt_expression SEMICOLON .)
    ID              reduce using rule 44 (stmt -> stmt_expression SEMICOLON .)
    THIS            reduce using rule 44 (stmt -> stmt_expression SEMICOLON .)
    SUPER           reduce using rule 44 (stmt -> stmt_expression SEMICOLON .)
    LPAREN          reduce using rule 44 (stmt -> stmt_expression SEMICOLON .)
    NEW             reduce using rule 44 (stmt -> stmt_expression SEMICOLON .)
    INTEGER         reduce using rule 44 (stmt -> stmt_expression SEMICOLON .)
    STRING          reduce using rule 44 (stmt -> stmt_expression SEMICOLON .)
    NULL            reduce using rule 44 (stmt -> stmt_expression SEMICOLON .)
    FALSE           reduce using rule 44 (stmt -> stmt_expression SEMICOLON .)
    TRUE            reduce using rule 44 (stmt -> stmt_expression SEMICOLON .)
    ELSE            reduce using rule 44 (stmt -> stmt_expression SEMICOLON .)


state 102

    (42) stmt -> RETURN expression . SEMICOLON
    (70) expression -> expression . arith_op expression
    (71) expression -> expression . bool_op expression
    (77) arith_op -> . PLUS
    (78) arith_op -> . MINUS
    (79) arith_op -> . TIMES
    (80) arith_op -> . DIVIDE
    (81) bool_op -> . GREATER
    (82) bool_op -> . LESS
    (83) bool_op -> . GREATEREQ
    (84) bool_op -> . LESSEQ
    (85) bool_op -> . EQUAL
    (86) bool_op -> . NOTEQUAL
    (87) bool_op -> . AND
    (88) bool_op -> . OR

    SEMICOLON       shift and go to state 134
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    TIMES           shift and go to state 121
    DIVIDE          shift and go to state 122
    GREATER         shift and go to state 123
    LESS            shift and go to state 124
    GREATEREQ       shift and go to state 125
    LESSEQ          shift and go to state 126
    EQUAL           shift and go to state 127
    NOTEQUAL        shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130

    arith_op                       shift and go to state 117
    bool_op                        shift and go to state 118

state 103

    (43) stmt -> RETURN SEMICOLON .

    RCURLY          reduce using rule 43 (stmt -> RETURN SEMICOLON .)
    IF              reduce using rule 43 (stmt -> RETURN SEMICOLON .)
    WHILE           reduce using rule 43 (stmt -> RETURN SEMICOLON .)
    FOR             reduce using rule 43 (stmt -> RETURN SEMICOLON .)
    RETURN          reduce using rule 43 (stmt -> RETURN SEMICOLON .)
    BREAK           reduce using rule 43 (stmt -> RETURN SEMICOLON .)
    CONTINUE        reduce using rule 43 (stmt -> RETURN SEMICOLON .)
    SEMICOLON       reduce using rule 43 (stmt -> RETURN SEMICOLON .)
    LCURLY          reduce using rule 43 (stmt -> RETURN SEMICOLON .)
    INT             reduce using rule 43 (stmt -> RETURN SEMICOLON .)
    FLOAT           reduce using rule 43 (stmt -> RETURN SEMICOLON .)
    BOOLEAN         reduce using rule 43 (stmt -> RETURN SEMICOLON .)
    ID              reduce using rule 43 (stmt -> RETURN SEMICOLON .)
    THIS            reduce using rule 43 (stmt -> RETURN SEMICOLON .)
    SUPER           reduce using rule 43 (stmt -> RETURN SEMICOLON .)
    LPAREN          reduce using rule 43 (stmt -> RETURN SEMICOLON .)
    NEW             reduce using rule 43 (stmt -> RETURN SEMICOLON .)
    INTEGER         reduce using rule 43 (stmt -> RETURN SEMICOLON .)
    STRING          reduce using rule 43 (stmt -> RETURN SEMICOLON .)
    NULL            reduce using rule 43 (stmt -> RETURN SEMICOLON .)
    FALSE           reduce using rule 43 (stmt -> RETURN SEMICOLON .)
    TRUE            reduce using rule 43 (stmt -> RETURN SEMICOLON .)
    ELSE            reduce using rule 43 (stmt -> RETURN SEMICOLON .)


state 104

    (45) stmt -> BREAK SEMICOLON .

    RCURLY          reduce using rule 45 (stmt -> BREAK SEMICOLON .)
    IF              reduce using rule 45 (stmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 45 (stmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 45 (stmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 45 (stmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 45 (stmt -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 45 (stmt -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 45 (stmt -> BREAK SEMICOLON .)
    LCURLY          reduce using rule 45 (stmt -> BREAK SEMICOLON .)
    INT             reduce using rule 45 (stmt -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 45 (stmt -> BREAK SEMICOLON .)
    BOOLEAN         reduce using rule 45 (stmt -> BREAK SEMICOLON .)
    ID              reduce using rule 45 (stmt -> BREAK SEMICOLON .)
    THIS            reduce using rule 45 (stmt -> BREAK SEMICOLON .)
    SUPER           reduce using rule 45 (stmt -> BREAK SEMICOLON .)
    LPAREN          reduce using rule 45 (stmt -> BREAK SEMICOLON .)
    NEW             reduce using rule 45 (stmt -> BREAK SEMICOLON .)
    INTEGER         reduce using rule 45 (stmt -> BREAK SEMICOLON .)
    STRING          reduce using rule 45 (stmt -> BREAK SEMICOLON .)
    NULL            reduce using rule 45 (stmt -> BREAK SEMICOLON .)
    FALSE           reduce using rule 45 (stmt -> BREAK SEMICOLON .)
    TRUE            reduce using rule 45 (stmt -> BREAK SEMICOLON .)
    ELSE            reduce using rule 45 (stmt -> BREAK SEMICOLON .)


state 105

    (46) stmt -> CONTINUE SEMICOLON .

    RCURLY          reduce using rule 46 (stmt -> CONTINUE SEMICOLON .)
    IF              reduce using rule 46 (stmt -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 46 (stmt -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 46 (stmt -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 46 (stmt -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 46 (stmt -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 46 (stmt -> CONTINUE SEMICOLON .)
    SEMICOLON       reduce using rule 46 (stmt -> CONTINUE SEMICOLON .)
    LCURLY          reduce using rule 46 (stmt -> CONTINUE SEMICOLON .)
    INT             reduce using rule 46 (stmt -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 46 (stmt -> CONTINUE SEMICOLON .)
    BOOLEAN         reduce using rule 46 (stmt -> CONTINUE SEMICOLON .)
    ID              reduce using rule 46 (stmt -> CONTINUE SEMICOLON .)
    THIS            reduce using rule 46 (stmt -> CONTINUE SEMICOLON .)
    SUPER           reduce using rule 46 (stmt -> CONTINUE SEMICOLON .)
    LPAREN          reduce using rule 46 (stmt -> CONTINUE SEMICOLON .)
    NEW             reduce using rule 46 (stmt -> CONTINUE SEMICOLON .)
    INTEGER         reduce using rule 46 (stmt -> CONTINUE SEMICOLON .)
    STRING          reduce using rule 46 (stmt -> CONTINUE SEMICOLON .)
    NULL            reduce using rule 46 (stmt -> CONTINUE SEMICOLON .)
    FALSE           reduce using rule 46 (stmt -> CONTINUE SEMICOLON .)
    TRUE            reduce using rule 46 (stmt -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 46 (stmt -> CONTINUE SEMICOLON .)


state 106

    (76) assign -> lhs SETEQUAL . expression
    (68) expression -> . primary
    (69) expression -> . assign
    (70) expression -> . expression arith_op expression
    (71) expression -> . expression bool_op expression
    (72) expression -> . unary_op expression
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . LPAREN expression RPAREN
    (60) primary -> . NEW ID
    (61) primary -> . NEW ID LPAREN arguments RPAREN
    (62) primary -> . method_invocation
    (63) primary -> . lhs
    (76) assign -> . lhs SETEQUAL expression
    (89) unary_op -> . PLUS
    (90) unary_op -> . MINUS
    (91) unary_op -> . NOT
    (50) literal -> . INTEGER
    (51) literal -> . FLOAT
    (52) literal -> . STRING
    (53) literal -> . NULL
    (54) literal -> . FALSE
    (55) literal -> . TRUE
    (66) method_invocation -> . field_access LPAREN arguments RPAREN
    (67) method_invocation -> . field_access LPAREN RPAREN
    (73) lhs -> . field_access
    (74) field_access -> . primary DOT ID
    (75) field_access -> . ID

    THIS            shift and go to state 69
    SUPER           shift and go to state 70
    LPAREN          shift and go to state 50
    NEW             shift and go to state 71
    PLUS            shift and go to state 95
    MINUS           shift and go to state 96
    NOT             shift and go to state 97
    INTEGER         shift and go to state 72
    FLOAT           shift and go to state 98
    STRING          shift and go to state 73
    NULL            shift and go to state 74
    FALSE           shift and go to state 75
    TRUE            shift and go to state 76
    ID              shift and go to state 92

    lhs                            shift and go to state 94
    expression                     shift and go to state 135
    primary                        shift and go to state 89
    assign                         shift and go to state 90
    unary_op                       shift and go to state 91
    literal                        shift and go to state 68
    method_invocation              shift and go to state 93
    field_access                   shift and go to state 64

state 107

    (66) method_invocation -> field_access LPAREN . arguments RPAREN
    (67) method_invocation -> field_access LPAREN . RPAREN
    (64) arguments -> . expression
    (65) arguments -> . expression COMMA arguments
    (68) expression -> . primary
    (69) expression -> . assign
    (70) expression -> . expression arith_op expression
    (71) expression -> . expression bool_op expression
    (72) expression -> . unary_op expression
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . LPAREN expression RPAREN
    (60) primary -> . NEW ID
    (61) primary -> . NEW ID LPAREN arguments RPAREN
    (62) primary -> . method_invocation
    (63) primary -> . lhs
    (76) assign -> . lhs SETEQUAL expression
    (89) unary_op -> . PLUS
    (90) unary_op -> . MINUS
    (91) unary_op -> . NOT
    (50) literal -> . INTEGER
    (51) literal -> . FLOAT
    (52) literal -> . STRING
    (53) literal -> . NULL
    (54) literal -> . FALSE
    (55) literal -> . TRUE
    (66) method_invocation -> . field_access LPAREN arguments RPAREN
    (67) method_invocation -> . field_access LPAREN RPAREN
    (73) lhs -> . field_access
    (74) field_access -> . primary DOT ID
    (75) field_access -> . ID

    RPAREN          shift and go to state 137
    THIS            shift and go to state 69
    SUPER           shift and go to state 70
    LPAREN          shift and go to state 50
    NEW             shift and go to state 71
    PLUS            shift and go to state 95
    MINUS           shift and go to state 96
    NOT             shift and go to state 97
    INTEGER         shift and go to state 72
    FLOAT           shift and go to state 98
    STRING          shift and go to state 73
    NULL            shift and go to state 74
    FALSE           shift and go to state 75
    TRUE            shift and go to state 76
    ID              shift and go to state 92

    field_access                   shift and go to state 64
    arguments                      shift and go to state 136
    expression                     shift and go to state 138
    primary                        shift and go to state 89
    assign                         shift and go to state 90
    unary_op                       shift and go to state 91
    literal                        shift and go to state 68
    method_invocation              shift and go to state 93
    lhs                            shift and go to state 94

state 108

    (74) field_access -> primary DOT . ID

    ID              shift and go to state 139


state 109

    (60) primary -> NEW ID .
    (61) primary -> NEW ID . LPAREN arguments RPAREN

    DOT             reduce using rule 60 (primary -> NEW ID .)
    RPAREN          reduce using rule 60 (primary -> NEW ID .)
    PLUS            reduce using rule 60 (primary -> NEW ID .)
    MINUS           reduce using rule 60 (primary -> NEW ID .)
    TIMES           reduce using rule 60 (primary -> NEW ID .)
    DIVIDE          reduce using rule 60 (primary -> NEW ID .)
    GREATER         reduce using rule 60 (primary -> NEW ID .)
    LESS            reduce using rule 60 (primary -> NEW ID .)
    GREATEREQ       reduce using rule 60 (primary -> NEW ID .)
    LESSEQ          reduce using rule 60 (primary -> NEW ID .)
    EQUAL           reduce using rule 60 (primary -> NEW ID .)
    NOTEQUAL        reduce using rule 60 (primary -> NEW ID .)
    AND             reduce using rule 60 (primary -> NEW ID .)
    OR              reduce using rule 60 (primary -> NEW ID .)
    SEMICOLON       reduce using rule 60 (primary -> NEW ID .)
    COMMA           reduce using rule 60 (primary -> NEW ID .)
    LPAREN          shift and go to state 140


state 110

    (32) formals -> formal_param COMMA formals .

    LCURLY          reduce using rule 32 (formals -> formal_param COMMA formals .)
    RCURLY          reduce using rule 32 (formals -> formal_param COMMA formals .)
    PUBLIC          reduce using rule 32 (formals -> formal_param COMMA formals .)
    PRIVATE         reduce using rule 32 (formals -> formal_param COMMA formals .)
    VOID            reduce using rule 32 (formals -> formal_param COMMA formals .)
    ID              reduce using rule 32 (formals -> formal_param COMMA formals .)
    INT             reduce using rule 32 (formals -> formal_param COMMA formals .)
    FLOAT           reduce using rule 32 (formals -> formal_param COMMA formals .)
    BOOLEAN         reduce using rule 32 (formals -> formal_param COMMA formals .)
    RPAREN          reduce using rule 32 (formals -> formal_param COMMA formals .)


state 111

    (27) method_decl -> modifier VOID ID LPAREN RPAREN . block
    (34) block -> . LCURLY stmtlist RCURLY
    (35) block -> . empty
    (94) empty -> .

    LCURLY          shift and go to state 37
    RCURLY          reduce using rule 94 (empty -> .)
    PUBLIC          reduce using rule 94 (empty -> .)
    PRIVATE         reduce using rule 94 (empty -> .)
    VOID            reduce using rule 94 (empty -> .)
    ID              reduce using rule 94 (empty -> .)
    INT             reduce using rule 94 (empty -> .)
    FLOAT           reduce using rule 94 (empty -> .)
    BOOLEAN         reduce using rule 94 (empty -> .)

    block                          shift and go to state 141
    empty                          shift and go to state 38

state 112

    (28) method_decl -> modifier VOID ID LPAREN formals . RPAREN block

    RPAREN          shift and go to state 142


state 113

    (25) method_decl -> modifier type ID LPAREN RPAREN block .

    RCURLY          reduce using rule 25 (method_decl -> modifier type ID LPAREN RPAREN block .)
    PUBLIC          reduce using rule 25 (method_decl -> modifier type ID LPAREN RPAREN block .)
    PRIVATE         reduce using rule 25 (method_decl -> modifier type ID LPAREN RPAREN block .)
    VOID            reduce using rule 25 (method_decl -> modifier type ID LPAREN RPAREN block .)
    ID              reduce using rule 25 (method_decl -> modifier type ID LPAREN RPAREN block .)
    INT             reduce using rule 25 (method_decl -> modifier type ID LPAREN RPAREN block .)
    FLOAT           reduce using rule 25 (method_decl -> modifier type ID LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 25 (method_decl -> modifier type ID LPAREN RPAREN block .)


state 114

    (26) method_decl -> modifier type ID LPAREN formals RPAREN . block
    (34) block -> . LCURLY stmtlist RCURLY
    (35) block -> . empty
    (94) empty -> .

    LCURLY          shift and go to state 37
    RCURLY          reduce using rule 94 (empty -> .)
    PUBLIC          reduce using rule 94 (empty -> .)
    PRIVATE         reduce using rule 94 (empty -> .)
    VOID            reduce using rule 94 (empty -> .)
    ID              reduce using rule 94 (empty -> .)
    INT             reduce using rule 94 (empty -> .)
    FLOAT           reduce using rule 94 (empty -> .)
    BOOLEAN         reduce using rule 94 (empty -> .)

    block                          shift and go to state 143
    empty                          shift and go to state 38

state 115

    (38) stmt -> IF LPAREN expression . RPAREN stmt
    (39) stmt -> IF LPAREN expression . RPAREN stmt ELSE stmt
    (70) expression -> expression . arith_op expression
    (71) expression -> expression . bool_op expression
    (77) arith_op -> . PLUS
    (78) arith_op -> . MINUS
    (79) arith_op -> . TIMES
    (80) arith_op -> . DIVIDE
    (81) bool_op -> . GREATER
    (82) bool_op -> . LESS
    (83) bool_op -> . GREATEREQ
    (84) bool_op -> . LESSEQ
    (85) bool_op -> . EQUAL
    (86) bool_op -> . NOTEQUAL
    (87) bool_op -> . AND
    (88) bool_op -> . OR

    RPAREN          shift and go to state 144
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    TIMES           shift and go to state 121
    DIVIDE          shift and go to state 122
    GREATER         shift and go to state 123
    LESS            shift and go to state 124
    GREATEREQ       shift and go to state 125
    LESSEQ          shift and go to state 126
    EQUAL           shift and go to state 127
    NOTEQUAL        shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130

    arith_op                       shift and go to state 117
    bool_op                        shift and go to state 118

state 116

    (59) primary -> LPAREN expression RPAREN .

    DOT             reduce using rule 59 (primary -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 59 (primary -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 59 (primary -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 59 (primary -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 59 (primary -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 59 (primary -> LPAREN expression RPAREN .)
    GREATER         reduce using rule 59 (primary -> LPAREN expression RPAREN .)
    LESS            reduce using rule 59 (primary -> LPAREN expression RPAREN .)
    GREATEREQ       reduce using rule 59 (primary -> LPAREN expression RPAREN .)
    LESSEQ          reduce using rule 59 (primary -> LPAREN expression RPAREN .)
    EQUAL           reduce using rule 59 (primary -> LPAREN expression RPAREN .)
    NOTEQUAL        reduce using rule 59 (primary -> LPAREN expression RPAREN .)
    AND             reduce using rule 59 (primary -> LPAREN expression RPAREN .)
    OR              reduce using rule 59 (primary -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 59 (primary -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 59 (primary -> LPAREN expression RPAREN .)


state 117

    (70) expression -> expression arith_op . expression
    (68) expression -> . primary
    (69) expression -> . assign
    (70) expression -> . expression arith_op expression
    (71) expression -> . expression bool_op expression
    (72) expression -> . unary_op expression
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . LPAREN expression RPAREN
    (60) primary -> . NEW ID
    (61) primary -> . NEW ID LPAREN arguments RPAREN
    (62) primary -> . method_invocation
    (63) primary -> . lhs
    (76) assign -> . lhs SETEQUAL expression
    (89) unary_op -> . PLUS
    (90) unary_op -> . MINUS
    (91) unary_op -> . NOT
    (50) literal -> . INTEGER
    (51) literal -> . FLOAT
    (52) literal -> . STRING
    (53) literal -> . NULL
    (54) literal -> . FALSE
    (55) literal -> . TRUE
    (66) method_invocation -> . field_access LPAREN arguments RPAREN
    (67) method_invocation -> . field_access LPAREN RPAREN
    (73) lhs -> . field_access
    (74) field_access -> . primary DOT ID
    (75) field_access -> . ID

    THIS            shift and go to state 69
    SUPER           shift and go to state 70
    LPAREN          shift and go to state 50
    NEW             shift and go to state 71
    PLUS            shift and go to state 95
    MINUS           shift and go to state 96
    NOT             shift and go to state 97
    INTEGER         shift and go to state 72
    FLOAT           shift and go to state 98
    STRING          shift and go to state 73
    NULL            shift and go to state 74
    FALSE           shift and go to state 75
    TRUE            shift and go to state 76
    ID              shift and go to state 92

    expression                     shift and go to state 145
    primary                        shift and go to state 89
    assign                         shift and go to state 90
    unary_op                       shift and go to state 91
    literal                        shift and go to state 68
    method_invocation              shift and go to state 93
    lhs                            shift and go to state 94
    field_access                   shift and go to state 64

state 118

    (71) expression -> expression bool_op . expression
    (68) expression -> . primary
    (69) expression -> . assign
    (70) expression -> . expression arith_op expression
    (71) expression -> . expression bool_op expression
    (72) expression -> . unary_op expression
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . LPAREN expression RPAREN
    (60) primary -> . NEW ID
    (61) primary -> . NEW ID LPAREN arguments RPAREN
    (62) primary -> . method_invocation
    (63) primary -> . lhs
    (76) assign -> . lhs SETEQUAL expression
    (89) unary_op -> . PLUS
    (90) unary_op -> . MINUS
    (91) unary_op -> . NOT
    (50) literal -> . INTEGER
    (51) literal -> . FLOAT
    (52) literal -> . STRING
    (53) literal -> . NULL
    (54) literal -> . FALSE
    (55) literal -> . TRUE
    (66) method_invocation -> . field_access LPAREN arguments RPAREN
    (67) method_invocation -> . field_access LPAREN RPAREN
    (73) lhs -> . field_access
    (74) field_access -> . primary DOT ID
    (75) field_access -> . ID

    THIS            shift and go to state 69
    SUPER           shift and go to state 70
    LPAREN          shift and go to state 50
    NEW             shift and go to state 71
    PLUS            shift and go to state 95
    MINUS           shift and go to state 96
    NOT             shift and go to state 97
    INTEGER         shift and go to state 72
    FLOAT           shift and go to state 98
    STRING          shift and go to state 73
    NULL            shift and go to state 74
    FALSE           shift and go to state 75
    TRUE            shift and go to state 76
    ID              shift and go to state 92

    expression                     shift and go to state 146
    primary                        shift and go to state 89
    assign                         shift and go to state 90
    unary_op                       shift and go to state 91
    literal                        shift and go to state 68
    method_invocation              shift and go to state 93
    lhs                            shift and go to state 94
    field_access                   shift and go to state 64

state 119

    (77) arith_op -> PLUS .

    THIS            reduce using rule 77 (arith_op -> PLUS .)
    SUPER           reduce using rule 77 (arith_op -> PLUS .)
    LPAREN          reduce using rule 77 (arith_op -> PLUS .)
    NEW             reduce using rule 77 (arith_op -> PLUS .)
    PLUS            reduce using rule 77 (arith_op -> PLUS .)
    MINUS           reduce using rule 77 (arith_op -> PLUS .)
    NOT             reduce using rule 77 (arith_op -> PLUS .)
    INTEGER         reduce using rule 77 (arith_op -> PLUS .)
    FLOAT           reduce using rule 77 (arith_op -> PLUS .)
    STRING          reduce using rule 77 (arith_op -> PLUS .)
    NULL            reduce using rule 77 (arith_op -> PLUS .)
    FALSE           reduce using rule 77 (arith_op -> PLUS .)
    TRUE            reduce using rule 77 (arith_op -> PLUS .)
    ID              reduce using rule 77 (arith_op -> PLUS .)


state 120

    (78) arith_op -> MINUS .

    THIS            reduce using rule 78 (arith_op -> MINUS .)
    SUPER           reduce using rule 78 (arith_op -> MINUS .)
    LPAREN          reduce using rule 78 (arith_op -> MINUS .)
    NEW             reduce using rule 78 (arith_op -> MINUS .)
    PLUS            reduce using rule 78 (arith_op -> MINUS .)
    MINUS           reduce using rule 78 (arith_op -> MINUS .)
    NOT             reduce using rule 78 (arith_op -> MINUS .)
    INTEGER         reduce using rule 78 (arith_op -> MINUS .)
    FLOAT           reduce using rule 78 (arith_op -> MINUS .)
    STRING          reduce using rule 78 (arith_op -> MINUS .)
    NULL            reduce using rule 78 (arith_op -> MINUS .)
    FALSE           reduce using rule 78 (arith_op -> MINUS .)
    TRUE            reduce using rule 78 (arith_op -> MINUS .)
    ID              reduce using rule 78 (arith_op -> MINUS .)


state 121

    (79) arith_op -> TIMES .

    THIS            reduce using rule 79 (arith_op -> TIMES .)
    SUPER           reduce using rule 79 (arith_op -> TIMES .)
    LPAREN          reduce using rule 79 (arith_op -> TIMES .)
    NEW             reduce using rule 79 (arith_op -> TIMES .)
    PLUS            reduce using rule 79 (arith_op -> TIMES .)
    MINUS           reduce using rule 79 (arith_op -> TIMES .)
    NOT             reduce using rule 79 (arith_op -> TIMES .)
    INTEGER         reduce using rule 79 (arith_op -> TIMES .)
    FLOAT           reduce using rule 79 (arith_op -> TIMES .)
    STRING          reduce using rule 79 (arith_op -> TIMES .)
    NULL            reduce using rule 79 (arith_op -> TIMES .)
    FALSE           reduce using rule 79 (arith_op -> TIMES .)
    TRUE            reduce using rule 79 (arith_op -> TIMES .)
    ID              reduce using rule 79 (arith_op -> TIMES .)


state 122

    (80) arith_op -> DIVIDE .

    THIS            reduce using rule 80 (arith_op -> DIVIDE .)
    SUPER           reduce using rule 80 (arith_op -> DIVIDE .)
    LPAREN          reduce using rule 80 (arith_op -> DIVIDE .)
    NEW             reduce using rule 80 (arith_op -> DIVIDE .)
    PLUS            reduce using rule 80 (arith_op -> DIVIDE .)
    MINUS           reduce using rule 80 (arith_op -> DIVIDE .)
    NOT             reduce using rule 80 (arith_op -> DIVIDE .)
    INTEGER         reduce using rule 80 (arith_op -> DIVIDE .)
    FLOAT           reduce using rule 80 (arith_op -> DIVIDE .)
    STRING          reduce using rule 80 (arith_op -> DIVIDE .)
    NULL            reduce using rule 80 (arith_op -> DIVIDE .)
    FALSE           reduce using rule 80 (arith_op -> DIVIDE .)
    TRUE            reduce using rule 80 (arith_op -> DIVIDE .)
    ID              reduce using rule 80 (arith_op -> DIVIDE .)


state 123

    (81) bool_op -> GREATER .

    THIS            reduce using rule 81 (bool_op -> GREATER .)
    SUPER           reduce using rule 81 (bool_op -> GREATER .)
    LPAREN          reduce using rule 81 (bool_op -> GREATER .)
    NEW             reduce using rule 81 (bool_op -> GREATER .)
    PLUS            reduce using rule 81 (bool_op -> GREATER .)
    MINUS           reduce using rule 81 (bool_op -> GREATER .)
    NOT             reduce using rule 81 (bool_op -> GREATER .)
    INTEGER         reduce using rule 81 (bool_op -> GREATER .)
    FLOAT           reduce using rule 81 (bool_op -> GREATER .)
    STRING          reduce using rule 81 (bool_op -> GREATER .)
    NULL            reduce using rule 81 (bool_op -> GREATER .)
    FALSE           reduce using rule 81 (bool_op -> GREATER .)
    TRUE            reduce using rule 81 (bool_op -> GREATER .)
    ID              reduce using rule 81 (bool_op -> GREATER .)


state 124

    (82) bool_op -> LESS .

    THIS            reduce using rule 82 (bool_op -> LESS .)
    SUPER           reduce using rule 82 (bool_op -> LESS .)
    LPAREN          reduce using rule 82 (bool_op -> LESS .)
    NEW             reduce using rule 82 (bool_op -> LESS .)
    PLUS            reduce using rule 82 (bool_op -> LESS .)
    MINUS           reduce using rule 82 (bool_op -> LESS .)
    NOT             reduce using rule 82 (bool_op -> LESS .)
    INTEGER         reduce using rule 82 (bool_op -> LESS .)
    FLOAT           reduce using rule 82 (bool_op -> LESS .)
    STRING          reduce using rule 82 (bool_op -> LESS .)
    NULL            reduce using rule 82 (bool_op -> LESS .)
    FALSE           reduce using rule 82 (bool_op -> LESS .)
    TRUE            reduce using rule 82 (bool_op -> LESS .)
    ID              reduce using rule 82 (bool_op -> LESS .)


state 125

    (83) bool_op -> GREATEREQ .

    THIS            reduce using rule 83 (bool_op -> GREATEREQ .)
    SUPER           reduce using rule 83 (bool_op -> GREATEREQ .)
    LPAREN          reduce using rule 83 (bool_op -> GREATEREQ .)
    NEW             reduce using rule 83 (bool_op -> GREATEREQ .)
    PLUS            reduce using rule 83 (bool_op -> GREATEREQ .)
    MINUS           reduce using rule 83 (bool_op -> GREATEREQ .)
    NOT             reduce using rule 83 (bool_op -> GREATEREQ .)
    INTEGER         reduce using rule 83 (bool_op -> GREATEREQ .)
    FLOAT           reduce using rule 83 (bool_op -> GREATEREQ .)
    STRING          reduce using rule 83 (bool_op -> GREATEREQ .)
    NULL            reduce using rule 83 (bool_op -> GREATEREQ .)
    FALSE           reduce using rule 83 (bool_op -> GREATEREQ .)
    TRUE            reduce using rule 83 (bool_op -> GREATEREQ .)
    ID              reduce using rule 83 (bool_op -> GREATEREQ .)


state 126

    (84) bool_op -> LESSEQ .

    THIS            reduce using rule 84 (bool_op -> LESSEQ .)
    SUPER           reduce using rule 84 (bool_op -> LESSEQ .)
    LPAREN          reduce using rule 84 (bool_op -> LESSEQ .)
    NEW             reduce using rule 84 (bool_op -> LESSEQ .)
    PLUS            reduce using rule 84 (bool_op -> LESSEQ .)
    MINUS           reduce using rule 84 (bool_op -> LESSEQ .)
    NOT             reduce using rule 84 (bool_op -> LESSEQ .)
    INTEGER         reduce using rule 84 (bool_op -> LESSEQ .)
    FLOAT           reduce using rule 84 (bool_op -> LESSEQ .)
    STRING          reduce using rule 84 (bool_op -> LESSEQ .)
    NULL            reduce using rule 84 (bool_op -> LESSEQ .)
    FALSE           reduce using rule 84 (bool_op -> LESSEQ .)
    TRUE            reduce using rule 84 (bool_op -> LESSEQ .)
    ID              reduce using rule 84 (bool_op -> LESSEQ .)


state 127

    (85) bool_op -> EQUAL .

    THIS            reduce using rule 85 (bool_op -> EQUAL .)
    SUPER           reduce using rule 85 (bool_op -> EQUAL .)
    LPAREN          reduce using rule 85 (bool_op -> EQUAL .)
    NEW             reduce using rule 85 (bool_op -> EQUAL .)
    PLUS            reduce using rule 85 (bool_op -> EQUAL .)
    MINUS           reduce using rule 85 (bool_op -> EQUAL .)
    NOT             reduce using rule 85 (bool_op -> EQUAL .)
    INTEGER         reduce using rule 85 (bool_op -> EQUAL .)
    FLOAT           reduce using rule 85 (bool_op -> EQUAL .)
    STRING          reduce using rule 85 (bool_op -> EQUAL .)
    NULL            reduce using rule 85 (bool_op -> EQUAL .)
    FALSE           reduce using rule 85 (bool_op -> EQUAL .)
    TRUE            reduce using rule 85 (bool_op -> EQUAL .)
    ID              reduce using rule 85 (bool_op -> EQUAL .)


state 128

    (86) bool_op -> NOTEQUAL .

    THIS            reduce using rule 86 (bool_op -> NOTEQUAL .)
    SUPER           reduce using rule 86 (bool_op -> NOTEQUAL .)
    LPAREN          reduce using rule 86 (bool_op -> NOTEQUAL .)
    NEW             reduce using rule 86 (bool_op -> NOTEQUAL .)
    PLUS            reduce using rule 86 (bool_op -> NOTEQUAL .)
    MINUS           reduce using rule 86 (bool_op -> NOTEQUAL .)
    NOT             reduce using rule 86 (bool_op -> NOTEQUAL .)
    INTEGER         reduce using rule 86 (bool_op -> NOTEQUAL .)
    FLOAT           reduce using rule 86 (bool_op -> NOTEQUAL .)
    STRING          reduce using rule 86 (bool_op -> NOTEQUAL .)
    NULL            reduce using rule 86 (bool_op -> NOTEQUAL .)
    FALSE           reduce using rule 86 (bool_op -> NOTEQUAL .)
    TRUE            reduce using rule 86 (bool_op -> NOTEQUAL .)
    ID              reduce using rule 86 (bool_op -> NOTEQUAL .)


state 129

    (87) bool_op -> AND .

    THIS            reduce using rule 87 (bool_op -> AND .)
    SUPER           reduce using rule 87 (bool_op -> AND .)
    LPAREN          reduce using rule 87 (bool_op -> AND .)
    NEW             reduce using rule 87 (bool_op -> AND .)
    PLUS            reduce using rule 87 (bool_op -> AND .)
    MINUS           reduce using rule 87 (bool_op -> AND .)
    NOT             reduce using rule 87 (bool_op -> AND .)
    INTEGER         reduce using rule 87 (bool_op -> AND .)
    FLOAT           reduce using rule 87 (bool_op -> AND .)
    STRING          reduce using rule 87 (bool_op -> AND .)
    NULL            reduce using rule 87 (bool_op -> AND .)
    FALSE           reduce using rule 87 (bool_op -> AND .)
    TRUE            reduce using rule 87 (bool_op -> AND .)
    ID              reduce using rule 87 (bool_op -> AND .)


state 130

    (88) bool_op -> OR .

    THIS            reduce using rule 88 (bool_op -> OR .)
    SUPER           reduce using rule 88 (bool_op -> OR .)
    LPAREN          reduce using rule 88 (bool_op -> OR .)
    NEW             reduce using rule 88 (bool_op -> OR .)
    PLUS            reduce using rule 88 (bool_op -> OR .)
    MINUS           reduce using rule 88 (bool_op -> OR .)
    NOT             reduce using rule 88 (bool_op -> OR .)
    INTEGER         reduce using rule 88 (bool_op -> OR .)
    FLOAT           reduce using rule 88 (bool_op -> OR .)
    STRING          reduce using rule 88 (bool_op -> OR .)
    NULL            reduce using rule 88 (bool_op -> OR .)
    FALSE           reduce using rule 88 (bool_op -> OR .)
    TRUE            reduce using rule 88 (bool_op -> OR .)
    ID              reduce using rule 88 (bool_op -> OR .)


state 131

    (72) expression -> unary_op expression .
    (70) expression -> expression . arith_op expression
    (71) expression -> expression . bool_op expression
    (77) arith_op -> . PLUS
    (78) arith_op -> . MINUS
    (79) arith_op -> . TIMES
    (80) arith_op -> . DIVIDE
    (81) bool_op -> . GREATER
    (82) bool_op -> . LESS
    (83) bool_op -> . GREATEREQ
    (84) bool_op -> . LESSEQ
    (85) bool_op -> . EQUAL
    (86) bool_op -> . NOTEQUAL
    (87) bool_op -> . AND
    (88) bool_op -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 72 (expression -> unary_op expression .)
    SEMICOLON       reduce using rule 72 (expression -> unary_op expression .)
    COMMA           reduce using rule 72 (expression -> unary_op expression .)
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    TIMES           shift and go to state 121
    DIVIDE          shift and go to state 122
    GREATER         shift and go to state 123
    LESS            shift and go to state 124
    GREATEREQ       shift and go to state 125
    LESSEQ          shift and go to state 126
    EQUAL           shift and go to state 127
    NOTEQUAL        shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130

  ! PLUS            [ reduce using rule 72 (expression -> unary_op expression .) ]
  ! MINUS           [ reduce using rule 72 (expression -> unary_op expression .) ]
  ! TIMES           [ reduce using rule 72 (expression -> unary_op expression .) ]
  ! DIVIDE          [ reduce using rule 72 (expression -> unary_op expression .) ]
  ! GREATER         [ reduce using rule 72 (expression -> unary_op expression .) ]
  ! LESS            [ reduce using rule 72 (expression -> unary_op expression .) ]
  ! GREATEREQ       [ reduce using rule 72 (expression -> unary_op expression .) ]
  ! LESSEQ          [ reduce using rule 72 (expression -> unary_op expression .) ]
  ! EQUAL           [ reduce using rule 72 (expression -> unary_op expression .) ]
  ! NOTEQUAL        [ reduce using rule 72 (expression -> unary_op expression .) ]
  ! AND             [ reduce using rule 72 (expression -> unary_op expression .) ]
  ! OR              [ reduce using rule 72 (expression -> unary_op expression .) ]

    arith_op                       shift and go to state 117
    bool_op                        shift and go to state 118

state 132

    (40) stmt -> WHILE LPAREN expression . RPAREN stmt
    (70) expression -> expression . arith_op expression
    (71) expression -> expression . bool_op expression
    (77) arith_op -> . PLUS
    (78) arith_op -> . MINUS
    (79) arith_op -> . TIMES
    (80) arith_op -> . DIVIDE
    (81) bool_op -> . GREATER
    (82) bool_op -> . LESS
    (83) bool_op -> . GREATEREQ
    (84) bool_op -> . LESSEQ
    (85) bool_op -> . EQUAL
    (86) bool_op -> . NOTEQUAL
    (87) bool_op -> . AND
    (88) bool_op -> . OR

    RPAREN          shift and go to state 147
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    TIMES           shift and go to state 121
    DIVIDE          shift and go to state 122
    GREATER         shift and go to state 123
    LESS            shift and go to state 124
    GREATEREQ       shift and go to state 125
    LESSEQ          shift and go to state 126
    EQUAL           shift and go to state 127
    NOTEQUAL        shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130

    arith_op                       shift and go to state 117
    bool_op                        shift and go to state 118

state 133

    (41) stmt -> FOR LPAREN stmt_expression . SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt

    SEMICOLON       shift and go to state 148


state 134

    (42) stmt -> RETURN expression SEMICOLON .

    RCURLY          reduce using rule 42 (stmt -> RETURN expression SEMICOLON .)
    IF              reduce using rule 42 (stmt -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 42 (stmt -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 42 (stmt -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 42 (stmt -> RETURN expression SEMICOLON .)
    BREAK           reduce using rule 42 (stmt -> RETURN expression SEMICOLON .)
    CONTINUE        reduce using rule 42 (stmt -> RETURN expression SEMICOLON .)
    SEMICOLON       reduce using rule 42 (stmt -> RETURN expression SEMICOLON .)
    LCURLY          reduce using rule 42 (stmt -> RETURN expression SEMICOLON .)
    INT             reduce using rule 42 (stmt -> RETURN expression SEMICOLON .)
    FLOAT           reduce using rule 42 (stmt -> RETURN expression SEMICOLON .)
    BOOLEAN         reduce using rule 42 (stmt -> RETURN expression SEMICOLON .)
    ID              reduce using rule 42 (stmt -> RETURN expression SEMICOLON .)
    THIS            reduce using rule 42 (stmt -> RETURN expression SEMICOLON .)
    SUPER           reduce using rule 42 (stmt -> RETURN expression SEMICOLON .)
    LPAREN          reduce using rule 42 (stmt -> RETURN expression SEMICOLON .)
    NEW             reduce using rule 42 (stmt -> RETURN expression SEMICOLON .)
    INTEGER         reduce using rule 42 (stmt -> RETURN expression SEMICOLON .)
    STRING          reduce using rule 42 (stmt -> RETURN expression SEMICOLON .)
    NULL            reduce using rule 42 (stmt -> RETURN expression SEMICOLON .)
    FALSE           reduce using rule 42 (stmt -> RETURN expression SEMICOLON .)
    TRUE            reduce using rule 42 (stmt -> RETURN expression SEMICOLON .)
    ELSE            reduce using rule 42 (stmt -> RETURN expression SEMICOLON .)


state 135

    (76) assign -> lhs SETEQUAL expression .
    (70) expression -> expression . arith_op expression
    (71) expression -> expression . bool_op expression
    (77) arith_op -> . PLUS
    (78) arith_op -> . MINUS
    (79) arith_op -> . TIMES
    (80) arith_op -> . DIVIDE
    (81) bool_op -> . GREATER
    (82) bool_op -> . LESS
    (83) bool_op -> . GREATEREQ
    (84) bool_op -> . LESSEQ
    (85) bool_op -> . EQUAL
    (86) bool_op -> . NOTEQUAL
    (87) bool_op -> . AND
    (88) bool_op -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 76 (assign -> lhs SETEQUAL expression .)
    RPAREN          reduce using rule 76 (assign -> lhs SETEQUAL expression .)
    COMMA           reduce using rule 76 (assign -> lhs SETEQUAL expression .)
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    TIMES           shift and go to state 121
    DIVIDE          shift and go to state 122
    GREATER         shift and go to state 123
    LESS            shift and go to state 124
    GREATEREQ       shift and go to state 125
    LESSEQ          shift and go to state 126
    EQUAL           shift and go to state 127
    NOTEQUAL        shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130

  ! PLUS            [ reduce using rule 76 (assign -> lhs SETEQUAL expression .) ]
  ! MINUS           [ reduce using rule 76 (assign -> lhs SETEQUAL expression .) ]
  ! TIMES           [ reduce using rule 76 (assign -> lhs SETEQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 76 (assign -> lhs SETEQUAL expression .) ]
  ! GREATER         [ reduce using rule 76 (assign -> lhs SETEQUAL expression .) ]
  ! LESS            [ reduce using rule 76 (assign -> lhs SETEQUAL expression .) ]
  ! GREATEREQ       [ reduce using rule 76 (assign -> lhs SETEQUAL expression .) ]
  ! LESSEQ          [ reduce using rule 76 (assign -> lhs SETEQUAL expression .) ]
  ! EQUAL           [ reduce using rule 76 (assign -> lhs SETEQUAL expression .) ]
  ! NOTEQUAL        [ reduce using rule 76 (assign -> lhs SETEQUAL expression .) ]
  ! AND             [ reduce using rule 76 (assign -> lhs SETEQUAL expression .) ]
  ! OR              [ reduce using rule 76 (assign -> lhs SETEQUAL expression .) ]

    arith_op                       shift and go to state 117
    bool_op                        shift and go to state 118

state 136

    (66) method_invocation -> field_access LPAREN arguments . RPAREN

    RPAREN          shift and go to state 149


state 137

    (67) method_invocation -> field_access LPAREN RPAREN .

    SEMICOLON       reduce using rule 67 (method_invocation -> field_access LPAREN RPAREN .)
    DOT             reduce using rule 67 (method_invocation -> field_access LPAREN RPAREN .)
    RPAREN          reduce using rule 67 (method_invocation -> field_access LPAREN RPAREN .)
    PLUS            reduce using rule 67 (method_invocation -> field_access LPAREN RPAREN .)
    MINUS           reduce using rule 67 (method_invocation -> field_access LPAREN RPAREN .)
    TIMES           reduce using rule 67 (method_invocation -> field_access LPAREN RPAREN .)
    DIVIDE          reduce using rule 67 (method_invocation -> field_access LPAREN RPAREN .)
    GREATER         reduce using rule 67 (method_invocation -> field_access LPAREN RPAREN .)
    LESS            reduce using rule 67 (method_invocation -> field_access LPAREN RPAREN .)
    GREATEREQ       reduce using rule 67 (method_invocation -> field_access LPAREN RPAREN .)
    LESSEQ          reduce using rule 67 (method_invocation -> field_access LPAREN RPAREN .)
    EQUAL           reduce using rule 67 (method_invocation -> field_access LPAREN RPAREN .)
    NOTEQUAL        reduce using rule 67 (method_invocation -> field_access LPAREN RPAREN .)
    AND             reduce using rule 67 (method_invocation -> field_access LPAREN RPAREN .)
    OR              reduce using rule 67 (method_invocation -> field_access LPAREN RPAREN .)
    COMMA           reduce using rule 67 (method_invocation -> field_access LPAREN RPAREN .)


state 138

    (64) arguments -> expression .
    (65) arguments -> expression . COMMA arguments
    (70) expression -> expression . arith_op expression
    (71) expression -> expression . bool_op expression
    (77) arith_op -> . PLUS
    (78) arith_op -> . MINUS
    (79) arith_op -> . TIMES
    (80) arith_op -> . DIVIDE
    (81) bool_op -> . GREATER
    (82) bool_op -> . LESS
    (83) bool_op -> . GREATEREQ
    (84) bool_op -> . LESSEQ
    (85) bool_op -> . EQUAL
    (86) bool_op -> . NOTEQUAL
    (87) bool_op -> . AND
    (88) bool_op -> . OR

    RPAREN          reduce using rule 64 (arguments -> expression .)
    COMMA           shift and go to state 150
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    TIMES           shift and go to state 121
    DIVIDE          shift and go to state 122
    GREATER         shift and go to state 123
    LESS            shift and go to state 124
    GREATEREQ       shift and go to state 125
    LESSEQ          shift and go to state 126
    EQUAL           shift and go to state 127
    NOTEQUAL        shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130

    arith_op                       shift and go to state 117
    bool_op                        shift and go to state 118

state 139

    (74) field_access -> primary DOT ID .

    LPAREN          reduce using rule 74 (field_access -> primary DOT ID .)
    SETEQUAL        reduce using rule 74 (field_access -> primary DOT ID .)
    DOT             reduce using rule 74 (field_access -> primary DOT ID .)
    RPAREN          reduce using rule 74 (field_access -> primary DOT ID .)
    PLUS            reduce using rule 74 (field_access -> primary DOT ID .)
    MINUS           reduce using rule 74 (field_access -> primary DOT ID .)
    TIMES           reduce using rule 74 (field_access -> primary DOT ID .)
    DIVIDE          reduce using rule 74 (field_access -> primary DOT ID .)
    GREATER         reduce using rule 74 (field_access -> primary DOT ID .)
    LESS            reduce using rule 74 (field_access -> primary DOT ID .)
    GREATEREQ       reduce using rule 74 (field_access -> primary DOT ID .)
    LESSEQ          reduce using rule 74 (field_access -> primary DOT ID .)
    EQUAL           reduce using rule 74 (field_access -> primary DOT ID .)
    NOTEQUAL        reduce using rule 74 (field_access -> primary DOT ID .)
    AND             reduce using rule 74 (field_access -> primary DOT ID .)
    OR              reduce using rule 74 (field_access -> primary DOT ID .)
    SEMICOLON       reduce using rule 74 (field_access -> primary DOT ID .)
    COMMA           reduce using rule 74 (field_access -> primary DOT ID .)


state 140

    (61) primary -> NEW ID LPAREN . arguments RPAREN
    (64) arguments -> . expression
    (65) arguments -> . expression COMMA arguments
    (68) expression -> . primary
    (69) expression -> . assign
    (70) expression -> . expression arith_op expression
    (71) expression -> . expression bool_op expression
    (72) expression -> . unary_op expression
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . LPAREN expression RPAREN
    (60) primary -> . NEW ID
    (61) primary -> . NEW ID LPAREN arguments RPAREN
    (62) primary -> . method_invocation
    (63) primary -> . lhs
    (76) assign -> . lhs SETEQUAL expression
    (89) unary_op -> . PLUS
    (90) unary_op -> . MINUS
    (91) unary_op -> . NOT
    (50) literal -> . INTEGER
    (51) literal -> . FLOAT
    (52) literal -> . STRING
    (53) literal -> . NULL
    (54) literal -> . FALSE
    (55) literal -> . TRUE
    (66) method_invocation -> . field_access LPAREN arguments RPAREN
    (67) method_invocation -> . field_access LPAREN RPAREN
    (73) lhs -> . field_access
    (74) field_access -> . primary DOT ID
    (75) field_access -> . ID

    THIS            shift and go to state 69
    SUPER           shift and go to state 70
    LPAREN          shift and go to state 50
    NEW             shift and go to state 71
    PLUS            shift and go to state 95
    MINUS           shift and go to state 96
    NOT             shift and go to state 97
    INTEGER         shift and go to state 72
    FLOAT           shift and go to state 98
    STRING          shift and go to state 73
    NULL            shift and go to state 74
    FALSE           shift and go to state 75
    TRUE            shift and go to state 76
    ID              shift and go to state 92

    arguments                      shift and go to state 151
    expression                     shift and go to state 138
    primary                        shift and go to state 89
    assign                         shift and go to state 90
    unary_op                       shift and go to state 91
    literal                        shift and go to state 68
    method_invocation              shift and go to state 93
    lhs                            shift and go to state 94
    field_access                   shift and go to state 64

state 141

    (27) method_decl -> modifier VOID ID LPAREN RPAREN block .

    RCURLY          reduce using rule 27 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    PUBLIC          reduce using rule 27 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    PRIVATE         reduce using rule 27 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    VOID            reduce using rule 27 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    ID              reduce using rule 27 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    INT             reduce using rule 27 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    FLOAT           reduce using rule 27 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 27 (method_decl -> modifier VOID ID LPAREN RPAREN block .)


state 142

    (28) method_decl -> modifier VOID ID LPAREN formals RPAREN . block
    (34) block -> . LCURLY stmtlist RCURLY
    (35) block -> . empty
    (94) empty -> .

    LCURLY          shift and go to state 37
    RCURLY          reduce using rule 94 (empty -> .)
    PUBLIC          reduce using rule 94 (empty -> .)
    PRIVATE         reduce using rule 94 (empty -> .)
    VOID            reduce using rule 94 (empty -> .)
    ID              reduce using rule 94 (empty -> .)
    INT             reduce using rule 94 (empty -> .)
    FLOAT           reduce using rule 94 (empty -> .)
    BOOLEAN         reduce using rule 94 (empty -> .)

    block                          shift and go to state 152
    empty                          shift and go to state 38

state 143

    (26) method_decl -> modifier type ID LPAREN formals RPAREN block .

    RCURLY          reduce using rule 26 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    PUBLIC          reduce using rule 26 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 26 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    VOID            reduce using rule 26 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    ID              reduce using rule 26 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    INT             reduce using rule 26 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 26 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 26 (method_decl -> modifier type ID LPAREN formals RPAREN block .)


state 144

    (38) stmt -> IF LPAREN expression RPAREN . stmt
    (39) stmt -> IF LPAREN expression RPAREN . stmt ELSE stmt
    (38) stmt -> . IF LPAREN expression RPAREN stmt
    (39) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (40) stmt -> . WHILE LPAREN expression RPAREN stmt
    (41) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (42) stmt -> . RETURN expression SEMICOLON
    (43) stmt -> . RETURN SEMICOLON
    (44) stmt -> . stmt_expression SEMICOLON
    (45) stmt -> . BREAK SEMICOLON
    (46) stmt -> . CONTINUE SEMICOLON
    (47) stmt -> . block
    (48) stmt -> . var_decl
    (49) stmt -> . SEMICOLON
    (92) stmt_expression -> . assign
    (93) stmt_expression -> . method_invocation
    (34) block -> . LCURLY stmtlist RCURLY
    (35) block -> . empty
    (17) var_decl -> . type variables SEMICOLON
    (76) assign -> . lhs SETEQUAL expression
    (66) method_invocation -> . field_access LPAREN arguments RPAREN
    (67) method_invocation -> . field_access LPAREN RPAREN
    (94) empty -> .
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (73) lhs -> . field_access
    (74) field_access -> . primary DOT ID
    (75) field_access -> . ID
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . LPAREN expression RPAREN
    (60) primary -> . NEW ID
    (61) primary -> . NEW ID LPAREN arguments RPAREN
    (62) primary -> . method_invocation
    (63) primary -> . lhs
    (50) literal -> . INTEGER
    (51) literal -> . FLOAT
    (52) literal -> . STRING
    (53) literal -> . NULL
    (54) literal -> . FALSE
    (55) literal -> . TRUE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    IF              shift and go to state 49
    WHILE           shift and go to state 51
    FOR             shift and go to state 52
    RETURN          shift and go to state 55
    BREAK           shift and go to state 56
    CONTINUE        shift and go to state 57
    SEMICOLON       shift and go to state 54
    LCURLY          shift and go to state 37
    ELSE            reduce using rule 94 (empty -> .)
    RCURLY          reduce using rule 94 (empty -> .)
    INT             shift and go to state 25
    FLOAT           shift and go to state 65
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 66
    THIS            shift and go to state 69
    SUPER           shift and go to state 70
    LPAREN          shift and go to state 50
    NEW             shift and go to state 71
    INTEGER         shift and go to state 72
    STRING          shift and go to state 73
    NULL            shift and go to state 74
    FALSE           shift and go to state 75
    TRUE            shift and go to state 76

  ! IF              [ reduce using rule 94 (empty -> .) ]
  ! WHILE           [ reduce using rule 94 (empty -> .) ]
  ! FOR             [ reduce using rule 94 (empty -> .) ]
  ! RETURN          [ reduce using rule 94 (empty -> .) ]
  ! BREAK           [ reduce using rule 94 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 94 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 94 (empty -> .) ]
  ! LCURLY          [ reduce using rule 94 (empty -> .) ]
  ! INT             [ reduce using rule 94 (empty -> .) ]
  ! FLOAT           [ reduce using rule 94 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 94 (empty -> .) ]
  ! ID              [ reduce using rule 94 (empty -> .) ]
  ! THIS            [ reduce using rule 94 (empty -> .) ]
  ! SUPER           [ reduce using rule 94 (empty -> .) ]
  ! LPAREN          [ reduce using rule 94 (empty -> .) ]
  ! NEW             [ reduce using rule 94 (empty -> .) ]
  ! INTEGER         [ reduce using rule 94 (empty -> .) ]
  ! STRING          [ reduce using rule 94 (empty -> .) ]
  ! NULL            [ reduce using rule 94 (empty -> .) ]
  ! FALSE           [ reduce using rule 94 (empty -> .) ]
  ! TRUE            [ reduce using rule 94 (empty -> .) ]

    stmt                           shift and go to state 153
    stmt_expression                shift and go to state 53
    block                          shift and go to state 58
    var_decl                       shift and go to state 59
    assign                         shift and go to state 60
    method_invocation              shift and go to state 61
    empty                          shift and go to state 38
    type                           shift and go to state 62
    lhs                            shift and go to state 63
    field_access                   shift and go to state 64
    primary                        shift and go to state 67
    literal                        shift and go to state 68

state 145

    (70) expression -> expression arith_op expression .
    (70) expression -> expression . arith_op expression
    (71) expression -> expression . bool_op expression
    (77) arith_op -> . PLUS
    (78) arith_op -> . MINUS
    (79) arith_op -> . TIMES
    (80) arith_op -> . DIVIDE
    (81) bool_op -> . GREATER
    (82) bool_op -> . LESS
    (83) bool_op -> . GREATEREQ
    (84) bool_op -> . LESSEQ
    (85) bool_op -> . EQUAL
    (86) bool_op -> . NOTEQUAL
    (87) bool_op -> . AND
    (88) bool_op -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 70 (expression -> expression arith_op expression .)
    SEMICOLON       reduce using rule 70 (expression -> expression arith_op expression .)
    COMMA           reduce using rule 70 (expression -> expression arith_op expression .)
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    TIMES           shift and go to state 121
    DIVIDE          shift and go to state 122
    GREATER         shift and go to state 123
    LESS            shift and go to state 124
    GREATEREQ       shift and go to state 125
    LESSEQ          shift and go to state 126
    EQUAL           shift and go to state 127
    NOTEQUAL        shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130

  ! PLUS            [ reduce using rule 70 (expression -> expression arith_op expression .) ]
  ! MINUS           [ reduce using rule 70 (expression -> expression arith_op expression .) ]
  ! TIMES           [ reduce using rule 70 (expression -> expression arith_op expression .) ]
  ! DIVIDE          [ reduce using rule 70 (expression -> expression arith_op expression .) ]
  ! GREATER         [ reduce using rule 70 (expression -> expression arith_op expression .) ]
  ! LESS            [ reduce using rule 70 (expression -> expression arith_op expression .) ]
  ! GREATEREQ       [ reduce using rule 70 (expression -> expression arith_op expression .) ]
  ! LESSEQ          [ reduce using rule 70 (expression -> expression arith_op expression .) ]
  ! EQUAL           [ reduce using rule 70 (expression -> expression arith_op expression .) ]
  ! NOTEQUAL        [ reduce using rule 70 (expression -> expression arith_op expression .) ]
  ! AND             [ reduce using rule 70 (expression -> expression arith_op expression .) ]
  ! OR              [ reduce using rule 70 (expression -> expression arith_op expression .) ]

    arith_op                       shift and go to state 117
    bool_op                        shift and go to state 118

state 146

    (71) expression -> expression bool_op expression .
    (70) expression -> expression . arith_op expression
    (71) expression -> expression . bool_op expression
    (77) arith_op -> . PLUS
    (78) arith_op -> . MINUS
    (79) arith_op -> . TIMES
    (80) arith_op -> . DIVIDE
    (81) bool_op -> . GREATER
    (82) bool_op -> . LESS
    (83) bool_op -> . GREATEREQ
    (84) bool_op -> . LESSEQ
    (85) bool_op -> . EQUAL
    (86) bool_op -> . NOTEQUAL
    (87) bool_op -> . AND
    (88) bool_op -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 71 (expression -> expression bool_op expression .)
    SEMICOLON       reduce using rule 71 (expression -> expression bool_op expression .)
    COMMA           reduce using rule 71 (expression -> expression bool_op expression .)
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    TIMES           shift and go to state 121
    DIVIDE          shift and go to state 122
    GREATER         shift and go to state 123
    LESS            shift and go to state 124
    GREATEREQ       shift and go to state 125
    LESSEQ          shift and go to state 126
    EQUAL           shift and go to state 127
    NOTEQUAL        shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130

  ! PLUS            [ reduce using rule 71 (expression -> expression bool_op expression .) ]
  ! MINUS           [ reduce using rule 71 (expression -> expression bool_op expression .) ]
  ! TIMES           [ reduce using rule 71 (expression -> expression bool_op expression .) ]
  ! DIVIDE          [ reduce using rule 71 (expression -> expression bool_op expression .) ]
  ! GREATER         [ reduce using rule 71 (expression -> expression bool_op expression .) ]
  ! LESS            [ reduce using rule 71 (expression -> expression bool_op expression .) ]
  ! GREATEREQ       [ reduce using rule 71 (expression -> expression bool_op expression .) ]
  ! LESSEQ          [ reduce using rule 71 (expression -> expression bool_op expression .) ]
  ! EQUAL           [ reduce using rule 71 (expression -> expression bool_op expression .) ]
  ! NOTEQUAL        [ reduce using rule 71 (expression -> expression bool_op expression .) ]
  ! AND             [ reduce using rule 71 (expression -> expression bool_op expression .) ]
  ! OR              [ reduce using rule 71 (expression -> expression bool_op expression .) ]

    bool_op                        shift and go to state 118
    arith_op                       shift and go to state 117

state 147

    (40) stmt -> WHILE LPAREN expression RPAREN . stmt
    (38) stmt -> . IF LPAREN expression RPAREN stmt
    (39) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (40) stmt -> . WHILE LPAREN expression RPAREN stmt
    (41) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (42) stmt -> . RETURN expression SEMICOLON
    (43) stmt -> . RETURN SEMICOLON
    (44) stmt -> . stmt_expression SEMICOLON
    (45) stmt -> . BREAK SEMICOLON
    (46) stmt -> . CONTINUE SEMICOLON
    (47) stmt -> . block
    (48) stmt -> . var_decl
    (49) stmt -> . SEMICOLON
    (92) stmt_expression -> . assign
    (93) stmt_expression -> . method_invocation
    (34) block -> . LCURLY stmtlist RCURLY
    (35) block -> . empty
    (17) var_decl -> . type variables SEMICOLON
    (76) assign -> . lhs SETEQUAL expression
    (66) method_invocation -> . field_access LPAREN arguments RPAREN
    (67) method_invocation -> . field_access LPAREN RPAREN
    (94) empty -> .
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (73) lhs -> . field_access
    (74) field_access -> . primary DOT ID
    (75) field_access -> . ID
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . LPAREN expression RPAREN
    (60) primary -> . NEW ID
    (61) primary -> . NEW ID LPAREN arguments RPAREN
    (62) primary -> . method_invocation
    (63) primary -> . lhs
    (50) literal -> . INTEGER
    (51) literal -> . FLOAT
    (52) literal -> . STRING
    (53) literal -> . NULL
    (54) literal -> . FALSE
    (55) literal -> . TRUE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    IF              shift and go to state 49
    WHILE           shift and go to state 51
    FOR             shift and go to state 52
    RETURN          shift and go to state 55
    BREAK           shift and go to state 56
    CONTINUE        shift and go to state 57
    SEMICOLON       shift and go to state 54
    LCURLY          shift and go to state 37
    ELSE            reduce using rule 94 (empty -> .)
    RCURLY          reduce using rule 94 (empty -> .)
    INT             shift and go to state 25
    FLOAT           shift and go to state 65
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 66
    THIS            shift and go to state 69
    SUPER           shift and go to state 70
    LPAREN          shift and go to state 50
    NEW             shift and go to state 71
    INTEGER         shift and go to state 72
    STRING          shift and go to state 73
    NULL            shift and go to state 74
    FALSE           shift and go to state 75
    TRUE            shift and go to state 76

  ! IF              [ reduce using rule 94 (empty -> .) ]
  ! WHILE           [ reduce using rule 94 (empty -> .) ]
  ! FOR             [ reduce using rule 94 (empty -> .) ]
  ! RETURN          [ reduce using rule 94 (empty -> .) ]
  ! BREAK           [ reduce using rule 94 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 94 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 94 (empty -> .) ]
  ! LCURLY          [ reduce using rule 94 (empty -> .) ]
  ! INT             [ reduce using rule 94 (empty -> .) ]
  ! FLOAT           [ reduce using rule 94 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 94 (empty -> .) ]
  ! ID              [ reduce using rule 94 (empty -> .) ]
  ! THIS            [ reduce using rule 94 (empty -> .) ]
  ! SUPER           [ reduce using rule 94 (empty -> .) ]
  ! LPAREN          [ reduce using rule 94 (empty -> .) ]
  ! NEW             [ reduce using rule 94 (empty -> .) ]
  ! INTEGER         [ reduce using rule 94 (empty -> .) ]
  ! STRING          [ reduce using rule 94 (empty -> .) ]
  ! NULL            [ reduce using rule 94 (empty -> .) ]
  ! FALSE           [ reduce using rule 94 (empty -> .) ]
  ! TRUE            [ reduce using rule 94 (empty -> .) ]

    stmt                           shift and go to state 154
    stmt_expression                shift and go to state 53
    block                          shift and go to state 58
    var_decl                       shift and go to state 59
    assign                         shift and go to state 60
    method_invocation              shift and go to state 61
    empty                          shift and go to state 38
    type                           shift and go to state 62
    lhs                            shift and go to state 63
    field_access                   shift and go to state 64
    primary                        shift and go to state 67
    literal                        shift and go to state 68

state 148

    (41) stmt -> FOR LPAREN stmt_expression SEMICOLON . expression SEMICOLON stmt_expression RPAREN stmt
    (68) expression -> . primary
    (69) expression -> . assign
    (70) expression -> . expression arith_op expression
    (71) expression -> . expression bool_op expression
    (72) expression -> . unary_op expression
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . LPAREN expression RPAREN
    (60) primary -> . NEW ID
    (61) primary -> . NEW ID LPAREN arguments RPAREN
    (62) primary -> . method_invocation
    (63) primary -> . lhs
    (76) assign -> . lhs SETEQUAL expression
    (89) unary_op -> . PLUS
    (90) unary_op -> . MINUS
    (91) unary_op -> . NOT
    (50) literal -> . INTEGER
    (51) literal -> . FLOAT
    (52) literal -> . STRING
    (53) literal -> . NULL
    (54) literal -> . FALSE
    (55) literal -> . TRUE
    (66) method_invocation -> . field_access LPAREN arguments RPAREN
    (67) method_invocation -> . field_access LPAREN RPAREN
    (73) lhs -> . field_access
    (74) field_access -> . primary DOT ID
    (75) field_access -> . ID

    THIS            shift and go to state 69
    SUPER           shift and go to state 70
    LPAREN          shift and go to state 50
    NEW             shift and go to state 71
    PLUS            shift and go to state 95
    MINUS           shift and go to state 96
    NOT             shift and go to state 97
    INTEGER         shift and go to state 72
    FLOAT           shift and go to state 98
    STRING          shift and go to state 73
    NULL            shift and go to state 74
    FALSE           shift and go to state 75
    TRUE            shift and go to state 76
    ID              shift and go to state 92

    expression                     shift and go to state 155
    primary                        shift and go to state 89
    assign                         shift and go to state 90
    unary_op                       shift and go to state 91
    literal                        shift and go to state 68
    method_invocation              shift and go to state 93
    lhs                            shift and go to state 94
    field_access                   shift and go to state 64

state 149

    (66) method_invocation -> field_access LPAREN arguments RPAREN .

    SEMICOLON       reduce using rule 66 (method_invocation -> field_access LPAREN arguments RPAREN .)
    DOT             reduce using rule 66 (method_invocation -> field_access LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 66 (method_invocation -> field_access LPAREN arguments RPAREN .)
    PLUS            reduce using rule 66 (method_invocation -> field_access LPAREN arguments RPAREN .)
    MINUS           reduce using rule 66 (method_invocation -> field_access LPAREN arguments RPAREN .)
    TIMES           reduce using rule 66 (method_invocation -> field_access LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 66 (method_invocation -> field_access LPAREN arguments RPAREN .)
    GREATER         reduce using rule 66 (method_invocation -> field_access LPAREN arguments RPAREN .)
    LESS            reduce using rule 66 (method_invocation -> field_access LPAREN arguments RPAREN .)
    GREATEREQ       reduce using rule 66 (method_invocation -> field_access LPAREN arguments RPAREN .)
    LESSEQ          reduce using rule 66 (method_invocation -> field_access LPAREN arguments RPAREN .)
    EQUAL           reduce using rule 66 (method_invocation -> field_access LPAREN arguments RPAREN .)
    NOTEQUAL        reduce using rule 66 (method_invocation -> field_access LPAREN arguments RPAREN .)
    AND             reduce using rule 66 (method_invocation -> field_access LPAREN arguments RPAREN .)
    OR              reduce using rule 66 (method_invocation -> field_access LPAREN arguments RPAREN .)
    COMMA           reduce using rule 66 (method_invocation -> field_access LPAREN arguments RPAREN .)


state 150

    (65) arguments -> expression COMMA . arguments
    (64) arguments -> . expression
    (65) arguments -> . expression COMMA arguments
    (68) expression -> . primary
    (69) expression -> . assign
    (70) expression -> . expression arith_op expression
    (71) expression -> . expression bool_op expression
    (72) expression -> . unary_op expression
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . LPAREN expression RPAREN
    (60) primary -> . NEW ID
    (61) primary -> . NEW ID LPAREN arguments RPAREN
    (62) primary -> . method_invocation
    (63) primary -> . lhs
    (76) assign -> . lhs SETEQUAL expression
    (89) unary_op -> . PLUS
    (90) unary_op -> . MINUS
    (91) unary_op -> . NOT
    (50) literal -> . INTEGER
    (51) literal -> . FLOAT
    (52) literal -> . STRING
    (53) literal -> . NULL
    (54) literal -> . FALSE
    (55) literal -> . TRUE
    (66) method_invocation -> . field_access LPAREN arguments RPAREN
    (67) method_invocation -> . field_access LPAREN RPAREN
    (73) lhs -> . field_access
    (74) field_access -> . primary DOT ID
    (75) field_access -> . ID

    THIS            shift and go to state 69
    SUPER           shift and go to state 70
    LPAREN          shift and go to state 50
    NEW             shift and go to state 71
    PLUS            shift and go to state 95
    MINUS           shift and go to state 96
    NOT             shift and go to state 97
    INTEGER         shift and go to state 72
    FLOAT           shift and go to state 98
    STRING          shift and go to state 73
    NULL            shift and go to state 74
    FALSE           shift and go to state 75
    TRUE            shift and go to state 76
    ID              shift and go to state 92

    expression                     shift and go to state 138
    arguments                      shift and go to state 156
    primary                        shift and go to state 89
    assign                         shift and go to state 90
    unary_op                       shift and go to state 91
    literal                        shift and go to state 68
    method_invocation              shift and go to state 93
    lhs                            shift and go to state 94
    field_access                   shift and go to state 64

state 151

    (61) primary -> NEW ID LPAREN arguments . RPAREN

    RPAREN          shift and go to state 157


state 152

    (28) method_decl -> modifier VOID ID LPAREN formals RPAREN block .

    RCURLY          reduce using rule 28 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    PUBLIC          reduce using rule 28 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 28 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    VOID            reduce using rule 28 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    ID              reduce using rule 28 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    INT             reduce using rule 28 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 28 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 28 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)


state 153

    (38) stmt -> IF LPAREN expression RPAREN stmt .
    (39) stmt -> IF LPAREN expression RPAREN stmt . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    RCURLY          reduce using rule 38 (stmt -> IF LPAREN expression RPAREN stmt .)
    IF              reduce using rule 38 (stmt -> IF LPAREN expression RPAREN stmt .)
    WHILE           reduce using rule 38 (stmt -> IF LPAREN expression RPAREN stmt .)
    FOR             reduce using rule 38 (stmt -> IF LPAREN expression RPAREN stmt .)
    RETURN          reduce using rule 38 (stmt -> IF LPAREN expression RPAREN stmt .)
    BREAK           reduce using rule 38 (stmt -> IF LPAREN expression RPAREN stmt .)
    CONTINUE        reduce using rule 38 (stmt -> IF LPAREN expression RPAREN stmt .)
    SEMICOLON       reduce using rule 38 (stmt -> IF LPAREN expression RPAREN stmt .)
    LCURLY          reduce using rule 38 (stmt -> IF LPAREN expression RPAREN stmt .)
    INT             reduce using rule 38 (stmt -> IF LPAREN expression RPAREN stmt .)
    FLOAT           reduce using rule 38 (stmt -> IF LPAREN expression RPAREN stmt .)
    BOOLEAN         reduce using rule 38 (stmt -> IF LPAREN expression RPAREN stmt .)
    ID              reduce using rule 38 (stmt -> IF LPAREN expression RPAREN stmt .)
    THIS            reduce using rule 38 (stmt -> IF LPAREN expression RPAREN stmt .)
    SUPER           reduce using rule 38 (stmt -> IF LPAREN expression RPAREN stmt .)
    LPAREN          reduce using rule 38 (stmt -> IF LPAREN expression RPAREN stmt .)
    NEW             reduce using rule 38 (stmt -> IF LPAREN expression RPAREN stmt .)
    INTEGER         reduce using rule 38 (stmt -> IF LPAREN expression RPAREN stmt .)
    STRING          reduce using rule 38 (stmt -> IF LPAREN expression RPAREN stmt .)
    NULL            reduce using rule 38 (stmt -> IF LPAREN expression RPAREN stmt .)
    FALSE           reduce using rule 38 (stmt -> IF LPAREN expression RPAREN stmt .)
    TRUE            reduce using rule 38 (stmt -> IF LPAREN expression RPAREN stmt .)
    ELSE            shift and go to state 158

  ! ELSE            [ reduce using rule 38 (stmt -> IF LPAREN expression RPAREN stmt .) ]


state 154

    (40) stmt -> WHILE LPAREN expression RPAREN stmt .

    RCURLY          reduce using rule 40 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    IF              reduce using rule 40 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    WHILE           reduce using rule 40 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    FOR             reduce using rule 40 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    RETURN          reduce using rule 40 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    BREAK           reduce using rule 40 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    CONTINUE        reduce using rule 40 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    SEMICOLON       reduce using rule 40 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    LCURLY          reduce using rule 40 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    INT             reduce using rule 40 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    FLOAT           reduce using rule 40 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    BOOLEAN         reduce using rule 40 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    ID              reduce using rule 40 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    THIS            reduce using rule 40 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    SUPER           reduce using rule 40 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    LPAREN          reduce using rule 40 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    NEW             reduce using rule 40 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    INTEGER         reduce using rule 40 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    STRING          reduce using rule 40 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    NULL            reduce using rule 40 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    FALSE           reduce using rule 40 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    TRUE            reduce using rule 40 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    ELSE            reduce using rule 40 (stmt -> WHILE LPAREN expression RPAREN stmt .)


state 155

    (41) stmt -> FOR LPAREN stmt_expression SEMICOLON expression . SEMICOLON stmt_expression RPAREN stmt
    (70) expression -> expression . arith_op expression
    (71) expression -> expression . bool_op expression
    (77) arith_op -> . PLUS
    (78) arith_op -> . MINUS
    (79) arith_op -> . TIMES
    (80) arith_op -> . DIVIDE
    (81) bool_op -> . GREATER
    (82) bool_op -> . LESS
    (83) bool_op -> . GREATEREQ
    (84) bool_op -> . LESSEQ
    (85) bool_op -> . EQUAL
    (86) bool_op -> . NOTEQUAL
    (87) bool_op -> . AND
    (88) bool_op -> . OR

    SEMICOLON       shift and go to state 159
    PLUS            shift and go to state 119
    MINUS           shift and go to state 120
    TIMES           shift and go to state 121
    DIVIDE          shift and go to state 122
    GREATER         shift and go to state 123
    LESS            shift and go to state 124
    GREATEREQ       shift and go to state 125
    LESSEQ          shift and go to state 126
    EQUAL           shift and go to state 127
    NOTEQUAL        shift and go to state 128
    AND             shift and go to state 129
    OR              shift and go to state 130

    arith_op                       shift and go to state 117
    bool_op                        shift and go to state 118

state 156

    (65) arguments -> expression COMMA arguments .

    RPAREN          reduce using rule 65 (arguments -> expression COMMA arguments .)


state 157

    (61) primary -> NEW ID LPAREN arguments RPAREN .

    DOT             reduce using rule 61 (primary -> NEW ID LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 61 (primary -> NEW ID LPAREN arguments RPAREN .)
    PLUS            reduce using rule 61 (primary -> NEW ID LPAREN arguments RPAREN .)
    MINUS           reduce using rule 61 (primary -> NEW ID LPAREN arguments RPAREN .)
    TIMES           reduce using rule 61 (primary -> NEW ID LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 61 (primary -> NEW ID LPAREN arguments RPAREN .)
    GREATER         reduce using rule 61 (primary -> NEW ID LPAREN arguments RPAREN .)
    LESS            reduce using rule 61 (primary -> NEW ID LPAREN arguments RPAREN .)
    GREATEREQ       reduce using rule 61 (primary -> NEW ID LPAREN arguments RPAREN .)
    LESSEQ          reduce using rule 61 (primary -> NEW ID LPAREN arguments RPAREN .)
    EQUAL           reduce using rule 61 (primary -> NEW ID LPAREN arguments RPAREN .)
    NOTEQUAL        reduce using rule 61 (primary -> NEW ID LPAREN arguments RPAREN .)
    AND             reduce using rule 61 (primary -> NEW ID LPAREN arguments RPAREN .)
    OR              reduce using rule 61 (primary -> NEW ID LPAREN arguments RPAREN .)
    SEMICOLON       reduce using rule 61 (primary -> NEW ID LPAREN arguments RPAREN .)
    COMMA           reduce using rule 61 (primary -> NEW ID LPAREN arguments RPAREN .)


state 158

    (39) stmt -> IF LPAREN expression RPAREN stmt ELSE . stmt
    (38) stmt -> . IF LPAREN expression RPAREN stmt
    (39) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (40) stmt -> . WHILE LPAREN expression RPAREN stmt
    (41) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (42) stmt -> . RETURN expression SEMICOLON
    (43) stmt -> . RETURN SEMICOLON
    (44) stmt -> . stmt_expression SEMICOLON
    (45) stmt -> . BREAK SEMICOLON
    (46) stmt -> . CONTINUE SEMICOLON
    (47) stmt -> . block
    (48) stmt -> . var_decl
    (49) stmt -> . SEMICOLON
    (92) stmt_expression -> . assign
    (93) stmt_expression -> . method_invocation
    (34) block -> . LCURLY stmtlist RCURLY
    (35) block -> . empty
    (17) var_decl -> . type variables SEMICOLON
    (76) assign -> . lhs SETEQUAL expression
    (66) method_invocation -> . field_access LPAREN arguments RPAREN
    (67) method_invocation -> . field_access LPAREN RPAREN
    (94) empty -> .
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (73) lhs -> . field_access
    (74) field_access -> . primary DOT ID
    (75) field_access -> . ID
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . LPAREN expression RPAREN
    (60) primary -> . NEW ID
    (61) primary -> . NEW ID LPAREN arguments RPAREN
    (62) primary -> . method_invocation
    (63) primary -> . lhs
    (50) literal -> . INTEGER
    (51) literal -> . FLOAT
    (52) literal -> . STRING
    (53) literal -> . NULL
    (54) literal -> . FALSE
    (55) literal -> . TRUE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    IF              shift and go to state 49
    WHILE           shift and go to state 51
    FOR             shift and go to state 52
    RETURN          shift and go to state 55
    BREAK           shift and go to state 56
    CONTINUE        shift and go to state 57
    SEMICOLON       shift and go to state 54
    LCURLY          shift and go to state 37
    ELSE            reduce using rule 94 (empty -> .)
    RCURLY          reduce using rule 94 (empty -> .)
    INT             shift and go to state 25
    FLOAT           shift and go to state 65
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 66
    THIS            shift and go to state 69
    SUPER           shift and go to state 70
    LPAREN          shift and go to state 50
    NEW             shift and go to state 71
    INTEGER         shift and go to state 72
    STRING          shift and go to state 73
    NULL            shift and go to state 74
    FALSE           shift and go to state 75
    TRUE            shift and go to state 76

  ! IF              [ reduce using rule 94 (empty -> .) ]
  ! WHILE           [ reduce using rule 94 (empty -> .) ]
  ! FOR             [ reduce using rule 94 (empty -> .) ]
  ! RETURN          [ reduce using rule 94 (empty -> .) ]
  ! BREAK           [ reduce using rule 94 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 94 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 94 (empty -> .) ]
  ! LCURLY          [ reduce using rule 94 (empty -> .) ]
  ! INT             [ reduce using rule 94 (empty -> .) ]
  ! FLOAT           [ reduce using rule 94 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 94 (empty -> .) ]
  ! ID              [ reduce using rule 94 (empty -> .) ]
  ! THIS            [ reduce using rule 94 (empty -> .) ]
  ! SUPER           [ reduce using rule 94 (empty -> .) ]
  ! LPAREN          [ reduce using rule 94 (empty -> .) ]
  ! NEW             [ reduce using rule 94 (empty -> .) ]
  ! INTEGER         [ reduce using rule 94 (empty -> .) ]
  ! STRING          [ reduce using rule 94 (empty -> .) ]
  ! NULL            [ reduce using rule 94 (empty -> .) ]
  ! FALSE           [ reduce using rule 94 (empty -> .) ]
  ! TRUE            [ reduce using rule 94 (empty -> .) ]

    stmt                           shift and go to state 160
    stmt_expression                shift and go to state 53
    block                          shift and go to state 58
    var_decl                       shift and go to state 59
    assign                         shift and go to state 60
    method_invocation              shift and go to state 61
    empty                          shift and go to state 38
    type                           shift and go to state 62
    lhs                            shift and go to state 63
    field_access                   shift and go to state 64
    primary                        shift and go to state 67
    literal                        shift and go to state 68

state 159

    (41) stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON . stmt_expression RPAREN stmt
    (92) stmt_expression -> . assign
    (93) stmt_expression -> . method_invocation
    (76) assign -> . lhs SETEQUAL expression
    (66) method_invocation -> . field_access LPAREN arguments RPAREN
    (67) method_invocation -> . field_access LPAREN RPAREN
    (73) lhs -> . field_access
    (74) field_access -> . primary DOT ID
    (75) field_access -> . ID
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . LPAREN expression RPAREN
    (60) primary -> . NEW ID
    (61) primary -> . NEW ID LPAREN arguments RPAREN
    (62) primary -> . method_invocation
    (63) primary -> . lhs
    (50) literal -> . INTEGER
    (51) literal -> . FLOAT
    (52) literal -> . STRING
    (53) literal -> . NULL
    (54) literal -> . FALSE
    (55) literal -> . TRUE

    ID              shift and go to state 92
    THIS            shift and go to state 69
    SUPER           shift and go to state 70
    LPAREN          shift and go to state 50
    NEW             shift and go to state 71
    INTEGER         shift and go to state 72
    FLOAT           shift and go to state 98
    STRING          shift and go to state 73
    NULL            shift and go to state 74
    FALSE           shift and go to state 75
    TRUE            shift and go to state 76

    stmt_expression                shift and go to state 161
    assign                         shift and go to state 60
    method_invocation              shift and go to state 61
    lhs                            shift and go to state 63
    field_access                   shift and go to state 64
    primary                        shift and go to state 67
    literal                        shift and go to state 68

state 160

    (39) stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .

    RCURLY          reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    IF              reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    WHILE           reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    FOR             reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    RETURN          reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    BREAK           reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    CONTINUE        reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    SEMICOLON       reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    LCURLY          reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    INT             reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    FLOAT           reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    BOOLEAN         reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    ID              reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    THIS            reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    SUPER           reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    LPAREN          reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    NEW             reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    INTEGER         reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    STRING          reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    NULL            reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    FALSE           reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    TRUE            reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    ELSE            reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)


state 161

    (41) stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression . RPAREN stmt

    RPAREN          shift and go to state 162


state 162

    (41) stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN . stmt
    (38) stmt -> . IF LPAREN expression RPAREN stmt
    (39) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (40) stmt -> . WHILE LPAREN expression RPAREN stmt
    (41) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (42) stmt -> . RETURN expression SEMICOLON
    (43) stmt -> . RETURN SEMICOLON
    (44) stmt -> . stmt_expression SEMICOLON
    (45) stmt -> . BREAK SEMICOLON
    (46) stmt -> . CONTINUE SEMICOLON
    (47) stmt -> . block
    (48) stmt -> . var_decl
    (49) stmt -> . SEMICOLON
    (92) stmt_expression -> . assign
    (93) stmt_expression -> . method_invocation
    (34) block -> . LCURLY stmtlist RCURLY
    (35) block -> . empty
    (17) var_decl -> . type variables SEMICOLON
    (76) assign -> . lhs SETEQUAL expression
    (66) method_invocation -> . field_access LPAREN arguments RPAREN
    (67) method_invocation -> . field_access LPAREN RPAREN
    (94) empty -> .
    (18) type -> . INT
    (19) type -> . FLOAT
    (20) type -> . BOOLEAN
    (21) type -> . ID
    (73) lhs -> . field_access
    (74) field_access -> . primary DOT ID
    (75) field_access -> . ID
    (56) primary -> . literal
    (57) primary -> . THIS
    (58) primary -> . SUPER
    (59) primary -> . LPAREN expression RPAREN
    (60) primary -> . NEW ID
    (61) primary -> . NEW ID LPAREN arguments RPAREN
    (62) primary -> . method_invocation
    (63) primary -> . lhs
    (50) literal -> . INTEGER
    (51) literal -> . FLOAT
    (52) literal -> . STRING
    (53) literal -> . NULL
    (54) literal -> . FALSE
    (55) literal -> . TRUE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    IF              shift and go to state 49
    WHILE           shift and go to state 51
    FOR             shift and go to state 52
    RETURN          shift and go to state 55
    BREAK           shift and go to state 56
    CONTINUE        shift and go to state 57
    SEMICOLON       shift and go to state 54
    LCURLY          shift and go to state 37
    ELSE            reduce using rule 94 (empty -> .)
    RCURLY          reduce using rule 94 (empty -> .)
    INT             shift and go to state 25
    FLOAT           shift and go to state 65
    BOOLEAN         shift and go to state 27
    ID              shift and go to state 66
    THIS            shift and go to state 69
    SUPER           shift and go to state 70
    LPAREN          shift and go to state 50
    NEW             shift and go to state 71
    INTEGER         shift and go to state 72
    STRING          shift and go to state 73
    NULL            shift and go to state 74
    FALSE           shift and go to state 75
    TRUE            shift and go to state 76

  ! IF              [ reduce using rule 94 (empty -> .) ]
  ! WHILE           [ reduce using rule 94 (empty -> .) ]
  ! FOR             [ reduce using rule 94 (empty -> .) ]
  ! RETURN          [ reduce using rule 94 (empty -> .) ]
  ! BREAK           [ reduce using rule 94 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 94 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 94 (empty -> .) ]
  ! LCURLY          [ reduce using rule 94 (empty -> .) ]
  ! INT             [ reduce using rule 94 (empty -> .) ]
  ! FLOAT           [ reduce using rule 94 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 94 (empty -> .) ]
  ! ID              [ reduce using rule 94 (empty -> .) ]
  ! THIS            [ reduce using rule 94 (empty -> .) ]
  ! SUPER           [ reduce using rule 94 (empty -> .) ]
  ! LPAREN          [ reduce using rule 94 (empty -> .) ]
  ! NEW             [ reduce using rule 94 (empty -> .) ]
  ! INTEGER         [ reduce using rule 94 (empty -> .) ]
  ! STRING          [ reduce using rule 94 (empty -> .) ]
  ! NULL            [ reduce using rule 94 (empty -> .) ]
  ! FALSE           [ reduce using rule 94 (empty -> .) ]
  ! TRUE            [ reduce using rule 94 (empty -> .) ]

    stmt_expression                shift and go to state 53
    stmt                           shift and go to state 163
    block                          shift and go to state 58
    var_decl                       shift and go to state 59
    assign                         shift and go to state 60
    method_invocation              shift and go to state 61
    empty                          shift and go to state 38
    type                           shift and go to state 62
    lhs                            shift and go to state 63
    field_access                   shift and go to state 64
    primary                        shift and go to state 67
    literal                        shift and go to state 68

state 163

    (41) stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .

    RCURLY          reduce using rule 41 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    IF              reduce using rule 41 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    WHILE           reduce using rule 41 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    FOR             reduce using rule 41 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    RETURN          reduce using rule 41 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    BREAK           reduce using rule 41 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    CONTINUE        reduce using rule 41 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    SEMICOLON       reduce using rule 41 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    LCURLY          reduce using rule 41 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    INT             reduce using rule 41 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    FLOAT           reduce using rule 41 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    BOOLEAN         reduce using rule 41 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    ID              reduce using rule 41 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    THIS            reduce using rule 41 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    SUPER           reduce using rule 41 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    LPAREN          reduce using rule 41 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    NEW             reduce using rule 41 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    INTEGER         reduce using rule 41 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    STRING          reduce using rule 41 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    NULL            reduce using rule 41 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    FALSE           reduce using rule 41 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    TRUE            reduce using rule 41 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    ELSE            reduce using rule 41 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PUBLIC in state 5 resolved as shift
WARNING: shift/reduce conflict for PRIVATE in state 5 resolved as shift
WARNING: shift/reduce conflict for INT in state 23 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 23 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 23 resolved as shift
WARNING: shift/reduce conflict for ID in state 23 resolved as shift
WARNING: shift/reduce conflict for PUBLIC in state 30 resolved as shift
WARNING: shift/reduce conflict for PRIVATE in state 30 resolved as shift
WARNING: shift/reduce conflict for IF in state 37 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 37 resolved as shift
WARNING: shift/reduce conflict for FOR in state 37 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 37 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 37 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 37 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 37 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 37 resolved as shift
WARNING: shift/reduce conflict for INT in state 37 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 37 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 37 resolved as shift
WARNING: shift/reduce conflict for ID in state 37 resolved as shift
WARNING: shift/reduce conflict for THIS in state 37 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 37 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 37 resolved as shift
WARNING: shift/reduce conflict for NEW in state 37 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 37 resolved as shift
WARNING: shift/reduce conflict for STRING in state 37 resolved as shift
WARNING: shift/reduce conflict for NULL in state 37 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 37 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 37 resolved as shift
WARNING: shift/reduce conflict for RCURLY in state 47 resolved as shift
WARNING: shift/reduce conflict for IF in state 47 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 47 resolved as shift
WARNING: shift/reduce conflict for FOR in state 47 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 47 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 47 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 47 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 47 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 47 resolved as shift
WARNING: shift/reduce conflict for INT in state 47 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 47 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 47 resolved as shift
WARNING: shift/reduce conflict for ID in state 47 resolved as shift
WARNING: shift/reduce conflict for THIS in state 47 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 47 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 47 resolved as shift
WARNING: shift/reduce conflict for NEW in state 47 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 47 resolved as shift
WARNING: shift/reduce conflict for STRING in state 47 resolved as shift
WARNING: shift/reduce conflict for NULL in state 47 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 47 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 47 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 131 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 131 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 131 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 131 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 131 resolved as shift
WARNING: shift/reduce conflict for LESS in state 131 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 131 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 131 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 131 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 131 resolved as shift
WARNING: shift/reduce conflict for AND in state 131 resolved as shift
WARNING: shift/reduce conflict for OR in state 131 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 135 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 135 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 135 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 135 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 135 resolved as shift
WARNING: shift/reduce conflict for LESS in state 135 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 135 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 135 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 135 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 135 resolved as shift
WARNING: shift/reduce conflict for AND in state 135 resolved as shift
WARNING: shift/reduce conflict for OR in state 135 resolved as shift
WARNING: shift/reduce conflict for IF in state 144 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 144 resolved as shift
WARNING: shift/reduce conflict for FOR in state 144 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 144 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 144 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 144 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 144 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 144 resolved as shift
WARNING: shift/reduce conflict for INT in state 144 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 144 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 144 resolved as shift
WARNING: shift/reduce conflict for ID in state 144 resolved as shift
WARNING: shift/reduce conflict for THIS in state 144 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 144 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 144 resolved as shift
WARNING: shift/reduce conflict for NEW in state 144 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 144 resolved as shift
WARNING: shift/reduce conflict for STRING in state 144 resolved as shift
WARNING: shift/reduce conflict for NULL in state 144 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 144 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 144 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 145 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 145 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 145 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 145 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 145 resolved as shift
WARNING: shift/reduce conflict for LESS in state 145 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 145 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 145 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 145 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 145 resolved as shift
WARNING: shift/reduce conflict for AND in state 145 resolved as shift
WARNING: shift/reduce conflict for OR in state 145 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 146 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 146 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 146 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 146 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 146 resolved as shift
WARNING: shift/reduce conflict for LESS in state 146 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 146 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 146 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 146 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 146 resolved as shift
WARNING: shift/reduce conflict for AND in state 146 resolved as shift
WARNING: shift/reduce conflict for OR in state 146 resolved as shift
WARNING: shift/reduce conflict for IF in state 147 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 147 resolved as shift
WARNING: shift/reduce conflict for FOR in state 147 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 147 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 147 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 147 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 147 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 147 resolved as shift
WARNING: shift/reduce conflict for INT in state 147 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 147 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 147 resolved as shift
WARNING: shift/reduce conflict for ID in state 147 resolved as shift
WARNING: shift/reduce conflict for THIS in state 147 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 147 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 147 resolved as shift
WARNING: shift/reduce conflict for NEW in state 147 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 147 resolved as shift
WARNING: shift/reduce conflict for STRING in state 147 resolved as shift
WARNING: shift/reduce conflict for NULL in state 147 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 147 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 147 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 153 resolved as shift
WARNING: shift/reduce conflict for IF in state 158 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 158 resolved as shift
WARNING: shift/reduce conflict for FOR in state 158 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 158 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 158 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 158 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 158 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 158 resolved as shift
WARNING: shift/reduce conflict for INT in state 158 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 158 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 158 resolved as shift
WARNING: shift/reduce conflict for ID in state 158 resolved as shift
WARNING: shift/reduce conflict for THIS in state 158 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 158 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 158 resolved as shift
WARNING: shift/reduce conflict for NEW in state 158 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 158 resolved as shift
WARNING: shift/reduce conflict for STRING in state 158 resolved as shift
WARNING: shift/reduce conflict for NULL in state 158 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 158 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 158 resolved as shift
WARNING: shift/reduce conflict for IF in state 162 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 162 resolved as shift
WARNING: shift/reduce conflict for FOR in state 162 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 162 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 162 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 162 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 162 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 162 resolved as shift
WARNING: shift/reduce conflict for INT in state 162 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 162 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 162 resolved as shift
WARNING: shift/reduce conflict for ID in state 162 resolved as shift
WARNING: shift/reduce conflict for THIS in state 162 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 162 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 162 resolved as shift
WARNING: shift/reduce conflict for NEW in state 162 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 162 resolved as shift
WARNING: shift/reduce conflict for STRING in state 162 resolved as shift
WARNING: shift/reduce conflict for NULL in state 162 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 162 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 162 resolved as shift
WARNING: reduce/reduce conflict in state 11 resolved using rule (class_body -> empty)
WARNING: rejected rule (modifier -> empty) in state 11
WARNING: reduce/reduce conflict in state 23 resolved using rule (type -> ID)
WARNING: rejected rule (empty -> <empty>) in state 23
