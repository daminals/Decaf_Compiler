Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    BOOL
    DO
    DOUBLE
    ERROR
    LBRACKET
    RBRACKET
    float_const
    int_const
    string_const

Grammar

Rule 0     S' -> start
Rule 1     start -> class_decl
Rule 2     class_decl -> CLASS ID LCURLY class_body RCURLY
Rule 3     class_decl -> CLASS ID EXTENDS ID LCURLY class_body RCURLY
Rule 4     class_body -> field_decl
Rule 5     class_body -> method_decl
Rule 6     class_body -> constructor_decl
Rule 7     class_body -> class_body field_decl
Rule 8     class_body -> class_body method_decl
Rule 9     class_body -> class_body constructor_decl
Rule 10    field_decl -> modifier var_decl
Rule 11    modifier -> PUBLIC
Rule 12    modifier -> PRIVATE
Rule 13    modifier -> PUBLIC STATIC
Rule 14    modifier -> PRIVATE STATIC
Rule 15    modifier -> empty
Rule 16    var_decl -> type variables SEMICOLON
Rule 17    type -> INT
Rule 18    type -> FLOAT
Rule 19    type -> BOOLEAN
Rule 20    type -> ID
Rule 21    variables -> variable
Rule 22    variables -> variable COMMA variables
Rule 23    variable -> ID
Rule 24    method_decl -> modifier type ID LPAREN RPAREN block
Rule 25    method_decl -> modifier type ID LPAREN formals RPAREN block
Rule 26    method_decl -> modifier VOID ID LPAREN RPAREN block
Rule 27    method_decl -> modifier VOID ID LPAREN formals RPAREN block
Rule 28    constructor_decl -> modifier ID block
Rule 29    constructor_decl -> modifier ID formals block
Rule 30    formals -> formal_param
Rule 31    formals -> formal_param COMMA formals
Rule 32    formal_param -> type variable
Rule 33    block -> LCURLY stmt RCURLY
Rule 34    stmt -> IF LPAREN expression RPAREN stmt
Rule 35    stmt -> IF LPAREN expression RPAREN stmt ELSE stmt
Rule 36    stmt -> WHILE LPAREN expression RPAREN stmt
Rule 37    stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
Rule 38    stmt -> RETURN expression SEMICOLON
Rule 39    stmt -> RETURN SEMICOLON
Rule 40    stmt -> stmt_expression SEMICOLON
Rule 41    stmt -> BREAK SEMICOLON
Rule 42    stmt -> CONTINUE SEMICOLON
Rule 43    stmt -> block
Rule 44    stmt -> var_decl
Rule 45    stmt -> SEMICOLON
Rule 46    literal -> INTEGER
Rule 47    literal -> FLOAT
Rule 48    literal -> STRING
Rule 49    literal -> NULL
Rule 50    literal -> FALSE
Rule 51    literal -> TRUE
Rule 52    primary -> literal
Rule 53    primary -> THIS
Rule 54    primary -> SUPER
Rule 55    primary -> LPAREN expression RPAREN
Rule 56    primary -> NEW ID
Rule 57    primary -> NEW ID LPAREN arguments RPAREN
Rule 58    primary -> method_invocation
Rule 59    primary -> lhs
Rule 60    arguments -> expression
Rule 61    arguments -> expression COMMA arguments
Rule 62    lhs -> field_access
Rule 63    field_access -> primary DOT ID
Rule 64    field_access -> ID
Rule 65    method_invocation -> field_access LPAREN arguments RPAREN
Rule 66    method_invocation -> field_access LPAREN RPAREN
Rule 67    expression -> primary
Rule 68    expression -> assign
Rule 69    expression -> expression arith_op expression
Rule 70    expression -> expression bool_op expression
Rule 71    expression -> unary_op expression
Rule 72    assign -> lhs SETEQUAL expression
Rule 73    arith_op -> PLUS
Rule 74    arith_op -> MINUS
Rule 75    arith_op -> TIMES
Rule 76    arith_op -> DIVIDE
Rule 77    bool_op -> GREATER
Rule 78    bool_op -> LESS
Rule 79    bool_op -> GREATEREQ
Rule 80    bool_op -> LESSEQ
Rule 81    bool_op -> EQUAL
Rule 82    bool_op -> NOTEQUAL
Rule 83    bool_op -> AND
Rule 84    bool_op -> OR
Rule 85    unary_op -> PLUS
Rule 86    unary_op -> MINUS
Rule 87    unary_op -> NOT
Rule 88    stmt_expression -> assign
Rule 89    stmt_expression -> method_invocation
Rule 90    empty -> <empty>

Terminals, with rules where they appear

AND                  : 83
BOOL                 : 
BOOLEAN              : 19
BREAK                : 41
CLASS                : 2 3
COMMA                : 22 31 61
CONTINUE             : 42
DIVIDE               : 76
DO                   : 
DOT                  : 63
DOUBLE               : 
ELSE                 : 35
EQUAL                : 81
ERROR                : 
EXTENDS              : 3
FALSE                : 50
FLOAT                : 18 47
FOR                  : 37
GREATER              : 77
GREATEREQ            : 79
ID                   : 2 3 3 20 23 24 25 26 27 28 29 56 57 63 64
IF                   : 34 35
INT                  : 17
INTEGER              : 46
LBRACKET             : 
LCURLY               : 2 3 33
LESS                 : 78
LESSEQ               : 80
LPAREN               : 24 25 26 27 34 35 36 37 55 57 65 66
MINUS                : 74 86
NEW                  : 56 57
NOT                  : 87
NOTEQUAL             : 82
NULL                 : 49
OR                   : 84
PLUS                 : 73 85
PRIVATE              : 12 14
PUBLIC               : 11 13
RBRACKET             : 
RCURLY               : 2 3 33
RETURN               : 38 39
RPAREN               : 24 25 26 27 34 35 36 37 55 57 65 66
SEMICOLON            : 16 37 37 38 39 40 41 42 45
SETEQUAL             : 72
STATIC               : 13 14
STRING               : 48
SUPER                : 54
THIS                 : 53
TIMES                : 75
TRUE                 : 51
VOID                 : 26 27
WHILE                : 36
error                : 
float_const          : 
int_const            : 
string_const         : 

Nonterminals, with rules where they appear

arguments            : 57 61 65
arith_op             : 69
assign               : 68 88
block                : 24 25 26 27 28 29 43
bool_op              : 70
class_body           : 2 3 7 8 9
class_decl           : 1
constructor_decl     : 6 9
empty                : 15
expression           : 34 35 36 37 38 55 60 61 69 69 70 70 71 72
field_access         : 62 65 66
field_decl           : 4 7
formal_param         : 30 31
formals              : 25 27 29 31
lhs                  : 59 72
literal              : 52
method_decl          : 5 8
method_invocation    : 58 89
modifier             : 10 24 25 26 27 28 29
primary              : 63 67
start                : 0
stmt                 : 33 34 35 35 36 37
stmt_expression      : 37 37 40
type                 : 16 24 25 32
unary_op             : 71
var_decl             : 10 44
variable             : 21 22 32
variables            : 16 22

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . class_decl
    (2) class_decl -> . CLASS ID LCURLY class_body RCURLY
    (3) class_decl -> . CLASS ID EXTENDS ID LCURLY class_body RCURLY

    CLASS           shift and go to state 3

    start                          shift and go to state 1
    class_decl                     shift and go to state 2

state 1

    (0) S' -> start .



state 2

    (1) start -> class_decl .

    $end            reduce using rule 1 (start -> class_decl .)


state 3

    (2) class_decl -> CLASS . ID LCURLY class_body RCURLY
    (3) class_decl -> CLASS . ID EXTENDS ID LCURLY class_body RCURLY

    ID              shift and go to state 4


state 4

    (2) class_decl -> CLASS ID . LCURLY class_body RCURLY
    (3) class_decl -> CLASS ID . EXTENDS ID LCURLY class_body RCURLY

    LCURLY          shift and go to state 5
    EXTENDS         shift and go to state 6


state 5

    (2) class_decl -> CLASS ID LCURLY . class_body RCURLY
    (4) class_body -> . field_decl
    (5) class_body -> . method_decl
    (6) class_body -> . constructor_decl
    (7) class_body -> . class_body field_decl
    (8) class_body -> . class_body method_decl
    (9) class_body -> . class_body constructor_decl
    (10) field_decl -> . modifier var_decl
    (24) method_decl -> . modifier type ID LPAREN RPAREN block
    (25) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (26) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (27) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (28) constructor_decl -> . modifier ID block
    (29) constructor_decl -> . modifier ID formals block
    (11) modifier -> . PUBLIC
    (12) modifier -> . PRIVATE
    (13) modifier -> . PUBLIC STATIC
    (14) modifier -> . PRIVATE STATIC
    (15) modifier -> . empty
    (90) empty -> .

    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 13
    VOID            reduce using rule 90 (empty -> .)
    ID              reduce using rule 90 (empty -> .)
    INT             reduce using rule 90 (empty -> .)
    FLOAT           reduce using rule 90 (empty -> .)
    BOOLEAN         reduce using rule 90 (empty -> .)

    class_body                     shift and go to state 7
    field_decl                     shift and go to state 8
    method_decl                    shift and go to state 9
    constructor_decl               shift and go to state 10
    modifier                       shift and go to state 11
    empty                          shift and go to state 14

state 6

    (3) class_decl -> CLASS ID EXTENDS . ID LCURLY class_body RCURLY

    ID              shift and go to state 15


state 7

    (2) class_decl -> CLASS ID LCURLY class_body . RCURLY
    (7) class_body -> class_body . field_decl
    (8) class_body -> class_body . method_decl
    (9) class_body -> class_body . constructor_decl
    (10) field_decl -> . modifier var_decl
    (24) method_decl -> . modifier type ID LPAREN RPAREN block
    (25) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (26) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (27) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (28) constructor_decl -> . modifier ID block
    (29) constructor_decl -> . modifier ID formals block
    (11) modifier -> . PUBLIC
    (12) modifier -> . PRIVATE
    (13) modifier -> . PUBLIC STATIC
    (14) modifier -> . PRIVATE STATIC
    (15) modifier -> . empty
    (90) empty -> .

    RCURLY          shift and go to state 16
    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 13
    VOID            reduce using rule 90 (empty -> .)
    ID              reduce using rule 90 (empty -> .)
    INT             reduce using rule 90 (empty -> .)
    FLOAT           reduce using rule 90 (empty -> .)
    BOOLEAN         reduce using rule 90 (empty -> .)

    field_decl                     shift and go to state 17
    method_decl                    shift and go to state 18
    constructor_decl               shift and go to state 19
    modifier                       shift and go to state 11
    empty                          shift and go to state 14

state 8

    (4) class_body -> field_decl .

    RCURLY          reduce using rule 4 (class_body -> field_decl .)
    PUBLIC          reduce using rule 4 (class_body -> field_decl .)
    PRIVATE         reduce using rule 4 (class_body -> field_decl .)
    VOID            reduce using rule 4 (class_body -> field_decl .)
    ID              reduce using rule 4 (class_body -> field_decl .)
    INT             reduce using rule 4 (class_body -> field_decl .)
    FLOAT           reduce using rule 4 (class_body -> field_decl .)
    BOOLEAN         reduce using rule 4 (class_body -> field_decl .)


state 9

    (5) class_body -> method_decl .

    RCURLY          reduce using rule 5 (class_body -> method_decl .)
    PUBLIC          reduce using rule 5 (class_body -> method_decl .)
    PRIVATE         reduce using rule 5 (class_body -> method_decl .)
    VOID            reduce using rule 5 (class_body -> method_decl .)
    ID              reduce using rule 5 (class_body -> method_decl .)
    INT             reduce using rule 5 (class_body -> method_decl .)
    FLOAT           reduce using rule 5 (class_body -> method_decl .)
    BOOLEAN         reduce using rule 5 (class_body -> method_decl .)


state 10

    (6) class_body -> constructor_decl .

    RCURLY          reduce using rule 6 (class_body -> constructor_decl .)
    PUBLIC          reduce using rule 6 (class_body -> constructor_decl .)
    PRIVATE         reduce using rule 6 (class_body -> constructor_decl .)
    VOID            reduce using rule 6 (class_body -> constructor_decl .)
    ID              reduce using rule 6 (class_body -> constructor_decl .)
    INT             reduce using rule 6 (class_body -> constructor_decl .)
    FLOAT           reduce using rule 6 (class_body -> constructor_decl .)
    BOOLEAN         reduce using rule 6 (class_body -> constructor_decl .)


state 11

    (10) field_decl -> modifier . var_decl
    (24) method_decl -> modifier . type ID LPAREN RPAREN block
    (25) method_decl -> modifier . type ID LPAREN formals RPAREN block
    (26) method_decl -> modifier . VOID ID LPAREN RPAREN block
    (27) method_decl -> modifier . VOID ID LPAREN formals RPAREN block
    (28) constructor_decl -> modifier . ID block
    (29) constructor_decl -> modifier . ID formals block
    (16) var_decl -> . type variables SEMICOLON
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . BOOLEAN
    (20) type -> . ID

    VOID            shift and go to state 23
    ID              shift and go to state 22
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    BOOLEAN         shift and go to state 26

    var_decl                       shift and go to state 20
    type                           shift and go to state 21

state 12

    (11) modifier -> PUBLIC .
    (13) modifier -> PUBLIC . STATIC

    VOID            reduce using rule 11 (modifier -> PUBLIC .)
    ID              reduce using rule 11 (modifier -> PUBLIC .)
    INT             reduce using rule 11 (modifier -> PUBLIC .)
    FLOAT           reduce using rule 11 (modifier -> PUBLIC .)
    BOOLEAN         reduce using rule 11 (modifier -> PUBLIC .)
    STATIC          shift and go to state 27


state 13

    (12) modifier -> PRIVATE .
    (14) modifier -> PRIVATE . STATIC

    VOID            reduce using rule 12 (modifier -> PRIVATE .)
    ID              reduce using rule 12 (modifier -> PRIVATE .)
    INT             reduce using rule 12 (modifier -> PRIVATE .)
    FLOAT           reduce using rule 12 (modifier -> PRIVATE .)
    BOOLEAN         reduce using rule 12 (modifier -> PRIVATE .)
    STATIC          shift and go to state 28


state 14

    (15) modifier -> empty .

    VOID            reduce using rule 15 (modifier -> empty .)
    ID              reduce using rule 15 (modifier -> empty .)
    INT             reduce using rule 15 (modifier -> empty .)
    FLOAT           reduce using rule 15 (modifier -> empty .)
    BOOLEAN         reduce using rule 15 (modifier -> empty .)


state 15

    (3) class_decl -> CLASS ID EXTENDS ID . LCURLY class_body RCURLY

    LCURLY          shift and go to state 29


state 16

    (2) class_decl -> CLASS ID LCURLY class_body RCURLY .

    $end            reduce using rule 2 (class_decl -> CLASS ID LCURLY class_body RCURLY .)


state 17

    (7) class_body -> class_body field_decl .

    RCURLY          reduce using rule 7 (class_body -> class_body field_decl .)
    PUBLIC          reduce using rule 7 (class_body -> class_body field_decl .)
    PRIVATE         reduce using rule 7 (class_body -> class_body field_decl .)
    VOID            reduce using rule 7 (class_body -> class_body field_decl .)
    ID              reduce using rule 7 (class_body -> class_body field_decl .)
    INT             reduce using rule 7 (class_body -> class_body field_decl .)
    FLOAT           reduce using rule 7 (class_body -> class_body field_decl .)
    BOOLEAN         reduce using rule 7 (class_body -> class_body field_decl .)


state 18

    (8) class_body -> class_body method_decl .

    RCURLY          reduce using rule 8 (class_body -> class_body method_decl .)
    PUBLIC          reduce using rule 8 (class_body -> class_body method_decl .)
    PRIVATE         reduce using rule 8 (class_body -> class_body method_decl .)
    VOID            reduce using rule 8 (class_body -> class_body method_decl .)
    ID              reduce using rule 8 (class_body -> class_body method_decl .)
    INT             reduce using rule 8 (class_body -> class_body method_decl .)
    FLOAT           reduce using rule 8 (class_body -> class_body method_decl .)
    BOOLEAN         reduce using rule 8 (class_body -> class_body method_decl .)


state 19

    (9) class_body -> class_body constructor_decl .

    RCURLY          reduce using rule 9 (class_body -> class_body constructor_decl .)
    PUBLIC          reduce using rule 9 (class_body -> class_body constructor_decl .)
    PRIVATE         reduce using rule 9 (class_body -> class_body constructor_decl .)
    VOID            reduce using rule 9 (class_body -> class_body constructor_decl .)
    ID              reduce using rule 9 (class_body -> class_body constructor_decl .)
    INT             reduce using rule 9 (class_body -> class_body constructor_decl .)
    FLOAT           reduce using rule 9 (class_body -> class_body constructor_decl .)
    BOOLEAN         reduce using rule 9 (class_body -> class_body constructor_decl .)


state 20

    (10) field_decl -> modifier var_decl .

    RCURLY          reduce using rule 10 (field_decl -> modifier var_decl .)
    PUBLIC          reduce using rule 10 (field_decl -> modifier var_decl .)
    PRIVATE         reduce using rule 10 (field_decl -> modifier var_decl .)
    VOID            reduce using rule 10 (field_decl -> modifier var_decl .)
    ID              reduce using rule 10 (field_decl -> modifier var_decl .)
    INT             reduce using rule 10 (field_decl -> modifier var_decl .)
    FLOAT           reduce using rule 10 (field_decl -> modifier var_decl .)
    BOOLEAN         reduce using rule 10 (field_decl -> modifier var_decl .)


state 21

    (24) method_decl -> modifier type . ID LPAREN RPAREN block
    (25) method_decl -> modifier type . ID LPAREN formals RPAREN block
    (16) var_decl -> type . variables SEMICOLON
    (21) variables -> . variable
    (22) variables -> . variable COMMA variables
    (23) variable -> . ID

    ID              shift and go to state 30

    variables                      shift and go to state 31
    variable                       shift and go to state 32

state 22

    (28) constructor_decl -> modifier ID . block
    (29) constructor_decl -> modifier ID . formals block
    (20) type -> ID .
    (33) block -> . LCURLY stmt RCURLY
    (30) formals -> . formal_param
    (31) formals -> . formal_param COMMA formals
    (32) formal_param -> . type variable
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . BOOLEAN
    (20) type -> . ID

  ! shift/reduce conflict for ID resolved as shift
    LCURLY          shift and go to state 36
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    BOOLEAN         shift and go to state 26
    ID              shift and go to state 33

  ! ID              [ reduce using rule 20 (type -> ID .) ]

    block                          shift and go to state 34
    formals                        shift and go to state 35
    formal_param                   shift and go to state 37
    type                           shift and go to state 38

state 23

    (26) method_decl -> modifier VOID . ID LPAREN RPAREN block
    (27) method_decl -> modifier VOID . ID LPAREN formals RPAREN block

    ID              shift and go to state 39


state 24

    (17) type -> INT .

    ID              reduce using rule 17 (type -> INT .)


state 25

    (18) type -> FLOAT .

    ID              reduce using rule 18 (type -> FLOAT .)


state 26

    (19) type -> BOOLEAN .

    ID              reduce using rule 19 (type -> BOOLEAN .)


state 27

    (13) modifier -> PUBLIC STATIC .

    VOID            reduce using rule 13 (modifier -> PUBLIC STATIC .)
    ID              reduce using rule 13 (modifier -> PUBLIC STATIC .)
    INT             reduce using rule 13 (modifier -> PUBLIC STATIC .)
    FLOAT           reduce using rule 13 (modifier -> PUBLIC STATIC .)
    BOOLEAN         reduce using rule 13 (modifier -> PUBLIC STATIC .)


state 28

    (14) modifier -> PRIVATE STATIC .

    VOID            reduce using rule 14 (modifier -> PRIVATE STATIC .)
    ID              reduce using rule 14 (modifier -> PRIVATE STATIC .)
    INT             reduce using rule 14 (modifier -> PRIVATE STATIC .)
    FLOAT           reduce using rule 14 (modifier -> PRIVATE STATIC .)
    BOOLEAN         reduce using rule 14 (modifier -> PRIVATE STATIC .)


state 29

    (3) class_decl -> CLASS ID EXTENDS ID LCURLY . class_body RCURLY
    (4) class_body -> . field_decl
    (5) class_body -> . method_decl
    (6) class_body -> . constructor_decl
    (7) class_body -> . class_body field_decl
    (8) class_body -> . class_body method_decl
    (9) class_body -> . class_body constructor_decl
    (10) field_decl -> . modifier var_decl
    (24) method_decl -> . modifier type ID LPAREN RPAREN block
    (25) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (26) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (27) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (28) constructor_decl -> . modifier ID block
    (29) constructor_decl -> . modifier ID formals block
    (11) modifier -> . PUBLIC
    (12) modifier -> . PRIVATE
    (13) modifier -> . PUBLIC STATIC
    (14) modifier -> . PRIVATE STATIC
    (15) modifier -> . empty
    (90) empty -> .

    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 13
    VOID            reduce using rule 90 (empty -> .)
    ID              reduce using rule 90 (empty -> .)
    INT             reduce using rule 90 (empty -> .)
    FLOAT           reduce using rule 90 (empty -> .)
    BOOLEAN         reduce using rule 90 (empty -> .)

    class_body                     shift and go to state 40
    field_decl                     shift and go to state 8
    method_decl                    shift and go to state 9
    constructor_decl               shift and go to state 10
    modifier                       shift and go to state 11
    empty                          shift and go to state 14

state 30

    (24) method_decl -> modifier type ID . LPAREN RPAREN block
    (25) method_decl -> modifier type ID . LPAREN formals RPAREN block
    (23) variable -> ID .

    LPAREN          shift and go to state 41
    COMMA           reduce using rule 23 (variable -> ID .)
    SEMICOLON       reduce using rule 23 (variable -> ID .)


state 31

    (16) var_decl -> type variables . SEMICOLON

    SEMICOLON       shift and go to state 42


state 32

    (21) variables -> variable .
    (22) variables -> variable . COMMA variables

    SEMICOLON       reduce using rule 21 (variables -> variable .)
    COMMA           shift and go to state 43


state 33

    (20) type -> ID .

    ID              reduce using rule 20 (type -> ID .)


state 34

    (28) constructor_decl -> modifier ID block .

    RCURLY          reduce using rule 28 (constructor_decl -> modifier ID block .)
    PUBLIC          reduce using rule 28 (constructor_decl -> modifier ID block .)
    PRIVATE         reduce using rule 28 (constructor_decl -> modifier ID block .)
    VOID            reduce using rule 28 (constructor_decl -> modifier ID block .)
    ID              reduce using rule 28 (constructor_decl -> modifier ID block .)
    INT             reduce using rule 28 (constructor_decl -> modifier ID block .)
    FLOAT           reduce using rule 28 (constructor_decl -> modifier ID block .)
    BOOLEAN         reduce using rule 28 (constructor_decl -> modifier ID block .)


state 35

    (29) constructor_decl -> modifier ID formals . block
    (33) block -> . LCURLY stmt RCURLY

    LCURLY          shift and go to state 36

    block                          shift and go to state 44

state 36

    (33) block -> LCURLY . stmt RCURLY
    (34) stmt -> . IF LPAREN expression RPAREN stmt
    (35) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (36) stmt -> . WHILE LPAREN expression RPAREN stmt
    (37) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (38) stmt -> . RETURN expression SEMICOLON
    (39) stmt -> . RETURN SEMICOLON
    (40) stmt -> . stmt_expression SEMICOLON
    (41) stmt -> . BREAK SEMICOLON
    (42) stmt -> . CONTINUE SEMICOLON
    (43) stmt -> . block
    (44) stmt -> . var_decl
    (45) stmt -> . SEMICOLON
    (88) stmt_expression -> . assign
    (89) stmt_expression -> . method_invocation
    (33) block -> . LCURLY stmt RCURLY
    (16) var_decl -> . type variables SEMICOLON
    (72) assign -> . lhs SETEQUAL expression
    (65) method_invocation -> . field_access LPAREN arguments RPAREN
    (66) method_invocation -> . field_access LPAREN RPAREN
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . BOOLEAN
    (20) type -> . ID
    (62) lhs -> . field_access
    (63) field_access -> . primary DOT ID
    (64) field_access -> . ID
    (52) primary -> . literal
    (53) primary -> . THIS
    (54) primary -> . SUPER
    (55) primary -> . LPAREN expression RPAREN
    (56) primary -> . NEW ID
    (57) primary -> . NEW ID LPAREN arguments RPAREN
    (58) primary -> . method_invocation
    (59) primary -> . lhs
    (46) literal -> . INTEGER
    (47) literal -> . FLOAT
    (48) literal -> . STRING
    (49) literal -> . NULL
    (50) literal -> . FALSE
    (51) literal -> . TRUE

    IF              shift and go to state 46
    WHILE           shift and go to state 48
    FOR             shift and go to state 49
    RETURN          shift and go to state 52
    BREAK           shift and go to state 53
    CONTINUE        shift and go to state 54
    SEMICOLON       shift and go to state 51
    LCURLY          shift and go to state 36
    INT             shift and go to state 24
    FLOAT           shift and go to state 62
    BOOLEAN         shift and go to state 26
    ID              shift and go to state 63
    THIS            shift and go to state 66
    SUPER           shift and go to state 67
    LPAREN          shift and go to state 47
    NEW             shift and go to state 68
    INTEGER         shift and go to state 69
    STRING          shift and go to state 70
    NULL            shift and go to state 71
    FALSE           shift and go to state 72
    TRUE            shift and go to state 73

    stmt                           shift and go to state 45
    stmt_expression                shift and go to state 50
    block                          shift and go to state 55
    var_decl                       shift and go to state 56
    assign                         shift and go to state 57
    method_invocation              shift and go to state 58
    type                           shift and go to state 59
    lhs                            shift and go to state 60
    field_access                   shift and go to state 61
    primary                        shift and go to state 64
    literal                        shift and go to state 65

state 37

    (30) formals -> formal_param .
    (31) formals -> formal_param . COMMA formals

    LCURLY          reduce using rule 30 (formals -> formal_param .)
    RPAREN          reduce using rule 30 (formals -> formal_param .)
    COMMA           shift and go to state 74


state 38

    (32) formal_param -> type . variable
    (23) variable -> . ID

    ID              shift and go to state 76

    variable                       shift and go to state 75

state 39

    (26) method_decl -> modifier VOID ID . LPAREN RPAREN block
    (27) method_decl -> modifier VOID ID . LPAREN formals RPAREN block

    LPAREN          shift and go to state 77


state 40

    (3) class_decl -> CLASS ID EXTENDS ID LCURLY class_body . RCURLY
    (7) class_body -> class_body . field_decl
    (8) class_body -> class_body . method_decl
    (9) class_body -> class_body . constructor_decl
    (10) field_decl -> . modifier var_decl
    (24) method_decl -> . modifier type ID LPAREN RPAREN block
    (25) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (26) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (27) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (28) constructor_decl -> . modifier ID block
    (29) constructor_decl -> . modifier ID formals block
    (11) modifier -> . PUBLIC
    (12) modifier -> . PRIVATE
    (13) modifier -> . PUBLIC STATIC
    (14) modifier -> . PRIVATE STATIC
    (15) modifier -> . empty
    (90) empty -> .

    RCURLY          shift and go to state 78
    PUBLIC          shift and go to state 12
    PRIVATE         shift and go to state 13
    VOID            reduce using rule 90 (empty -> .)
    ID              reduce using rule 90 (empty -> .)
    INT             reduce using rule 90 (empty -> .)
    FLOAT           reduce using rule 90 (empty -> .)
    BOOLEAN         reduce using rule 90 (empty -> .)

    field_decl                     shift and go to state 17
    method_decl                    shift and go to state 18
    constructor_decl               shift and go to state 19
    modifier                       shift and go to state 11
    empty                          shift and go to state 14

state 41

    (24) method_decl -> modifier type ID LPAREN . RPAREN block
    (25) method_decl -> modifier type ID LPAREN . formals RPAREN block
    (30) formals -> . formal_param
    (31) formals -> . formal_param COMMA formals
    (32) formal_param -> . type variable
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . BOOLEAN
    (20) type -> . ID

    RPAREN          shift and go to state 79
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    BOOLEAN         shift and go to state 26
    ID              shift and go to state 33

    type                           shift and go to state 38
    formals                        shift and go to state 80
    formal_param                   shift and go to state 37

state 42

    (16) var_decl -> type variables SEMICOLON .

    RCURLY          reduce using rule 16 (var_decl -> type variables SEMICOLON .)
    PUBLIC          reduce using rule 16 (var_decl -> type variables SEMICOLON .)
    PRIVATE         reduce using rule 16 (var_decl -> type variables SEMICOLON .)
    VOID            reduce using rule 16 (var_decl -> type variables SEMICOLON .)
    ID              reduce using rule 16 (var_decl -> type variables SEMICOLON .)
    INT             reduce using rule 16 (var_decl -> type variables SEMICOLON .)
    FLOAT           reduce using rule 16 (var_decl -> type variables SEMICOLON .)
    BOOLEAN         reduce using rule 16 (var_decl -> type variables SEMICOLON .)
    ELSE            reduce using rule 16 (var_decl -> type variables SEMICOLON .)


state 43

    (22) variables -> variable COMMA . variables
    (21) variables -> . variable
    (22) variables -> . variable COMMA variables
    (23) variable -> . ID

    ID              shift and go to state 76

    variable                       shift and go to state 32
    variables                      shift and go to state 81

state 44

    (29) constructor_decl -> modifier ID formals block .

    RCURLY          reduce using rule 29 (constructor_decl -> modifier ID formals block .)
    PUBLIC          reduce using rule 29 (constructor_decl -> modifier ID formals block .)
    PRIVATE         reduce using rule 29 (constructor_decl -> modifier ID formals block .)
    VOID            reduce using rule 29 (constructor_decl -> modifier ID formals block .)
    ID              reduce using rule 29 (constructor_decl -> modifier ID formals block .)
    INT             reduce using rule 29 (constructor_decl -> modifier ID formals block .)
    FLOAT           reduce using rule 29 (constructor_decl -> modifier ID formals block .)
    BOOLEAN         reduce using rule 29 (constructor_decl -> modifier ID formals block .)


state 45

    (33) block -> LCURLY stmt . RCURLY

    RCURLY          shift and go to state 82


state 46

    (34) stmt -> IF . LPAREN expression RPAREN stmt
    (35) stmt -> IF . LPAREN expression RPAREN stmt ELSE stmt

    LPAREN          shift and go to state 83


state 47

    (55) primary -> LPAREN . expression RPAREN
    (67) expression -> . primary
    (68) expression -> . assign
    (69) expression -> . expression arith_op expression
    (70) expression -> . expression bool_op expression
    (71) expression -> . unary_op expression
    (52) primary -> . literal
    (53) primary -> . THIS
    (54) primary -> . SUPER
    (55) primary -> . LPAREN expression RPAREN
    (56) primary -> . NEW ID
    (57) primary -> . NEW ID LPAREN arguments RPAREN
    (58) primary -> . method_invocation
    (59) primary -> . lhs
    (72) assign -> . lhs SETEQUAL expression
    (85) unary_op -> . PLUS
    (86) unary_op -> . MINUS
    (87) unary_op -> . NOT
    (46) literal -> . INTEGER
    (47) literal -> . FLOAT
    (48) literal -> . STRING
    (49) literal -> . NULL
    (50) literal -> . FALSE
    (51) literal -> . TRUE
    (65) method_invocation -> . field_access LPAREN arguments RPAREN
    (66) method_invocation -> . field_access LPAREN RPAREN
    (62) lhs -> . field_access
    (63) field_access -> . primary DOT ID
    (64) field_access -> . ID

    THIS            shift and go to state 66
    SUPER           shift and go to state 67
    LPAREN          shift and go to state 47
    NEW             shift and go to state 68
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    NOT             shift and go to state 93
    INTEGER         shift and go to state 69
    FLOAT           shift and go to state 94
    STRING          shift and go to state 70
    NULL            shift and go to state 71
    FALSE           shift and go to state 72
    TRUE            shift and go to state 73
    ID              shift and go to state 88

    expression                     shift and go to state 84
    primary                        shift and go to state 85
    assign                         shift and go to state 86
    unary_op                       shift and go to state 87
    literal                        shift and go to state 65
    method_invocation              shift and go to state 89
    lhs                            shift and go to state 90
    field_access                   shift and go to state 61

state 48

    (36) stmt -> WHILE . LPAREN expression RPAREN stmt

    LPAREN          shift and go to state 95


state 49

    (37) stmt -> FOR . LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt

    LPAREN          shift and go to state 96


state 50

    (40) stmt -> stmt_expression . SEMICOLON

    SEMICOLON       shift and go to state 97


state 51

    (45) stmt -> SEMICOLON .

    RCURLY          reduce using rule 45 (stmt -> SEMICOLON .)
    ELSE            reduce using rule 45 (stmt -> SEMICOLON .)


state 52

    (38) stmt -> RETURN . expression SEMICOLON
    (39) stmt -> RETURN . SEMICOLON
    (67) expression -> . primary
    (68) expression -> . assign
    (69) expression -> . expression arith_op expression
    (70) expression -> . expression bool_op expression
    (71) expression -> . unary_op expression
    (52) primary -> . literal
    (53) primary -> . THIS
    (54) primary -> . SUPER
    (55) primary -> . LPAREN expression RPAREN
    (56) primary -> . NEW ID
    (57) primary -> . NEW ID LPAREN arguments RPAREN
    (58) primary -> . method_invocation
    (59) primary -> . lhs
    (72) assign -> . lhs SETEQUAL expression
    (85) unary_op -> . PLUS
    (86) unary_op -> . MINUS
    (87) unary_op -> . NOT
    (46) literal -> . INTEGER
    (47) literal -> . FLOAT
    (48) literal -> . STRING
    (49) literal -> . NULL
    (50) literal -> . FALSE
    (51) literal -> . TRUE
    (65) method_invocation -> . field_access LPAREN arguments RPAREN
    (66) method_invocation -> . field_access LPAREN RPAREN
    (62) lhs -> . field_access
    (63) field_access -> . primary DOT ID
    (64) field_access -> . ID

    SEMICOLON       shift and go to state 99
    THIS            shift and go to state 66
    SUPER           shift and go to state 67
    LPAREN          shift and go to state 47
    NEW             shift and go to state 68
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    NOT             shift and go to state 93
    INTEGER         shift and go to state 69
    FLOAT           shift and go to state 94
    STRING          shift and go to state 70
    NULL            shift and go to state 71
    FALSE           shift and go to state 72
    TRUE            shift and go to state 73
    ID              shift and go to state 88

    expression                     shift and go to state 98
    primary                        shift and go to state 85
    assign                         shift and go to state 86
    unary_op                       shift and go to state 87
    literal                        shift and go to state 65
    method_invocation              shift and go to state 89
    lhs                            shift and go to state 90
    field_access                   shift and go to state 61

state 53

    (41) stmt -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 100


state 54

    (42) stmt -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 101


state 55

    (43) stmt -> block .

    RCURLY          reduce using rule 43 (stmt -> block .)
    ELSE            reduce using rule 43 (stmt -> block .)


state 56

    (44) stmt -> var_decl .

    RCURLY          reduce using rule 44 (stmt -> var_decl .)
    ELSE            reduce using rule 44 (stmt -> var_decl .)


state 57

    (88) stmt_expression -> assign .

    SEMICOLON       reduce using rule 88 (stmt_expression -> assign .)
    RPAREN          reduce using rule 88 (stmt_expression -> assign .)


state 58

    (89) stmt_expression -> method_invocation .
    (58) primary -> method_invocation .

    SEMICOLON       reduce using rule 89 (stmt_expression -> method_invocation .)
    RPAREN          reduce using rule 89 (stmt_expression -> method_invocation .)
    DOT             reduce using rule 58 (primary -> method_invocation .)


state 59

    (16) var_decl -> type . variables SEMICOLON
    (21) variables -> . variable
    (22) variables -> . variable COMMA variables
    (23) variable -> . ID

    ID              shift and go to state 76

    variables                      shift and go to state 31
    variable                       shift and go to state 32

state 60

    (72) assign -> lhs . SETEQUAL expression
    (59) primary -> lhs .

    SETEQUAL        shift and go to state 102
    DOT             reduce using rule 59 (primary -> lhs .)


state 61

    (65) method_invocation -> field_access . LPAREN arguments RPAREN
    (66) method_invocation -> field_access . LPAREN RPAREN
    (62) lhs -> field_access .

    LPAREN          shift and go to state 103
    SETEQUAL        reduce using rule 62 (lhs -> field_access .)
    DOT             reduce using rule 62 (lhs -> field_access .)
    RPAREN          reduce using rule 62 (lhs -> field_access .)
    PLUS            reduce using rule 62 (lhs -> field_access .)
    MINUS           reduce using rule 62 (lhs -> field_access .)
    TIMES           reduce using rule 62 (lhs -> field_access .)
    DIVIDE          reduce using rule 62 (lhs -> field_access .)
    GREATER         reduce using rule 62 (lhs -> field_access .)
    LESS            reduce using rule 62 (lhs -> field_access .)
    GREATEREQ       reduce using rule 62 (lhs -> field_access .)
    LESSEQ          reduce using rule 62 (lhs -> field_access .)
    EQUAL           reduce using rule 62 (lhs -> field_access .)
    NOTEQUAL        reduce using rule 62 (lhs -> field_access .)
    AND             reduce using rule 62 (lhs -> field_access .)
    OR              reduce using rule 62 (lhs -> field_access .)
    SEMICOLON       reduce using rule 62 (lhs -> field_access .)
    COMMA           reduce using rule 62 (lhs -> field_access .)


state 62

    (18) type -> FLOAT .
    (47) literal -> FLOAT .

    ID              reduce using rule 18 (type -> FLOAT .)
    DOT             reduce using rule 47 (literal -> FLOAT .)


state 63

    (20) type -> ID .
    (64) field_access -> ID .

    ID              reduce using rule 20 (type -> ID .)
    LPAREN          reduce using rule 64 (field_access -> ID .)
    SETEQUAL        reduce using rule 64 (field_access -> ID .)
    DOT             reduce using rule 64 (field_access -> ID .)


state 64

    (63) field_access -> primary . DOT ID

    DOT             shift and go to state 104


state 65

    (52) primary -> literal .

    DOT             reduce using rule 52 (primary -> literal .)
    RPAREN          reduce using rule 52 (primary -> literal .)
    PLUS            reduce using rule 52 (primary -> literal .)
    MINUS           reduce using rule 52 (primary -> literal .)
    TIMES           reduce using rule 52 (primary -> literal .)
    DIVIDE          reduce using rule 52 (primary -> literal .)
    GREATER         reduce using rule 52 (primary -> literal .)
    LESS            reduce using rule 52 (primary -> literal .)
    GREATEREQ       reduce using rule 52 (primary -> literal .)
    LESSEQ          reduce using rule 52 (primary -> literal .)
    EQUAL           reduce using rule 52 (primary -> literal .)
    NOTEQUAL        reduce using rule 52 (primary -> literal .)
    AND             reduce using rule 52 (primary -> literal .)
    OR              reduce using rule 52 (primary -> literal .)
    SEMICOLON       reduce using rule 52 (primary -> literal .)
    COMMA           reduce using rule 52 (primary -> literal .)


state 66

    (53) primary -> THIS .

    DOT             reduce using rule 53 (primary -> THIS .)
    RPAREN          reduce using rule 53 (primary -> THIS .)
    PLUS            reduce using rule 53 (primary -> THIS .)
    MINUS           reduce using rule 53 (primary -> THIS .)
    TIMES           reduce using rule 53 (primary -> THIS .)
    DIVIDE          reduce using rule 53 (primary -> THIS .)
    GREATER         reduce using rule 53 (primary -> THIS .)
    LESS            reduce using rule 53 (primary -> THIS .)
    GREATEREQ       reduce using rule 53 (primary -> THIS .)
    LESSEQ          reduce using rule 53 (primary -> THIS .)
    EQUAL           reduce using rule 53 (primary -> THIS .)
    NOTEQUAL        reduce using rule 53 (primary -> THIS .)
    AND             reduce using rule 53 (primary -> THIS .)
    OR              reduce using rule 53 (primary -> THIS .)
    SEMICOLON       reduce using rule 53 (primary -> THIS .)
    COMMA           reduce using rule 53 (primary -> THIS .)


state 67

    (54) primary -> SUPER .

    DOT             reduce using rule 54 (primary -> SUPER .)
    RPAREN          reduce using rule 54 (primary -> SUPER .)
    PLUS            reduce using rule 54 (primary -> SUPER .)
    MINUS           reduce using rule 54 (primary -> SUPER .)
    TIMES           reduce using rule 54 (primary -> SUPER .)
    DIVIDE          reduce using rule 54 (primary -> SUPER .)
    GREATER         reduce using rule 54 (primary -> SUPER .)
    LESS            reduce using rule 54 (primary -> SUPER .)
    GREATEREQ       reduce using rule 54 (primary -> SUPER .)
    LESSEQ          reduce using rule 54 (primary -> SUPER .)
    EQUAL           reduce using rule 54 (primary -> SUPER .)
    NOTEQUAL        reduce using rule 54 (primary -> SUPER .)
    AND             reduce using rule 54 (primary -> SUPER .)
    OR              reduce using rule 54 (primary -> SUPER .)
    SEMICOLON       reduce using rule 54 (primary -> SUPER .)
    COMMA           reduce using rule 54 (primary -> SUPER .)


state 68

    (56) primary -> NEW . ID
    (57) primary -> NEW . ID LPAREN arguments RPAREN

    ID              shift and go to state 105


state 69

    (46) literal -> INTEGER .

    DOT             reduce using rule 46 (literal -> INTEGER .)
    RPAREN          reduce using rule 46 (literal -> INTEGER .)
    PLUS            reduce using rule 46 (literal -> INTEGER .)
    MINUS           reduce using rule 46 (literal -> INTEGER .)
    TIMES           reduce using rule 46 (literal -> INTEGER .)
    DIVIDE          reduce using rule 46 (literal -> INTEGER .)
    GREATER         reduce using rule 46 (literal -> INTEGER .)
    LESS            reduce using rule 46 (literal -> INTEGER .)
    GREATEREQ       reduce using rule 46 (literal -> INTEGER .)
    LESSEQ          reduce using rule 46 (literal -> INTEGER .)
    EQUAL           reduce using rule 46 (literal -> INTEGER .)
    NOTEQUAL        reduce using rule 46 (literal -> INTEGER .)
    AND             reduce using rule 46 (literal -> INTEGER .)
    OR              reduce using rule 46 (literal -> INTEGER .)
    SEMICOLON       reduce using rule 46 (literal -> INTEGER .)
    COMMA           reduce using rule 46 (literal -> INTEGER .)


state 70

    (48) literal -> STRING .

    DOT             reduce using rule 48 (literal -> STRING .)
    RPAREN          reduce using rule 48 (literal -> STRING .)
    PLUS            reduce using rule 48 (literal -> STRING .)
    MINUS           reduce using rule 48 (literal -> STRING .)
    TIMES           reduce using rule 48 (literal -> STRING .)
    DIVIDE          reduce using rule 48 (literal -> STRING .)
    GREATER         reduce using rule 48 (literal -> STRING .)
    LESS            reduce using rule 48 (literal -> STRING .)
    GREATEREQ       reduce using rule 48 (literal -> STRING .)
    LESSEQ          reduce using rule 48 (literal -> STRING .)
    EQUAL           reduce using rule 48 (literal -> STRING .)
    NOTEQUAL        reduce using rule 48 (literal -> STRING .)
    AND             reduce using rule 48 (literal -> STRING .)
    OR              reduce using rule 48 (literal -> STRING .)
    SEMICOLON       reduce using rule 48 (literal -> STRING .)
    COMMA           reduce using rule 48 (literal -> STRING .)


state 71

    (49) literal -> NULL .

    DOT             reduce using rule 49 (literal -> NULL .)
    RPAREN          reduce using rule 49 (literal -> NULL .)
    PLUS            reduce using rule 49 (literal -> NULL .)
    MINUS           reduce using rule 49 (literal -> NULL .)
    TIMES           reduce using rule 49 (literal -> NULL .)
    DIVIDE          reduce using rule 49 (literal -> NULL .)
    GREATER         reduce using rule 49 (literal -> NULL .)
    LESS            reduce using rule 49 (literal -> NULL .)
    GREATEREQ       reduce using rule 49 (literal -> NULL .)
    LESSEQ          reduce using rule 49 (literal -> NULL .)
    EQUAL           reduce using rule 49 (literal -> NULL .)
    NOTEQUAL        reduce using rule 49 (literal -> NULL .)
    AND             reduce using rule 49 (literal -> NULL .)
    OR              reduce using rule 49 (literal -> NULL .)
    SEMICOLON       reduce using rule 49 (literal -> NULL .)
    COMMA           reduce using rule 49 (literal -> NULL .)


state 72

    (50) literal -> FALSE .

    DOT             reduce using rule 50 (literal -> FALSE .)
    RPAREN          reduce using rule 50 (literal -> FALSE .)
    PLUS            reduce using rule 50 (literal -> FALSE .)
    MINUS           reduce using rule 50 (literal -> FALSE .)
    TIMES           reduce using rule 50 (literal -> FALSE .)
    DIVIDE          reduce using rule 50 (literal -> FALSE .)
    GREATER         reduce using rule 50 (literal -> FALSE .)
    LESS            reduce using rule 50 (literal -> FALSE .)
    GREATEREQ       reduce using rule 50 (literal -> FALSE .)
    LESSEQ          reduce using rule 50 (literal -> FALSE .)
    EQUAL           reduce using rule 50 (literal -> FALSE .)
    NOTEQUAL        reduce using rule 50 (literal -> FALSE .)
    AND             reduce using rule 50 (literal -> FALSE .)
    OR              reduce using rule 50 (literal -> FALSE .)
    SEMICOLON       reduce using rule 50 (literal -> FALSE .)
    COMMA           reduce using rule 50 (literal -> FALSE .)


state 73

    (51) literal -> TRUE .

    DOT             reduce using rule 51 (literal -> TRUE .)
    RPAREN          reduce using rule 51 (literal -> TRUE .)
    PLUS            reduce using rule 51 (literal -> TRUE .)
    MINUS           reduce using rule 51 (literal -> TRUE .)
    TIMES           reduce using rule 51 (literal -> TRUE .)
    DIVIDE          reduce using rule 51 (literal -> TRUE .)
    GREATER         reduce using rule 51 (literal -> TRUE .)
    LESS            reduce using rule 51 (literal -> TRUE .)
    GREATEREQ       reduce using rule 51 (literal -> TRUE .)
    LESSEQ          reduce using rule 51 (literal -> TRUE .)
    EQUAL           reduce using rule 51 (literal -> TRUE .)
    NOTEQUAL        reduce using rule 51 (literal -> TRUE .)
    AND             reduce using rule 51 (literal -> TRUE .)
    OR              reduce using rule 51 (literal -> TRUE .)
    SEMICOLON       reduce using rule 51 (literal -> TRUE .)
    COMMA           reduce using rule 51 (literal -> TRUE .)


state 74

    (31) formals -> formal_param COMMA . formals
    (30) formals -> . formal_param
    (31) formals -> . formal_param COMMA formals
    (32) formal_param -> . type variable
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . BOOLEAN
    (20) type -> . ID

    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    BOOLEAN         shift and go to state 26
    ID              shift and go to state 33

    formal_param                   shift and go to state 37
    formals                        shift and go to state 106
    type                           shift and go to state 38

state 75

    (32) formal_param -> type variable .

    COMMA           reduce using rule 32 (formal_param -> type variable .)
    LCURLY          reduce using rule 32 (formal_param -> type variable .)
    RPAREN          reduce using rule 32 (formal_param -> type variable .)


state 76

    (23) variable -> ID .

    COMMA           reduce using rule 23 (variable -> ID .)
    LCURLY          reduce using rule 23 (variable -> ID .)
    RPAREN          reduce using rule 23 (variable -> ID .)
    SEMICOLON       reduce using rule 23 (variable -> ID .)


state 77

    (26) method_decl -> modifier VOID ID LPAREN . RPAREN block
    (27) method_decl -> modifier VOID ID LPAREN . formals RPAREN block
    (30) formals -> . formal_param
    (31) formals -> . formal_param COMMA formals
    (32) formal_param -> . type variable
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . BOOLEAN
    (20) type -> . ID

    RPAREN          shift and go to state 107
    INT             shift and go to state 24
    FLOAT           shift and go to state 25
    BOOLEAN         shift and go to state 26
    ID              shift and go to state 33

    formals                        shift and go to state 108
    formal_param                   shift and go to state 37
    type                           shift and go to state 38

state 78

    (3) class_decl -> CLASS ID EXTENDS ID LCURLY class_body RCURLY .

    $end            reduce using rule 3 (class_decl -> CLASS ID EXTENDS ID LCURLY class_body RCURLY .)


state 79

    (24) method_decl -> modifier type ID LPAREN RPAREN . block
    (33) block -> . LCURLY stmt RCURLY

    LCURLY          shift and go to state 36

    block                          shift and go to state 109

state 80

    (25) method_decl -> modifier type ID LPAREN formals . RPAREN block

    RPAREN          shift and go to state 110


state 81

    (22) variables -> variable COMMA variables .

    SEMICOLON       reduce using rule 22 (variables -> variable COMMA variables .)


state 82

    (33) block -> LCURLY stmt RCURLY .

    RCURLY          reduce using rule 33 (block -> LCURLY stmt RCURLY .)
    PUBLIC          reduce using rule 33 (block -> LCURLY stmt RCURLY .)
    PRIVATE         reduce using rule 33 (block -> LCURLY stmt RCURLY .)
    VOID            reduce using rule 33 (block -> LCURLY stmt RCURLY .)
    ID              reduce using rule 33 (block -> LCURLY stmt RCURLY .)
    INT             reduce using rule 33 (block -> LCURLY stmt RCURLY .)
    FLOAT           reduce using rule 33 (block -> LCURLY stmt RCURLY .)
    BOOLEAN         reduce using rule 33 (block -> LCURLY stmt RCURLY .)
    ELSE            reduce using rule 33 (block -> LCURLY stmt RCURLY .)


state 83

    (34) stmt -> IF LPAREN . expression RPAREN stmt
    (35) stmt -> IF LPAREN . expression RPAREN stmt ELSE stmt
    (67) expression -> . primary
    (68) expression -> . assign
    (69) expression -> . expression arith_op expression
    (70) expression -> . expression bool_op expression
    (71) expression -> . unary_op expression
    (52) primary -> . literal
    (53) primary -> . THIS
    (54) primary -> . SUPER
    (55) primary -> . LPAREN expression RPAREN
    (56) primary -> . NEW ID
    (57) primary -> . NEW ID LPAREN arguments RPAREN
    (58) primary -> . method_invocation
    (59) primary -> . lhs
    (72) assign -> . lhs SETEQUAL expression
    (85) unary_op -> . PLUS
    (86) unary_op -> . MINUS
    (87) unary_op -> . NOT
    (46) literal -> . INTEGER
    (47) literal -> . FLOAT
    (48) literal -> . STRING
    (49) literal -> . NULL
    (50) literal -> . FALSE
    (51) literal -> . TRUE
    (65) method_invocation -> . field_access LPAREN arguments RPAREN
    (66) method_invocation -> . field_access LPAREN RPAREN
    (62) lhs -> . field_access
    (63) field_access -> . primary DOT ID
    (64) field_access -> . ID

    THIS            shift and go to state 66
    SUPER           shift and go to state 67
    LPAREN          shift and go to state 47
    NEW             shift and go to state 68
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    NOT             shift and go to state 93
    INTEGER         shift and go to state 69
    FLOAT           shift and go to state 94
    STRING          shift and go to state 70
    NULL            shift and go to state 71
    FALSE           shift and go to state 72
    TRUE            shift and go to state 73
    ID              shift and go to state 88

    expression                     shift and go to state 111
    primary                        shift and go to state 85
    assign                         shift and go to state 86
    unary_op                       shift and go to state 87
    literal                        shift and go to state 65
    method_invocation              shift and go to state 89
    lhs                            shift and go to state 90
    field_access                   shift and go to state 61

state 84

    (55) primary -> LPAREN expression . RPAREN
    (69) expression -> expression . arith_op expression
    (70) expression -> expression . bool_op expression
    (73) arith_op -> . PLUS
    (74) arith_op -> . MINUS
    (75) arith_op -> . TIMES
    (76) arith_op -> . DIVIDE
    (77) bool_op -> . GREATER
    (78) bool_op -> . LESS
    (79) bool_op -> . GREATEREQ
    (80) bool_op -> . LESSEQ
    (81) bool_op -> . EQUAL
    (82) bool_op -> . NOTEQUAL
    (83) bool_op -> . AND
    (84) bool_op -> . OR

    RPAREN          shift and go to state 112
    PLUS            shift and go to state 115
    MINUS           shift and go to state 116
    TIMES           shift and go to state 117
    DIVIDE          shift and go to state 118
    GREATER         shift and go to state 119
    LESS            shift and go to state 120
    GREATEREQ       shift and go to state 121
    LESSEQ          shift and go to state 122
    EQUAL           shift and go to state 123
    NOTEQUAL        shift and go to state 124
    AND             shift and go to state 125
    OR              shift and go to state 126

    arith_op                       shift and go to state 113
    bool_op                        shift and go to state 114

state 85

    (67) expression -> primary .
    (63) field_access -> primary . DOT ID

    RPAREN          reduce using rule 67 (expression -> primary .)
    PLUS            reduce using rule 67 (expression -> primary .)
    MINUS           reduce using rule 67 (expression -> primary .)
    TIMES           reduce using rule 67 (expression -> primary .)
    DIVIDE          reduce using rule 67 (expression -> primary .)
    GREATER         reduce using rule 67 (expression -> primary .)
    LESS            reduce using rule 67 (expression -> primary .)
    GREATEREQ       reduce using rule 67 (expression -> primary .)
    LESSEQ          reduce using rule 67 (expression -> primary .)
    EQUAL           reduce using rule 67 (expression -> primary .)
    NOTEQUAL        reduce using rule 67 (expression -> primary .)
    AND             reduce using rule 67 (expression -> primary .)
    OR              reduce using rule 67 (expression -> primary .)
    SEMICOLON       reduce using rule 67 (expression -> primary .)
    COMMA           reduce using rule 67 (expression -> primary .)
    DOT             shift and go to state 104


state 86

    (68) expression -> assign .

    RPAREN          reduce using rule 68 (expression -> assign .)
    PLUS            reduce using rule 68 (expression -> assign .)
    MINUS           reduce using rule 68 (expression -> assign .)
    TIMES           reduce using rule 68 (expression -> assign .)
    DIVIDE          reduce using rule 68 (expression -> assign .)
    GREATER         reduce using rule 68 (expression -> assign .)
    LESS            reduce using rule 68 (expression -> assign .)
    GREATEREQ       reduce using rule 68 (expression -> assign .)
    LESSEQ          reduce using rule 68 (expression -> assign .)
    EQUAL           reduce using rule 68 (expression -> assign .)
    NOTEQUAL        reduce using rule 68 (expression -> assign .)
    AND             reduce using rule 68 (expression -> assign .)
    OR              reduce using rule 68 (expression -> assign .)
    SEMICOLON       reduce using rule 68 (expression -> assign .)
    COMMA           reduce using rule 68 (expression -> assign .)


state 87

    (71) expression -> unary_op . expression
    (67) expression -> . primary
    (68) expression -> . assign
    (69) expression -> . expression arith_op expression
    (70) expression -> . expression bool_op expression
    (71) expression -> . unary_op expression
    (52) primary -> . literal
    (53) primary -> . THIS
    (54) primary -> . SUPER
    (55) primary -> . LPAREN expression RPAREN
    (56) primary -> . NEW ID
    (57) primary -> . NEW ID LPAREN arguments RPAREN
    (58) primary -> . method_invocation
    (59) primary -> . lhs
    (72) assign -> . lhs SETEQUAL expression
    (85) unary_op -> . PLUS
    (86) unary_op -> . MINUS
    (87) unary_op -> . NOT
    (46) literal -> . INTEGER
    (47) literal -> . FLOAT
    (48) literal -> . STRING
    (49) literal -> . NULL
    (50) literal -> . FALSE
    (51) literal -> . TRUE
    (65) method_invocation -> . field_access LPAREN arguments RPAREN
    (66) method_invocation -> . field_access LPAREN RPAREN
    (62) lhs -> . field_access
    (63) field_access -> . primary DOT ID
    (64) field_access -> . ID

    THIS            shift and go to state 66
    SUPER           shift and go to state 67
    LPAREN          shift and go to state 47
    NEW             shift and go to state 68
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    NOT             shift and go to state 93
    INTEGER         shift and go to state 69
    FLOAT           shift and go to state 94
    STRING          shift and go to state 70
    NULL            shift and go to state 71
    FALSE           shift and go to state 72
    TRUE            shift and go to state 73
    ID              shift and go to state 88

    unary_op                       shift and go to state 87
    expression                     shift and go to state 127
    primary                        shift and go to state 85
    assign                         shift and go to state 86
    literal                        shift and go to state 65
    method_invocation              shift and go to state 89
    lhs                            shift and go to state 90
    field_access                   shift and go to state 61

state 88

    (64) field_access -> ID .

    LPAREN          reduce using rule 64 (field_access -> ID .)
    SETEQUAL        reduce using rule 64 (field_access -> ID .)
    DOT             reduce using rule 64 (field_access -> ID .)
    RPAREN          reduce using rule 64 (field_access -> ID .)
    PLUS            reduce using rule 64 (field_access -> ID .)
    MINUS           reduce using rule 64 (field_access -> ID .)
    TIMES           reduce using rule 64 (field_access -> ID .)
    DIVIDE          reduce using rule 64 (field_access -> ID .)
    GREATER         reduce using rule 64 (field_access -> ID .)
    LESS            reduce using rule 64 (field_access -> ID .)
    GREATEREQ       reduce using rule 64 (field_access -> ID .)
    LESSEQ          reduce using rule 64 (field_access -> ID .)
    EQUAL           reduce using rule 64 (field_access -> ID .)
    NOTEQUAL        reduce using rule 64 (field_access -> ID .)
    AND             reduce using rule 64 (field_access -> ID .)
    OR              reduce using rule 64 (field_access -> ID .)
    SEMICOLON       reduce using rule 64 (field_access -> ID .)
    COMMA           reduce using rule 64 (field_access -> ID .)


state 89

    (58) primary -> method_invocation .

    DOT             reduce using rule 58 (primary -> method_invocation .)
    RPAREN          reduce using rule 58 (primary -> method_invocation .)
    PLUS            reduce using rule 58 (primary -> method_invocation .)
    MINUS           reduce using rule 58 (primary -> method_invocation .)
    TIMES           reduce using rule 58 (primary -> method_invocation .)
    DIVIDE          reduce using rule 58 (primary -> method_invocation .)
    GREATER         reduce using rule 58 (primary -> method_invocation .)
    LESS            reduce using rule 58 (primary -> method_invocation .)
    GREATEREQ       reduce using rule 58 (primary -> method_invocation .)
    LESSEQ          reduce using rule 58 (primary -> method_invocation .)
    EQUAL           reduce using rule 58 (primary -> method_invocation .)
    NOTEQUAL        reduce using rule 58 (primary -> method_invocation .)
    AND             reduce using rule 58 (primary -> method_invocation .)
    OR              reduce using rule 58 (primary -> method_invocation .)
    SEMICOLON       reduce using rule 58 (primary -> method_invocation .)
    COMMA           reduce using rule 58 (primary -> method_invocation .)


state 90

    (59) primary -> lhs .
    (72) assign -> lhs . SETEQUAL expression

    DOT             reduce using rule 59 (primary -> lhs .)
    RPAREN          reduce using rule 59 (primary -> lhs .)
    PLUS            reduce using rule 59 (primary -> lhs .)
    MINUS           reduce using rule 59 (primary -> lhs .)
    TIMES           reduce using rule 59 (primary -> lhs .)
    DIVIDE          reduce using rule 59 (primary -> lhs .)
    GREATER         reduce using rule 59 (primary -> lhs .)
    LESS            reduce using rule 59 (primary -> lhs .)
    GREATEREQ       reduce using rule 59 (primary -> lhs .)
    LESSEQ          reduce using rule 59 (primary -> lhs .)
    EQUAL           reduce using rule 59 (primary -> lhs .)
    NOTEQUAL        reduce using rule 59 (primary -> lhs .)
    AND             reduce using rule 59 (primary -> lhs .)
    OR              reduce using rule 59 (primary -> lhs .)
    SEMICOLON       reduce using rule 59 (primary -> lhs .)
    COMMA           reduce using rule 59 (primary -> lhs .)
    SETEQUAL        shift and go to state 102


state 91

    (85) unary_op -> PLUS .

    THIS            reduce using rule 85 (unary_op -> PLUS .)
    SUPER           reduce using rule 85 (unary_op -> PLUS .)
    LPAREN          reduce using rule 85 (unary_op -> PLUS .)
    NEW             reduce using rule 85 (unary_op -> PLUS .)
    PLUS            reduce using rule 85 (unary_op -> PLUS .)
    MINUS           reduce using rule 85 (unary_op -> PLUS .)
    NOT             reduce using rule 85 (unary_op -> PLUS .)
    INTEGER         reduce using rule 85 (unary_op -> PLUS .)
    FLOAT           reduce using rule 85 (unary_op -> PLUS .)
    STRING          reduce using rule 85 (unary_op -> PLUS .)
    NULL            reduce using rule 85 (unary_op -> PLUS .)
    FALSE           reduce using rule 85 (unary_op -> PLUS .)
    TRUE            reduce using rule 85 (unary_op -> PLUS .)
    ID              reduce using rule 85 (unary_op -> PLUS .)


state 92

    (86) unary_op -> MINUS .

    THIS            reduce using rule 86 (unary_op -> MINUS .)
    SUPER           reduce using rule 86 (unary_op -> MINUS .)
    LPAREN          reduce using rule 86 (unary_op -> MINUS .)
    NEW             reduce using rule 86 (unary_op -> MINUS .)
    PLUS            reduce using rule 86 (unary_op -> MINUS .)
    MINUS           reduce using rule 86 (unary_op -> MINUS .)
    NOT             reduce using rule 86 (unary_op -> MINUS .)
    INTEGER         reduce using rule 86 (unary_op -> MINUS .)
    FLOAT           reduce using rule 86 (unary_op -> MINUS .)
    STRING          reduce using rule 86 (unary_op -> MINUS .)
    NULL            reduce using rule 86 (unary_op -> MINUS .)
    FALSE           reduce using rule 86 (unary_op -> MINUS .)
    TRUE            reduce using rule 86 (unary_op -> MINUS .)
    ID              reduce using rule 86 (unary_op -> MINUS .)


state 93

    (87) unary_op -> NOT .

    THIS            reduce using rule 87 (unary_op -> NOT .)
    SUPER           reduce using rule 87 (unary_op -> NOT .)
    LPAREN          reduce using rule 87 (unary_op -> NOT .)
    NEW             reduce using rule 87 (unary_op -> NOT .)
    PLUS            reduce using rule 87 (unary_op -> NOT .)
    MINUS           reduce using rule 87 (unary_op -> NOT .)
    NOT             reduce using rule 87 (unary_op -> NOT .)
    INTEGER         reduce using rule 87 (unary_op -> NOT .)
    FLOAT           reduce using rule 87 (unary_op -> NOT .)
    STRING          reduce using rule 87 (unary_op -> NOT .)
    NULL            reduce using rule 87 (unary_op -> NOT .)
    FALSE           reduce using rule 87 (unary_op -> NOT .)
    TRUE            reduce using rule 87 (unary_op -> NOT .)
    ID              reduce using rule 87 (unary_op -> NOT .)


state 94

    (47) literal -> FLOAT .

    DOT             reduce using rule 47 (literal -> FLOAT .)
    RPAREN          reduce using rule 47 (literal -> FLOAT .)
    PLUS            reduce using rule 47 (literal -> FLOAT .)
    MINUS           reduce using rule 47 (literal -> FLOAT .)
    TIMES           reduce using rule 47 (literal -> FLOAT .)
    DIVIDE          reduce using rule 47 (literal -> FLOAT .)
    GREATER         reduce using rule 47 (literal -> FLOAT .)
    LESS            reduce using rule 47 (literal -> FLOAT .)
    GREATEREQ       reduce using rule 47 (literal -> FLOAT .)
    LESSEQ          reduce using rule 47 (literal -> FLOAT .)
    EQUAL           reduce using rule 47 (literal -> FLOAT .)
    NOTEQUAL        reduce using rule 47 (literal -> FLOAT .)
    AND             reduce using rule 47 (literal -> FLOAT .)
    OR              reduce using rule 47 (literal -> FLOAT .)
    SEMICOLON       reduce using rule 47 (literal -> FLOAT .)
    COMMA           reduce using rule 47 (literal -> FLOAT .)


state 95

    (36) stmt -> WHILE LPAREN . expression RPAREN stmt
    (67) expression -> . primary
    (68) expression -> . assign
    (69) expression -> . expression arith_op expression
    (70) expression -> . expression bool_op expression
    (71) expression -> . unary_op expression
    (52) primary -> . literal
    (53) primary -> . THIS
    (54) primary -> . SUPER
    (55) primary -> . LPAREN expression RPAREN
    (56) primary -> . NEW ID
    (57) primary -> . NEW ID LPAREN arguments RPAREN
    (58) primary -> . method_invocation
    (59) primary -> . lhs
    (72) assign -> . lhs SETEQUAL expression
    (85) unary_op -> . PLUS
    (86) unary_op -> . MINUS
    (87) unary_op -> . NOT
    (46) literal -> . INTEGER
    (47) literal -> . FLOAT
    (48) literal -> . STRING
    (49) literal -> . NULL
    (50) literal -> . FALSE
    (51) literal -> . TRUE
    (65) method_invocation -> . field_access LPAREN arguments RPAREN
    (66) method_invocation -> . field_access LPAREN RPAREN
    (62) lhs -> . field_access
    (63) field_access -> . primary DOT ID
    (64) field_access -> . ID

    THIS            shift and go to state 66
    SUPER           shift and go to state 67
    LPAREN          shift and go to state 47
    NEW             shift and go to state 68
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    NOT             shift and go to state 93
    INTEGER         shift and go to state 69
    FLOAT           shift and go to state 94
    STRING          shift and go to state 70
    NULL            shift and go to state 71
    FALSE           shift and go to state 72
    TRUE            shift and go to state 73
    ID              shift and go to state 88

    expression                     shift and go to state 128
    primary                        shift and go to state 85
    assign                         shift and go to state 86
    unary_op                       shift and go to state 87
    literal                        shift and go to state 65
    method_invocation              shift and go to state 89
    lhs                            shift and go to state 90
    field_access                   shift and go to state 61

state 96

    (37) stmt -> FOR LPAREN . stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (88) stmt_expression -> . assign
    (89) stmt_expression -> . method_invocation
    (72) assign -> . lhs SETEQUAL expression
    (65) method_invocation -> . field_access LPAREN arguments RPAREN
    (66) method_invocation -> . field_access LPAREN RPAREN
    (62) lhs -> . field_access
    (63) field_access -> . primary DOT ID
    (64) field_access -> . ID
    (52) primary -> . literal
    (53) primary -> . THIS
    (54) primary -> . SUPER
    (55) primary -> . LPAREN expression RPAREN
    (56) primary -> . NEW ID
    (57) primary -> . NEW ID LPAREN arguments RPAREN
    (58) primary -> . method_invocation
    (59) primary -> . lhs
    (46) literal -> . INTEGER
    (47) literal -> . FLOAT
    (48) literal -> . STRING
    (49) literal -> . NULL
    (50) literal -> . FALSE
    (51) literal -> . TRUE

    ID              shift and go to state 88
    THIS            shift and go to state 66
    SUPER           shift and go to state 67
    LPAREN          shift and go to state 47
    NEW             shift and go to state 68
    INTEGER         shift and go to state 69
    FLOAT           shift and go to state 94
    STRING          shift and go to state 70
    NULL            shift and go to state 71
    FALSE           shift and go to state 72
    TRUE            shift and go to state 73

    stmt_expression                shift and go to state 129
    assign                         shift and go to state 57
    method_invocation              shift and go to state 58
    lhs                            shift and go to state 60
    field_access                   shift and go to state 61
    primary                        shift and go to state 64
    literal                        shift and go to state 65

state 97

    (40) stmt -> stmt_expression SEMICOLON .

    RCURLY          reduce using rule 40 (stmt -> stmt_expression SEMICOLON .)
    ELSE            reduce using rule 40 (stmt -> stmt_expression SEMICOLON .)


state 98

    (38) stmt -> RETURN expression . SEMICOLON
    (69) expression -> expression . arith_op expression
    (70) expression -> expression . bool_op expression
    (73) arith_op -> . PLUS
    (74) arith_op -> . MINUS
    (75) arith_op -> . TIMES
    (76) arith_op -> . DIVIDE
    (77) bool_op -> . GREATER
    (78) bool_op -> . LESS
    (79) bool_op -> . GREATEREQ
    (80) bool_op -> . LESSEQ
    (81) bool_op -> . EQUAL
    (82) bool_op -> . NOTEQUAL
    (83) bool_op -> . AND
    (84) bool_op -> . OR

    SEMICOLON       shift and go to state 130
    PLUS            shift and go to state 115
    MINUS           shift and go to state 116
    TIMES           shift and go to state 117
    DIVIDE          shift and go to state 118
    GREATER         shift and go to state 119
    LESS            shift and go to state 120
    GREATEREQ       shift and go to state 121
    LESSEQ          shift and go to state 122
    EQUAL           shift and go to state 123
    NOTEQUAL        shift and go to state 124
    AND             shift and go to state 125
    OR              shift and go to state 126

    arith_op                       shift and go to state 113
    bool_op                        shift and go to state 114

state 99

    (39) stmt -> RETURN SEMICOLON .

    RCURLY          reduce using rule 39 (stmt -> RETURN SEMICOLON .)
    ELSE            reduce using rule 39 (stmt -> RETURN SEMICOLON .)


state 100

    (41) stmt -> BREAK SEMICOLON .

    RCURLY          reduce using rule 41 (stmt -> BREAK SEMICOLON .)
    ELSE            reduce using rule 41 (stmt -> BREAK SEMICOLON .)


state 101

    (42) stmt -> CONTINUE SEMICOLON .

    RCURLY          reduce using rule 42 (stmt -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 42 (stmt -> CONTINUE SEMICOLON .)


state 102

    (72) assign -> lhs SETEQUAL . expression
    (67) expression -> . primary
    (68) expression -> . assign
    (69) expression -> . expression arith_op expression
    (70) expression -> . expression bool_op expression
    (71) expression -> . unary_op expression
    (52) primary -> . literal
    (53) primary -> . THIS
    (54) primary -> . SUPER
    (55) primary -> . LPAREN expression RPAREN
    (56) primary -> . NEW ID
    (57) primary -> . NEW ID LPAREN arguments RPAREN
    (58) primary -> . method_invocation
    (59) primary -> . lhs
    (72) assign -> . lhs SETEQUAL expression
    (85) unary_op -> . PLUS
    (86) unary_op -> . MINUS
    (87) unary_op -> . NOT
    (46) literal -> . INTEGER
    (47) literal -> . FLOAT
    (48) literal -> . STRING
    (49) literal -> . NULL
    (50) literal -> . FALSE
    (51) literal -> . TRUE
    (65) method_invocation -> . field_access LPAREN arguments RPAREN
    (66) method_invocation -> . field_access LPAREN RPAREN
    (62) lhs -> . field_access
    (63) field_access -> . primary DOT ID
    (64) field_access -> . ID

    THIS            shift and go to state 66
    SUPER           shift and go to state 67
    LPAREN          shift and go to state 47
    NEW             shift and go to state 68
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    NOT             shift and go to state 93
    INTEGER         shift and go to state 69
    FLOAT           shift and go to state 94
    STRING          shift and go to state 70
    NULL            shift and go to state 71
    FALSE           shift and go to state 72
    TRUE            shift and go to state 73
    ID              shift and go to state 88

    lhs                            shift and go to state 90
    expression                     shift and go to state 131
    primary                        shift and go to state 85
    assign                         shift and go to state 86
    unary_op                       shift and go to state 87
    literal                        shift and go to state 65
    method_invocation              shift and go to state 89
    field_access                   shift and go to state 61

state 103

    (65) method_invocation -> field_access LPAREN . arguments RPAREN
    (66) method_invocation -> field_access LPAREN . RPAREN
    (60) arguments -> . expression
    (61) arguments -> . expression COMMA arguments
    (67) expression -> . primary
    (68) expression -> . assign
    (69) expression -> . expression arith_op expression
    (70) expression -> . expression bool_op expression
    (71) expression -> . unary_op expression
    (52) primary -> . literal
    (53) primary -> . THIS
    (54) primary -> . SUPER
    (55) primary -> . LPAREN expression RPAREN
    (56) primary -> . NEW ID
    (57) primary -> . NEW ID LPAREN arguments RPAREN
    (58) primary -> . method_invocation
    (59) primary -> . lhs
    (72) assign -> . lhs SETEQUAL expression
    (85) unary_op -> . PLUS
    (86) unary_op -> . MINUS
    (87) unary_op -> . NOT
    (46) literal -> . INTEGER
    (47) literal -> . FLOAT
    (48) literal -> . STRING
    (49) literal -> . NULL
    (50) literal -> . FALSE
    (51) literal -> . TRUE
    (65) method_invocation -> . field_access LPAREN arguments RPAREN
    (66) method_invocation -> . field_access LPAREN RPAREN
    (62) lhs -> . field_access
    (63) field_access -> . primary DOT ID
    (64) field_access -> . ID

    RPAREN          shift and go to state 133
    THIS            shift and go to state 66
    SUPER           shift and go to state 67
    LPAREN          shift and go to state 47
    NEW             shift and go to state 68
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    NOT             shift and go to state 93
    INTEGER         shift and go to state 69
    FLOAT           shift and go to state 94
    STRING          shift and go to state 70
    NULL            shift and go to state 71
    FALSE           shift and go to state 72
    TRUE            shift and go to state 73
    ID              shift and go to state 88

    field_access                   shift and go to state 61
    arguments                      shift and go to state 132
    expression                     shift and go to state 134
    primary                        shift and go to state 85
    assign                         shift and go to state 86
    unary_op                       shift and go to state 87
    literal                        shift and go to state 65
    method_invocation              shift and go to state 89
    lhs                            shift and go to state 90

state 104

    (63) field_access -> primary DOT . ID

    ID              shift and go to state 135


state 105

    (56) primary -> NEW ID .
    (57) primary -> NEW ID . LPAREN arguments RPAREN

    DOT             reduce using rule 56 (primary -> NEW ID .)
    RPAREN          reduce using rule 56 (primary -> NEW ID .)
    PLUS            reduce using rule 56 (primary -> NEW ID .)
    MINUS           reduce using rule 56 (primary -> NEW ID .)
    TIMES           reduce using rule 56 (primary -> NEW ID .)
    DIVIDE          reduce using rule 56 (primary -> NEW ID .)
    GREATER         reduce using rule 56 (primary -> NEW ID .)
    LESS            reduce using rule 56 (primary -> NEW ID .)
    GREATEREQ       reduce using rule 56 (primary -> NEW ID .)
    LESSEQ          reduce using rule 56 (primary -> NEW ID .)
    EQUAL           reduce using rule 56 (primary -> NEW ID .)
    NOTEQUAL        reduce using rule 56 (primary -> NEW ID .)
    AND             reduce using rule 56 (primary -> NEW ID .)
    OR              reduce using rule 56 (primary -> NEW ID .)
    SEMICOLON       reduce using rule 56 (primary -> NEW ID .)
    COMMA           reduce using rule 56 (primary -> NEW ID .)
    LPAREN          shift and go to state 136


state 106

    (31) formals -> formal_param COMMA formals .

    LCURLY          reduce using rule 31 (formals -> formal_param COMMA formals .)
    RPAREN          reduce using rule 31 (formals -> formal_param COMMA formals .)


state 107

    (26) method_decl -> modifier VOID ID LPAREN RPAREN . block
    (33) block -> . LCURLY stmt RCURLY

    LCURLY          shift and go to state 36

    block                          shift and go to state 137

state 108

    (27) method_decl -> modifier VOID ID LPAREN formals . RPAREN block

    RPAREN          shift and go to state 138


state 109

    (24) method_decl -> modifier type ID LPAREN RPAREN block .

    RCURLY          reduce using rule 24 (method_decl -> modifier type ID LPAREN RPAREN block .)
    PUBLIC          reduce using rule 24 (method_decl -> modifier type ID LPAREN RPAREN block .)
    PRIVATE         reduce using rule 24 (method_decl -> modifier type ID LPAREN RPAREN block .)
    VOID            reduce using rule 24 (method_decl -> modifier type ID LPAREN RPAREN block .)
    ID              reduce using rule 24 (method_decl -> modifier type ID LPAREN RPAREN block .)
    INT             reduce using rule 24 (method_decl -> modifier type ID LPAREN RPAREN block .)
    FLOAT           reduce using rule 24 (method_decl -> modifier type ID LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 24 (method_decl -> modifier type ID LPAREN RPAREN block .)


state 110

    (25) method_decl -> modifier type ID LPAREN formals RPAREN . block
    (33) block -> . LCURLY stmt RCURLY

    LCURLY          shift and go to state 36

    block                          shift and go to state 139

state 111

    (34) stmt -> IF LPAREN expression . RPAREN stmt
    (35) stmt -> IF LPAREN expression . RPAREN stmt ELSE stmt
    (69) expression -> expression . arith_op expression
    (70) expression -> expression . bool_op expression
    (73) arith_op -> . PLUS
    (74) arith_op -> . MINUS
    (75) arith_op -> . TIMES
    (76) arith_op -> . DIVIDE
    (77) bool_op -> . GREATER
    (78) bool_op -> . LESS
    (79) bool_op -> . GREATEREQ
    (80) bool_op -> . LESSEQ
    (81) bool_op -> . EQUAL
    (82) bool_op -> . NOTEQUAL
    (83) bool_op -> . AND
    (84) bool_op -> . OR

    RPAREN          shift and go to state 140
    PLUS            shift and go to state 115
    MINUS           shift and go to state 116
    TIMES           shift and go to state 117
    DIVIDE          shift and go to state 118
    GREATER         shift and go to state 119
    LESS            shift and go to state 120
    GREATEREQ       shift and go to state 121
    LESSEQ          shift and go to state 122
    EQUAL           shift and go to state 123
    NOTEQUAL        shift and go to state 124
    AND             shift and go to state 125
    OR              shift and go to state 126

    arith_op                       shift and go to state 113
    bool_op                        shift and go to state 114

state 112

    (55) primary -> LPAREN expression RPAREN .

    DOT             reduce using rule 55 (primary -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 55 (primary -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 55 (primary -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 55 (primary -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 55 (primary -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 55 (primary -> LPAREN expression RPAREN .)
    GREATER         reduce using rule 55 (primary -> LPAREN expression RPAREN .)
    LESS            reduce using rule 55 (primary -> LPAREN expression RPAREN .)
    GREATEREQ       reduce using rule 55 (primary -> LPAREN expression RPAREN .)
    LESSEQ          reduce using rule 55 (primary -> LPAREN expression RPAREN .)
    EQUAL           reduce using rule 55 (primary -> LPAREN expression RPAREN .)
    NOTEQUAL        reduce using rule 55 (primary -> LPAREN expression RPAREN .)
    AND             reduce using rule 55 (primary -> LPAREN expression RPAREN .)
    OR              reduce using rule 55 (primary -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 55 (primary -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 55 (primary -> LPAREN expression RPAREN .)


state 113

    (69) expression -> expression arith_op . expression
    (67) expression -> . primary
    (68) expression -> . assign
    (69) expression -> . expression arith_op expression
    (70) expression -> . expression bool_op expression
    (71) expression -> . unary_op expression
    (52) primary -> . literal
    (53) primary -> . THIS
    (54) primary -> . SUPER
    (55) primary -> . LPAREN expression RPAREN
    (56) primary -> . NEW ID
    (57) primary -> . NEW ID LPAREN arguments RPAREN
    (58) primary -> . method_invocation
    (59) primary -> . lhs
    (72) assign -> . lhs SETEQUAL expression
    (85) unary_op -> . PLUS
    (86) unary_op -> . MINUS
    (87) unary_op -> . NOT
    (46) literal -> . INTEGER
    (47) literal -> . FLOAT
    (48) literal -> . STRING
    (49) literal -> . NULL
    (50) literal -> . FALSE
    (51) literal -> . TRUE
    (65) method_invocation -> . field_access LPAREN arguments RPAREN
    (66) method_invocation -> . field_access LPAREN RPAREN
    (62) lhs -> . field_access
    (63) field_access -> . primary DOT ID
    (64) field_access -> . ID

    THIS            shift and go to state 66
    SUPER           shift and go to state 67
    LPAREN          shift and go to state 47
    NEW             shift and go to state 68
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    NOT             shift and go to state 93
    INTEGER         shift and go to state 69
    FLOAT           shift and go to state 94
    STRING          shift and go to state 70
    NULL            shift and go to state 71
    FALSE           shift and go to state 72
    TRUE            shift and go to state 73
    ID              shift and go to state 88

    expression                     shift and go to state 141
    primary                        shift and go to state 85
    assign                         shift and go to state 86
    unary_op                       shift and go to state 87
    literal                        shift and go to state 65
    method_invocation              shift and go to state 89
    lhs                            shift and go to state 90
    field_access                   shift and go to state 61

state 114

    (70) expression -> expression bool_op . expression
    (67) expression -> . primary
    (68) expression -> . assign
    (69) expression -> . expression arith_op expression
    (70) expression -> . expression bool_op expression
    (71) expression -> . unary_op expression
    (52) primary -> . literal
    (53) primary -> . THIS
    (54) primary -> . SUPER
    (55) primary -> . LPAREN expression RPAREN
    (56) primary -> . NEW ID
    (57) primary -> . NEW ID LPAREN arguments RPAREN
    (58) primary -> . method_invocation
    (59) primary -> . lhs
    (72) assign -> . lhs SETEQUAL expression
    (85) unary_op -> . PLUS
    (86) unary_op -> . MINUS
    (87) unary_op -> . NOT
    (46) literal -> . INTEGER
    (47) literal -> . FLOAT
    (48) literal -> . STRING
    (49) literal -> . NULL
    (50) literal -> . FALSE
    (51) literal -> . TRUE
    (65) method_invocation -> . field_access LPAREN arguments RPAREN
    (66) method_invocation -> . field_access LPAREN RPAREN
    (62) lhs -> . field_access
    (63) field_access -> . primary DOT ID
    (64) field_access -> . ID

    THIS            shift and go to state 66
    SUPER           shift and go to state 67
    LPAREN          shift and go to state 47
    NEW             shift and go to state 68
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    NOT             shift and go to state 93
    INTEGER         shift and go to state 69
    FLOAT           shift and go to state 94
    STRING          shift and go to state 70
    NULL            shift and go to state 71
    FALSE           shift and go to state 72
    TRUE            shift and go to state 73
    ID              shift and go to state 88

    expression                     shift and go to state 142
    primary                        shift and go to state 85
    assign                         shift and go to state 86
    unary_op                       shift and go to state 87
    literal                        shift and go to state 65
    method_invocation              shift and go to state 89
    lhs                            shift and go to state 90
    field_access                   shift and go to state 61

state 115

    (73) arith_op -> PLUS .

    THIS            reduce using rule 73 (arith_op -> PLUS .)
    SUPER           reduce using rule 73 (arith_op -> PLUS .)
    LPAREN          reduce using rule 73 (arith_op -> PLUS .)
    NEW             reduce using rule 73 (arith_op -> PLUS .)
    PLUS            reduce using rule 73 (arith_op -> PLUS .)
    MINUS           reduce using rule 73 (arith_op -> PLUS .)
    NOT             reduce using rule 73 (arith_op -> PLUS .)
    INTEGER         reduce using rule 73 (arith_op -> PLUS .)
    FLOAT           reduce using rule 73 (arith_op -> PLUS .)
    STRING          reduce using rule 73 (arith_op -> PLUS .)
    NULL            reduce using rule 73 (arith_op -> PLUS .)
    FALSE           reduce using rule 73 (arith_op -> PLUS .)
    TRUE            reduce using rule 73 (arith_op -> PLUS .)
    ID              reduce using rule 73 (arith_op -> PLUS .)


state 116

    (74) arith_op -> MINUS .

    THIS            reduce using rule 74 (arith_op -> MINUS .)
    SUPER           reduce using rule 74 (arith_op -> MINUS .)
    LPAREN          reduce using rule 74 (arith_op -> MINUS .)
    NEW             reduce using rule 74 (arith_op -> MINUS .)
    PLUS            reduce using rule 74 (arith_op -> MINUS .)
    MINUS           reduce using rule 74 (arith_op -> MINUS .)
    NOT             reduce using rule 74 (arith_op -> MINUS .)
    INTEGER         reduce using rule 74 (arith_op -> MINUS .)
    FLOAT           reduce using rule 74 (arith_op -> MINUS .)
    STRING          reduce using rule 74 (arith_op -> MINUS .)
    NULL            reduce using rule 74 (arith_op -> MINUS .)
    FALSE           reduce using rule 74 (arith_op -> MINUS .)
    TRUE            reduce using rule 74 (arith_op -> MINUS .)
    ID              reduce using rule 74 (arith_op -> MINUS .)


state 117

    (75) arith_op -> TIMES .

    THIS            reduce using rule 75 (arith_op -> TIMES .)
    SUPER           reduce using rule 75 (arith_op -> TIMES .)
    LPAREN          reduce using rule 75 (arith_op -> TIMES .)
    NEW             reduce using rule 75 (arith_op -> TIMES .)
    PLUS            reduce using rule 75 (arith_op -> TIMES .)
    MINUS           reduce using rule 75 (arith_op -> TIMES .)
    NOT             reduce using rule 75 (arith_op -> TIMES .)
    INTEGER         reduce using rule 75 (arith_op -> TIMES .)
    FLOAT           reduce using rule 75 (arith_op -> TIMES .)
    STRING          reduce using rule 75 (arith_op -> TIMES .)
    NULL            reduce using rule 75 (arith_op -> TIMES .)
    FALSE           reduce using rule 75 (arith_op -> TIMES .)
    TRUE            reduce using rule 75 (arith_op -> TIMES .)
    ID              reduce using rule 75 (arith_op -> TIMES .)


state 118

    (76) arith_op -> DIVIDE .

    THIS            reduce using rule 76 (arith_op -> DIVIDE .)
    SUPER           reduce using rule 76 (arith_op -> DIVIDE .)
    LPAREN          reduce using rule 76 (arith_op -> DIVIDE .)
    NEW             reduce using rule 76 (arith_op -> DIVIDE .)
    PLUS            reduce using rule 76 (arith_op -> DIVIDE .)
    MINUS           reduce using rule 76 (arith_op -> DIVIDE .)
    NOT             reduce using rule 76 (arith_op -> DIVIDE .)
    INTEGER         reduce using rule 76 (arith_op -> DIVIDE .)
    FLOAT           reduce using rule 76 (arith_op -> DIVIDE .)
    STRING          reduce using rule 76 (arith_op -> DIVIDE .)
    NULL            reduce using rule 76 (arith_op -> DIVIDE .)
    FALSE           reduce using rule 76 (arith_op -> DIVIDE .)
    TRUE            reduce using rule 76 (arith_op -> DIVIDE .)
    ID              reduce using rule 76 (arith_op -> DIVIDE .)


state 119

    (77) bool_op -> GREATER .

    THIS            reduce using rule 77 (bool_op -> GREATER .)
    SUPER           reduce using rule 77 (bool_op -> GREATER .)
    LPAREN          reduce using rule 77 (bool_op -> GREATER .)
    NEW             reduce using rule 77 (bool_op -> GREATER .)
    PLUS            reduce using rule 77 (bool_op -> GREATER .)
    MINUS           reduce using rule 77 (bool_op -> GREATER .)
    NOT             reduce using rule 77 (bool_op -> GREATER .)
    INTEGER         reduce using rule 77 (bool_op -> GREATER .)
    FLOAT           reduce using rule 77 (bool_op -> GREATER .)
    STRING          reduce using rule 77 (bool_op -> GREATER .)
    NULL            reduce using rule 77 (bool_op -> GREATER .)
    FALSE           reduce using rule 77 (bool_op -> GREATER .)
    TRUE            reduce using rule 77 (bool_op -> GREATER .)
    ID              reduce using rule 77 (bool_op -> GREATER .)


state 120

    (78) bool_op -> LESS .

    THIS            reduce using rule 78 (bool_op -> LESS .)
    SUPER           reduce using rule 78 (bool_op -> LESS .)
    LPAREN          reduce using rule 78 (bool_op -> LESS .)
    NEW             reduce using rule 78 (bool_op -> LESS .)
    PLUS            reduce using rule 78 (bool_op -> LESS .)
    MINUS           reduce using rule 78 (bool_op -> LESS .)
    NOT             reduce using rule 78 (bool_op -> LESS .)
    INTEGER         reduce using rule 78 (bool_op -> LESS .)
    FLOAT           reduce using rule 78 (bool_op -> LESS .)
    STRING          reduce using rule 78 (bool_op -> LESS .)
    NULL            reduce using rule 78 (bool_op -> LESS .)
    FALSE           reduce using rule 78 (bool_op -> LESS .)
    TRUE            reduce using rule 78 (bool_op -> LESS .)
    ID              reduce using rule 78 (bool_op -> LESS .)


state 121

    (79) bool_op -> GREATEREQ .

    THIS            reduce using rule 79 (bool_op -> GREATEREQ .)
    SUPER           reduce using rule 79 (bool_op -> GREATEREQ .)
    LPAREN          reduce using rule 79 (bool_op -> GREATEREQ .)
    NEW             reduce using rule 79 (bool_op -> GREATEREQ .)
    PLUS            reduce using rule 79 (bool_op -> GREATEREQ .)
    MINUS           reduce using rule 79 (bool_op -> GREATEREQ .)
    NOT             reduce using rule 79 (bool_op -> GREATEREQ .)
    INTEGER         reduce using rule 79 (bool_op -> GREATEREQ .)
    FLOAT           reduce using rule 79 (bool_op -> GREATEREQ .)
    STRING          reduce using rule 79 (bool_op -> GREATEREQ .)
    NULL            reduce using rule 79 (bool_op -> GREATEREQ .)
    FALSE           reduce using rule 79 (bool_op -> GREATEREQ .)
    TRUE            reduce using rule 79 (bool_op -> GREATEREQ .)
    ID              reduce using rule 79 (bool_op -> GREATEREQ .)


state 122

    (80) bool_op -> LESSEQ .

    THIS            reduce using rule 80 (bool_op -> LESSEQ .)
    SUPER           reduce using rule 80 (bool_op -> LESSEQ .)
    LPAREN          reduce using rule 80 (bool_op -> LESSEQ .)
    NEW             reduce using rule 80 (bool_op -> LESSEQ .)
    PLUS            reduce using rule 80 (bool_op -> LESSEQ .)
    MINUS           reduce using rule 80 (bool_op -> LESSEQ .)
    NOT             reduce using rule 80 (bool_op -> LESSEQ .)
    INTEGER         reduce using rule 80 (bool_op -> LESSEQ .)
    FLOAT           reduce using rule 80 (bool_op -> LESSEQ .)
    STRING          reduce using rule 80 (bool_op -> LESSEQ .)
    NULL            reduce using rule 80 (bool_op -> LESSEQ .)
    FALSE           reduce using rule 80 (bool_op -> LESSEQ .)
    TRUE            reduce using rule 80 (bool_op -> LESSEQ .)
    ID              reduce using rule 80 (bool_op -> LESSEQ .)


state 123

    (81) bool_op -> EQUAL .

    THIS            reduce using rule 81 (bool_op -> EQUAL .)
    SUPER           reduce using rule 81 (bool_op -> EQUAL .)
    LPAREN          reduce using rule 81 (bool_op -> EQUAL .)
    NEW             reduce using rule 81 (bool_op -> EQUAL .)
    PLUS            reduce using rule 81 (bool_op -> EQUAL .)
    MINUS           reduce using rule 81 (bool_op -> EQUAL .)
    NOT             reduce using rule 81 (bool_op -> EQUAL .)
    INTEGER         reduce using rule 81 (bool_op -> EQUAL .)
    FLOAT           reduce using rule 81 (bool_op -> EQUAL .)
    STRING          reduce using rule 81 (bool_op -> EQUAL .)
    NULL            reduce using rule 81 (bool_op -> EQUAL .)
    FALSE           reduce using rule 81 (bool_op -> EQUAL .)
    TRUE            reduce using rule 81 (bool_op -> EQUAL .)
    ID              reduce using rule 81 (bool_op -> EQUAL .)


state 124

    (82) bool_op -> NOTEQUAL .

    THIS            reduce using rule 82 (bool_op -> NOTEQUAL .)
    SUPER           reduce using rule 82 (bool_op -> NOTEQUAL .)
    LPAREN          reduce using rule 82 (bool_op -> NOTEQUAL .)
    NEW             reduce using rule 82 (bool_op -> NOTEQUAL .)
    PLUS            reduce using rule 82 (bool_op -> NOTEQUAL .)
    MINUS           reduce using rule 82 (bool_op -> NOTEQUAL .)
    NOT             reduce using rule 82 (bool_op -> NOTEQUAL .)
    INTEGER         reduce using rule 82 (bool_op -> NOTEQUAL .)
    FLOAT           reduce using rule 82 (bool_op -> NOTEQUAL .)
    STRING          reduce using rule 82 (bool_op -> NOTEQUAL .)
    NULL            reduce using rule 82 (bool_op -> NOTEQUAL .)
    FALSE           reduce using rule 82 (bool_op -> NOTEQUAL .)
    TRUE            reduce using rule 82 (bool_op -> NOTEQUAL .)
    ID              reduce using rule 82 (bool_op -> NOTEQUAL .)


state 125

    (83) bool_op -> AND .

    THIS            reduce using rule 83 (bool_op -> AND .)
    SUPER           reduce using rule 83 (bool_op -> AND .)
    LPAREN          reduce using rule 83 (bool_op -> AND .)
    NEW             reduce using rule 83 (bool_op -> AND .)
    PLUS            reduce using rule 83 (bool_op -> AND .)
    MINUS           reduce using rule 83 (bool_op -> AND .)
    NOT             reduce using rule 83 (bool_op -> AND .)
    INTEGER         reduce using rule 83 (bool_op -> AND .)
    FLOAT           reduce using rule 83 (bool_op -> AND .)
    STRING          reduce using rule 83 (bool_op -> AND .)
    NULL            reduce using rule 83 (bool_op -> AND .)
    FALSE           reduce using rule 83 (bool_op -> AND .)
    TRUE            reduce using rule 83 (bool_op -> AND .)
    ID              reduce using rule 83 (bool_op -> AND .)


state 126

    (84) bool_op -> OR .

    THIS            reduce using rule 84 (bool_op -> OR .)
    SUPER           reduce using rule 84 (bool_op -> OR .)
    LPAREN          reduce using rule 84 (bool_op -> OR .)
    NEW             reduce using rule 84 (bool_op -> OR .)
    PLUS            reduce using rule 84 (bool_op -> OR .)
    MINUS           reduce using rule 84 (bool_op -> OR .)
    NOT             reduce using rule 84 (bool_op -> OR .)
    INTEGER         reduce using rule 84 (bool_op -> OR .)
    FLOAT           reduce using rule 84 (bool_op -> OR .)
    STRING          reduce using rule 84 (bool_op -> OR .)
    NULL            reduce using rule 84 (bool_op -> OR .)
    FALSE           reduce using rule 84 (bool_op -> OR .)
    TRUE            reduce using rule 84 (bool_op -> OR .)
    ID              reduce using rule 84 (bool_op -> OR .)


state 127

    (71) expression -> unary_op expression .
    (69) expression -> expression . arith_op expression
    (70) expression -> expression . bool_op expression
    (73) arith_op -> . PLUS
    (74) arith_op -> . MINUS
    (75) arith_op -> . TIMES
    (76) arith_op -> . DIVIDE
    (77) bool_op -> . GREATER
    (78) bool_op -> . LESS
    (79) bool_op -> . GREATEREQ
    (80) bool_op -> . LESSEQ
    (81) bool_op -> . EQUAL
    (82) bool_op -> . NOTEQUAL
    (83) bool_op -> . AND
    (84) bool_op -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 71 (expression -> unary_op expression .)
    SEMICOLON       reduce using rule 71 (expression -> unary_op expression .)
    COMMA           reduce using rule 71 (expression -> unary_op expression .)
    PLUS            shift and go to state 115
    MINUS           shift and go to state 116
    TIMES           shift and go to state 117
    DIVIDE          shift and go to state 118
    GREATER         shift and go to state 119
    LESS            shift and go to state 120
    GREATEREQ       shift and go to state 121
    LESSEQ          shift and go to state 122
    EQUAL           shift and go to state 123
    NOTEQUAL        shift and go to state 124
    AND             shift and go to state 125
    OR              shift and go to state 126

  ! PLUS            [ reduce using rule 71 (expression -> unary_op expression .) ]
  ! MINUS           [ reduce using rule 71 (expression -> unary_op expression .) ]
  ! TIMES           [ reduce using rule 71 (expression -> unary_op expression .) ]
  ! DIVIDE          [ reduce using rule 71 (expression -> unary_op expression .) ]
  ! GREATER         [ reduce using rule 71 (expression -> unary_op expression .) ]
  ! LESS            [ reduce using rule 71 (expression -> unary_op expression .) ]
  ! GREATEREQ       [ reduce using rule 71 (expression -> unary_op expression .) ]
  ! LESSEQ          [ reduce using rule 71 (expression -> unary_op expression .) ]
  ! EQUAL           [ reduce using rule 71 (expression -> unary_op expression .) ]
  ! NOTEQUAL        [ reduce using rule 71 (expression -> unary_op expression .) ]
  ! AND             [ reduce using rule 71 (expression -> unary_op expression .) ]
  ! OR              [ reduce using rule 71 (expression -> unary_op expression .) ]

    arith_op                       shift and go to state 113
    bool_op                        shift and go to state 114

state 128

    (36) stmt -> WHILE LPAREN expression . RPAREN stmt
    (69) expression -> expression . arith_op expression
    (70) expression -> expression . bool_op expression
    (73) arith_op -> . PLUS
    (74) arith_op -> . MINUS
    (75) arith_op -> . TIMES
    (76) arith_op -> . DIVIDE
    (77) bool_op -> . GREATER
    (78) bool_op -> . LESS
    (79) bool_op -> . GREATEREQ
    (80) bool_op -> . LESSEQ
    (81) bool_op -> . EQUAL
    (82) bool_op -> . NOTEQUAL
    (83) bool_op -> . AND
    (84) bool_op -> . OR

    RPAREN          shift and go to state 143
    PLUS            shift and go to state 115
    MINUS           shift and go to state 116
    TIMES           shift and go to state 117
    DIVIDE          shift and go to state 118
    GREATER         shift and go to state 119
    LESS            shift and go to state 120
    GREATEREQ       shift and go to state 121
    LESSEQ          shift and go to state 122
    EQUAL           shift and go to state 123
    NOTEQUAL        shift and go to state 124
    AND             shift and go to state 125
    OR              shift and go to state 126

    arith_op                       shift and go to state 113
    bool_op                        shift and go to state 114

state 129

    (37) stmt -> FOR LPAREN stmt_expression . SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt

    SEMICOLON       shift and go to state 144


state 130

    (38) stmt -> RETURN expression SEMICOLON .

    RCURLY          reduce using rule 38 (stmt -> RETURN expression SEMICOLON .)
    ELSE            reduce using rule 38 (stmt -> RETURN expression SEMICOLON .)


state 131

    (72) assign -> lhs SETEQUAL expression .
    (69) expression -> expression . arith_op expression
    (70) expression -> expression . bool_op expression
    (73) arith_op -> . PLUS
    (74) arith_op -> . MINUS
    (75) arith_op -> . TIMES
    (76) arith_op -> . DIVIDE
    (77) bool_op -> . GREATER
    (78) bool_op -> . LESS
    (79) bool_op -> . GREATEREQ
    (80) bool_op -> . LESSEQ
    (81) bool_op -> . EQUAL
    (82) bool_op -> . NOTEQUAL
    (83) bool_op -> . AND
    (84) bool_op -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 72 (assign -> lhs SETEQUAL expression .)
    RPAREN          reduce using rule 72 (assign -> lhs SETEQUAL expression .)
    COMMA           reduce using rule 72 (assign -> lhs SETEQUAL expression .)
    PLUS            shift and go to state 115
    MINUS           shift and go to state 116
    TIMES           shift and go to state 117
    DIVIDE          shift and go to state 118
    GREATER         shift and go to state 119
    LESS            shift and go to state 120
    GREATEREQ       shift and go to state 121
    LESSEQ          shift and go to state 122
    EQUAL           shift and go to state 123
    NOTEQUAL        shift and go to state 124
    AND             shift and go to state 125
    OR              shift and go to state 126

  ! PLUS            [ reduce using rule 72 (assign -> lhs SETEQUAL expression .) ]
  ! MINUS           [ reduce using rule 72 (assign -> lhs SETEQUAL expression .) ]
  ! TIMES           [ reduce using rule 72 (assign -> lhs SETEQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 72 (assign -> lhs SETEQUAL expression .) ]
  ! GREATER         [ reduce using rule 72 (assign -> lhs SETEQUAL expression .) ]
  ! LESS            [ reduce using rule 72 (assign -> lhs SETEQUAL expression .) ]
  ! GREATEREQ       [ reduce using rule 72 (assign -> lhs SETEQUAL expression .) ]
  ! LESSEQ          [ reduce using rule 72 (assign -> lhs SETEQUAL expression .) ]
  ! EQUAL           [ reduce using rule 72 (assign -> lhs SETEQUAL expression .) ]
  ! NOTEQUAL        [ reduce using rule 72 (assign -> lhs SETEQUAL expression .) ]
  ! AND             [ reduce using rule 72 (assign -> lhs SETEQUAL expression .) ]
  ! OR              [ reduce using rule 72 (assign -> lhs SETEQUAL expression .) ]

    arith_op                       shift and go to state 113
    bool_op                        shift and go to state 114

state 132

    (65) method_invocation -> field_access LPAREN arguments . RPAREN

    RPAREN          shift and go to state 145


state 133

    (66) method_invocation -> field_access LPAREN RPAREN .

    SEMICOLON       reduce using rule 66 (method_invocation -> field_access LPAREN RPAREN .)
    DOT             reduce using rule 66 (method_invocation -> field_access LPAREN RPAREN .)
    RPAREN          reduce using rule 66 (method_invocation -> field_access LPAREN RPAREN .)
    PLUS            reduce using rule 66 (method_invocation -> field_access LPAREN RPAREN .)
    MINUS           reduce using rule 66 (method_invocation -> field_access LPAREN RPAREN .)
    TIMES           reduce using rule 66 (method_invocation -> field_access LPAREN RPAREN .)
    DIVIDE          reduce using rule 66 (method_invocation -> field_access LPAREN RPAREN .)
    GREATER         reduce using rule 66 (method_invocation -> field_access LPAREN RPAREN .)
    LESS            reduce using rule 66 (method_invocation -> field_access LPAREN RPAREN .)
    GREATEREQ       reduce using rule 66 (method_invocation -> field_access LPAREN RPAREN .)
    LESSEQ          reduce using rule 66 (method_invocation -> field_access LPAREN RPAREN .)
    EQUAL           reduce using rule 66 (method_invocation -> field_access LPAREN RPAREN .)
    NOTEQUAL        reduce using rule 66 (method_invocation -> field_access LPAREN RPAREN .)
    AND             reduce using rule 66 (method_invocation -> field_access LPAREN RPAREN .)
    OR              reduce using rule 66 (method_invocation -> field_access LPAREN RPAREN .)
    COMMA           reduce using rule 66 (method_invocation -> field_access LPAREN RPAREN .)


state 134

    (60) arguments -> expression .
    (61) arguments -> expression . COMMA arguments
    (69) expression -> expression . arith_op expression
    (70) expression -> expression . bool_op expression
    (73) arith_op -> . PLUS
    (74) arith_op -> . MINUS
    (75) arith_op -> . TIMES
    (76) arith_op -> . DIVIDE
    (77) bool_op -> . GREATER
    (78) bool_op -> . LESS
    (79) bool_op -> . GREATEREQ
    (80) bool_op -> . LESSEQ
    (81) bool_op -> . EQUAL
    (82) bool_op -> . NOTEQUAL
    (83) bool_op -> . AND
    (84) bool_op -> . OR

    RPAREN          reduce using rule 60 (arguments -> expression .)
    COMMA           shift and go to state 146
    PLUS            shift and go to state 115
    MINUS           shift and go to state 116
    TIMES           shift and go to state 117
    DIVIDE          shift and go to state 118
    GREATER         shift and go to state 119
    LESS            shift and go to state 120
    GREATEREQ       shift and go to state 121
    LESSEQ          shift and go to state 122
    EQUAL           shift and go to state 123
    NOTEQUAL        shift and go to state 124
    AND             shift and go to state 125
    OR              shift and go to state 126

    arith_op                       shift and go to state 113
    bool_op                        shift and go to state 114

state 135

    (63) field_access -> primary DOT ID .

    LPAREN          reduce using rule 63 (field_access -> primary DOT ID .)
    SETEQUAL        reduce using rule 63 (field_access -> primary DOT ID .)
    DOT             reduce using rule 63 (field_access -> primary DOT ID .)
    RPAREN          reduce using rule 63 (field_access -> primary DOT ID .)
    PLUS            reduce using rule 63 (field_access -> primary DOT ID .)
    MINUS           reduce using rule 63 (field_access -> primary DOT ID .)
    TIMES           reduce using rule 63 (field_access -> primary DOT ID .)
    DIVIDE          reduce using rule 63 (field_access -> primary DOT ID .)
    GREATER         reduce using rule 63 (field_access -> primary DOT ID .)
    LESS            reduce using rule 63 (field_access -> primary DOT ID .)
    GREATEREQ       reduce using rule 63 (field_access -> primary DOT ID .)
    LESSEQ          reduce using rule 63 (field_access -> primary DOT ID .)
    EQUAL           reduce using rule 63 (field_access -> primary DOT ID .)
    NOTEQUAL        reduce using rule 63 (field_access -> primary DOT ID .)
    AND             reduce using rule 63 (field_access -> primary DOT ID .)
    OR              reduce using rule 63 (field_access -> primary DOT ID .)
    SEMICOLON       reduce using rule 63 (field_access -> primary DOT ID .)
    COMMA           reduce using rule 63 (field_access -> primary DOT ID .)


state 136

    (57) primary -> NEW ID LPAREN . arguments RPAREN
    (60) arguments -> . expression
    (61) arguments -> . expression COMMA arguments
    (67) expression -> . primary
    (68) expression -> . assign
    (69) expression -> . expression arith_op expression
    (70) expression -> . expression bool_op expression
    (71) expression -> . unary_op expression
    (52) primary -> . literal
    (53) primary -> . THIS
    (54) primary -> . SUPER
    (55) primary -> . LPAREN expression RPAREN
    (56) primary -> . NEW ID
    (57) primary -> . NEW ID LPAREN arguments RPAREN
    (58) primary -> . method_invocation
    (59) primary -> . lhs
    (72) assign -> . lhs SETEQUAL expression
    (85) unary_op -> . PLUS
    (86) unary_op -> . MINUS
    (87) unary_op -> . NOT
    (46) literal -> . INTEGER
    (47) literal -> . FLOAT
    (48) literal -> . STRING
    (49) literal -> . NULL
    (50) literal -> . FALSE
    (51) literal -> . TRUE
    (65) method_invocation -> . field_access LPAREN arguments RPAREN
    (66) method_invocation -> . field_access LPAREN RPAREN
    (62) lhs -> . field_access
    (63) field_access -> . primary DOT ID
    (64) field_access -> . ID

    THIS            shift and go to state 66
    SUPER           shift and go to state 67
    LPAREN          shift and go to state 47
    NEW             shift and go to state 68
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    NOT             shift and go to state 93
    INTEGER         shift and go to state 69
    FLOAT           shift and go to state 94
    STRING          shift and go to state 70
    NULL            shift and go to state 71
    FALSE           shift and go to state 72
    TRUE            shift and go to state 73
    ID              shift and go to state 88

    arguments                      shift and go to state 147
    expression                     shift and go to state 134
    primary                        shift and go to state 85
    assign                         shift and go to state 86
    unary_op                       shift and go to state 87
    literal                        shift and go to state 65
    method_invocation              shift and go to state 89
    lhs                            shift and go to state 90
    field_access                   shift and go to state 61

state 137

    (26) method_decl -> modifier VOID ID LPAREN RPAREN block .

    RCURLY          reduce using rule 26 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    PUBLIC          reduce using rule 26 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    PRIVATE         reduce using rule 26 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    VOID            reduce using rule 26 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    ID              reduce using rule 26 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    INT             reduce using rule 26 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    FLOAT           reduce using rule 26 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 26 (method_decl -> modifier VOID ID LPAREN RPAREN block .)


state 138

    (27) method_decl -> modifier VOID ID LPAREN formals RPAREN . block
    (33) block -> . LCURLY stmt RCURLY

    LCURLY          shift and go to state 36

    block                          shift and go to state 148

state 139

    (25) method_decl -> modifier type ID LPAREN formals RPAREN block .

    RCURLY          reduce using rule 25 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    PUBLIC          reduce using rule 25 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 25 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    VOID            reduce using rule 25 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    ID              reduce using rule 25 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    INT             reduce using rule 25 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 25 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 25 (method_decl -> modifier type ID LPAREN formals RPAREN block .)


state 140

    (34) stmt -> IF LPAREN expression RPAREN . stmt
    (35) stmt -> IF LPAREN expression RPAREN . stmt ELSE stmt
    (34) stmt -> . IF LPAREN expression RPAREN stmt
    (35) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (36) stmt -> . WHILE LPAREN expression RPAREN stmt
    (37) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (38) stmt -> . RETURN expression SEMICOLON
    (39) stmt -> . RETURN SEMICOLON
    (40) stmt -> . stmt_expression SEMICOLON
    (41) stmt -> . BREAK SEMICOLON
    (42) stmt -> . CONTINUE SEMICOLON
    (43) stmt -> . block
    (44) stmt -> . var_decl
    (45) stmt -> . SEMICOLON
    (88) stmt_expression -> . assign
    (89) stmt_expression -> . method_invocation
    (33) block -> . LCURLY stmt RCURLY
    (16) var_decl -> . type variables SEMICOLON
    (72) assign -> . lhs SETEQUAL expression
    (65) method_invocation -> . field_access LPAREN arguments RPAREN
    (66) method_invocation -> . field_access LPAREN RPAREN
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . BOOLEAN
    (20) type -> . ID
    (62) lhs -> . field_access
    (63) field_access -> . primary DOT ID
    (64) field_access -> . ID
    (52) primary -> . literal
    (53) primary -> . THIS
    (54) primary -> . SUPER
    (55) primary -> . LPAREN expression RPAREN
    (56) primary -> . NEW ID
    (57) primary -> . NEW ID LPAREN arguments RPAREN
    (58) primary -> . method_invocation
    (59) primary -> . lhs
    (46) literal -> . INTEGER
    (47) literal -> . FLOAT
    (48) literal -> . STRING
    (49) literal -> . NULL
    (50) literal -> . FALSE
    (51) literal -> . TRUE

    IF              shift and go to state 46
    WHILE           shift and go to state 48
    FOR             shift and go to state 49
    RETURN          shift and go to state 52
    BREAK           shift and go to state 53
    CONTINUE        shift and go to state 54
    SEMICOLON       shift and go to state 51
    LCURLY          shift and go to state 36
    INT             shift and go to state 24
    FLOAT           shift and go to state 62
    BOOLEAN         shift and go to state 26
    ID              shift and go to state 63
    THIS            shift and go to state 66
    SUPER           shift and go to state 67
    LPAREN          shift and go to state 47
    NEW             shift and go to state 68
    INTEGER         shift and go to state 69
    STRING          shift and go to state 70
    NULL            shift and go to state 71
    FALSE           shift and go to state 72
    TRUE            shift and go to state 73

    stmt                           shift and go to state 149
    stmt_expression                shift and go to state 50
    block                          shift and go to state 55
    var_decl                       shift and go to state 56
    assign                         shift and go to state 57
    method_invocation              shift and go to state 58
    type                           shift and go to state 59
    lhs                            shift and go to state 60
    field_access                   shift and go to state 61
    primary                        shift and go to state 64
    literal                        shift and go to state 65

state 141

    (69) expression -> expression arith_op expression .
    (69) expression -> expression . arith_op expression
    (70) expression -> expression . bool_op expression
    (73) arith_op -> . PLUS
    (74) arith_op -> . MINUS
    (75) arith_op -> . TIMES
    (76) arith_op -> . DIVIDE
    (77) bool_op -> . GREATER
    (78) bool_op -> . LESS
    (79) bool_op -> . GREATEREQ
    (80) bool_op -> . LESSEQ
    (81) bool_op -> . EQUAL
    (82) bool_op -> . NOTEQUAL
    (83) bool_op -> . AND
    (84) bool_op -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 69 (expression -> expression arith_op expression .)
    SEMICOLON       reduce using rule 69 (expression -> expression arith_op expression .)
    COMMA           reduce using rule 69 (expression -> expression arith_op expression .)
    PLUS            shift and go to state 115
    MINUS           shift and go to state 116
    TIMES           shift and go to state 117
    DIVIDE          shift and go to state 118
    GREATER         shift and go to state 119
    LESS            shift and go to state 120
    GREATEREQ       shift and go to state 121
    LESSEQ          shift and go to state 122
    EQUAL           shift and go to state 123
    NOTEQUAL        shift and go to state 124
    AND             shift and go to state 125
    OR              shift and go to state 126

  ! PLUS            [ reduce using rule 69 (expression -> expression arith_op expression .) ]
  ! MINUS           [ reduce using rule 69 (expression -> expression arith_op expression .) ]
  ! TIMES           [ reduce using rule 69 (expression -> expression arith_op expression .) ]
  ! DIVIDE          [ reduce using rule 69 (expression -> expression arith_op expression .) ]
  ! GREATER         [ reduce using rule 69 (expression -> expression arith_op expression .) ]
  ! LESS            [ reduce using rule 69 (expression -> expression arith_op expression .) ]
  ! GREATEREQ       [ reduce using rule 69 (expression -> expression arith_op expression .) ]
  ! LESSEQ          [ reduce using rule 69 (expression -> expression arith_op expression .) ]
  ! EQUAL           [ reduce using rule 69 (expression -> expression arith_op expression .) ]
  ! NOTEQUAL        [ reduce using rule 69 (expression -> expression arith_op expression .) ]
  ! AND             [ reduce using rule 69 (expression -> expression arith_op expression .) ]
  ! OR              [ reduce using rule 69 (expression -> expression arith_op expression .) ]

    arith_op                       shift and go to state 113
    bool_op                        shift and go to state 114

state 142

    (70) expression -> expression bool_op expression .
    (69) expression -> expression . arith_op expression
    (70) expression -> expression . bool_op expression
    (73) arith_op -> . PLUS
    (74) arith_op -> . MINUS
    (75) arith_op -> . TIMES
    (76) arith_op -> . DIVIDE
    (77) bool_op -> . GREATER
    (78) bool_op -> . LESS
    (79) bool_op -> . GREATEREQ
    (80) bool_op -> . LESSEQ
    (81) bool_op -> . EQUAL
    (82) bool_op -> . NOTEQUAL
    (83) bool_op -> . AND
    (84) bool_op -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 70 (expression -> expression bool_op expression .)
    SEMICOLON       reduce using rule 70 (expression -> expression bool_op expression .)
    COMMA           reduce using rule 70 (expression -> expression bool_op expression .)
    PLUS            shift and go to state 115
    MINUS           shift and go to state 116
    TIMES           shift and go to state 117
    DIVIDE          shift and go to state 118
    GREATER         shift and go to state 119
    LESS            shift and go to state 120
    GREATEREQ       shift and go to state 121
    LESSEQ          shift and go to state 122
    EQUAL           shift and go to state 123
    NOTEQUAL        shift and go to state 124
    AND             shift and go to state 125
    OR              shift and go to state 126

  ! PLUS            [ reduce using rule 70 (expression -> expression bool_op expression .) ]
  ! MINUS           [ reduce using rule 70 (expression -> expression bool_op expression .) ]
  ! TIMES           [ reduce using rule 70 (expression -> expression bool_op expression .) ]
  ! DIVIDE          [ reduce using rule 70 (expression -> expression bool_op expression .) ]
  ! GREATER         [ reduce using rule 70 (expression -> expression bool_op expression .) ]
  ! LESS            [ reduce using rule 70 (expression -> expression bool_op expression .) ]
  ! GREATEREQ       [ reduce using rule 70 (expression -> expression bool_op expression .) ]
  ! LESSEQ          [ reduce using rule 70 (expression -> expression bool_op expression .) ]
  ! EQUAL           [ reduce using rule 70 (expression -> expression bool_op expression .) ]
  ! NOTEQUAL        [ reduce using rule 70 (expression -> expression bool_op expression .) ]
  ! AND             [ reduce using rule 70 (expression -> expression bool_op expression .) ]
  ! OR              [ reduce using rule 70 (expression -> expression bool_op expression .) ]

    bool_op                        shift and go to state 114
    arith_op                       shift and go to state 113

state 143

    (36) stmt -> WHILE LPAREN expression RPAREN . stmt
    (34) stmt -> . IF LPAREN expression RPAREN stmt
    (35) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (36) stmt -> . WHILE LPAREN expression RPAREN stmt
    (37) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (38) stmt -> . RETURN expression SEMICOLON
    (39) stmt -> . RETURN SEMICOLON
    (40) stmt -> . stmt_expression SEMICOLON
    (41) stmt -> . BREAK SEMICOLON
    (42) stmt -> . CONTINUE SEMICOLON
    (43) stmt -> . block
    (44) stmt -> . var_decl
    (45) stmt -> . SEMICOLON
    (88) stmt_expression -> . assign
    (89) stmt_expression -> . method_invocation
    (33) block -> . LCURLY stmt RCURLY
    (16) var_decl -> . type variables SEMICOLON
    (72) assign -> . lhs SETEQUAL expression
    (65) method_invocation -> . field_access LPAREN arguments RPAREN
    (66) method_invocation -> . field_access LPAREN RPAREN
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . BOOLEAN
    (20) type -> . ID
    (62) lhs -> . field_access
    (63) field_access -> . primary DOT ID
    (64) field_access -> . ID
    (52) primary -> . literal
    (53) primary -> . THIS
    (54) primary -> . SUPER
    (55) primary -> . LPAREN expression RPAREN
    (56) primary -> . NEW ID
    (57) primary -> . NEW ID LPAREN arguments RPAREN
    (58) primary -> . method_invocation
    (59) primary -> . lhs
    (46) literal -> . INTEGER
    (47) literal -> . FLOAT
    (48) literal -> . STRING
    (49) literal -> . NULL
    (50) literal -> . FALSE
    (51) literal -> . TRUE

    IF              shift and go to state 46
    WHILE           shift and go to state 48
    FOR             shift and go to state 49
    RETURN          shift and go to state 52
    BREAK           shift and go to state 53
    CONTINUE        shift and go to state 54
    SEMICOLON       shift and go to state 51
    LCURLY          shift and go to state 36
    INT             shift and go to state 24
    FLOAT           shift and go to state 62
    BOOLEAN         shift and go to state 26
    ID              shift and go to state 63
    THIS            shift and go to state 66
    SUPER           shift and go to state 67
    LPAREN          shift and go to state 47
    NEW             shift and go to state 68
    INTEGER         shift and go to state 69
    STRING          shift and go to state 70
    NULL            shift and go to state 71
    FALSE           shift and go to state 72
    TRUE            shift and go to state 73

    stmt                           shift and go to state 150
    stmt_expression                shift and go to state 50
    block                          shift and go to state 55
    var_decl                       shift and go to state 56
    assign                         shift and go to state 57
    method_invocation              shift and go to state 58
    type                           shift and go to state 59
    lhs                            shift and go to state 60
    field_access                   shift and go to state 61
    primary                        shift and go to state 64
    literal                        shift and go to state 65

state 144

    (37) stmt -> FOR LPAREN stmt_expression SEMICOLON . expression SEMICOLON stmt_expression RPAREN stmt
    (67) expression -> . primary
    (68) expression -> . assign
    (69) expression -> . expression arith_op expression
    (70) expression -> . expression bool_op expression
    (71) expression -> . unary_op expression
    (52) primary -> . literal
    (53) primary -> . THIS
    (54) primary -> . SUPER
    (55) primary -> . LPAREN expression RPAREN
    (56) primary -> . NEW ID
    (57) primary -> . NEW ID LPAREN arguments RPAREN
    (58) primary -> . method_invocation
    (59) primary -> . lhs
    (72) assign -> . lhs SETEQUAL expression
    (85) unary_op -> . PLUS
    (86) unary_op -> . MINUS
    (87) unary_op -> . NOT
    (46) literal -> . INTEGER
    (47) literal -> . FLOAT
    (48) literal -> . STRING
    (49) literal -> . NULL
    (50) literal -> . FALSE
    (51) literal -> . TRUE
    (65) method_invocation -> . field_access LPAREN arguments RPAREN
    (66) method_invocation -> . field_access LPAREN RPAREN
    (62) lhs -> . field_access
    (63) field_access -> . primary DOT ID
    (64) field_access -> . ID

    THIS            shift and go to state 66
    SUPER           shift and go to state 67
    LPAREN          shift and go to state 47
    NEW             shift and go to state 68
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    NOT             shift and go to state 93
    INTEGER         shift and go to state 69
    FLOAT           shift and go to state 94
    STRING          shift and go to state 70
    NULL            shift and go to state 71
    FALSE           shift and go to state 72
    TRUE            shift and go to state 73
    ID              shift and go to state 88

    expression                     shift and go to state 151
    primary                        shift and go to state 85
    assign                         shift and go to state 86
    unary_op                       shift and go to state 87
    literal                        shift and go to state 65
    method_invocation              shift and go to state 89
    lhs                            shift and go to state 90
    field_access                   shift and go to state 61

state 145

    (65) method_invocation -> field_access LPAREN arguments RPAREN .

    SEMICOLON       reduce using rule 65 (method_invocation -> field_access LPAREN arguments RPAREN .)
    DOT             reduce using rule 65 (method_invocation -> field_access LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 65 (method_invocation -> field_access LPAREN arguments RPAREN .)
    PLUS            reduce using rule 65 (method_invocation -> field_access LPAREN arguments RPAREN .)
    MINUS           reduce using rule 65 (method_invocation -> field_access LPAREN arguments RPAREN .)
    TIMES           reduce using rule 65 (method_invocation -> field_access LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 65 (method_invocation -> field_access LPAREN arguments RPAREN .)
    GREATER         reduce using rule 65 (method_invocation -> field_access LPAREN arguments RPAREN .)
    LESS            reduce using rule 65 (method_invocation -> field_access LPAREN arguments RPAREN .)
    GREATEREQ       reduce using rule 65 (method_invocation -> field_access LPAREN arguments RPAREN .)
    LESSEQ          reduce using rule 65 (method_invocation -> field_access LPAREN arguments RPAREN .)
    EQUAL           reduce using rule 65 (method_invocation -> field_access LPAREN arguments RPAREN .)
    NOTEQUAL        reduce using rule 65 (method_invocation -> field_access LPAREN arguments RPAREN .)
    AND             reduce using rule 65 (method_invocation -> field_access LPAREN arguments RPAREN .)
    OR              reduce using rule 65 (method_invocation -> field_access LPAREN arguments RPAREN .)
    COMMA           reduce using rule 65 (method_invocation -> field_access LPAREN arguments RPAREN .)


state 146

    (61) arguments -> expression COMMA . arguments
    (60) arguments -> . expression
    (61) arguments -> . expression COMMA arguments
    (67) expression -> . primary
    (68) expression -> . assign
    (69) expression -> . expression arith_op expression
    (70) expression -> . expression bool_op expression
    (71) expression -> . unary_op expression
    (52) primary -> . literal
    (53) primary -> . THIS
    (54) primary -> . SUPER
    (55) primary -> . LPAREN expression RPAREN
    (56) primary -> . NEW ID
    (57) primary -> . NEW ID LPAREN arguments RPAREN
    (58) primary -> . method_invocation
    (59) primary -> . lhs
    (72) assign -> . lhs SETEQUAL expression
    (85) unary_op -> . PLUS
    (86) unary_op -> . MINUS
    (87) unary_op -> . NOT
    (46) literal -> . INTEGER
    (47) literal -> . FLOAT
    (48) literal -> . STRING
    (49) literal -> . NULL
    (50) literal -> . FALSE
    (51) literal -> . TRUE
    (65) method_invocation -> . field_access LPAREN arguments RPAREN
    (66) method_invocation -> . field_access LPAREN RPAREN
    (62) lhs -> . field_access
    (63) field_access -> . primary DOT ID
    (64) field_access -> . ID

    THIS            shift and go to state 66
    SUPER           shift and go to state 67
    LPAREN          shift and go to state 47
    NEW             shift and go to state 68
    PLUS            shift and go to state 91
    MINUS           shift and go to state 92
    NOT             shift and go to state 93
    INTEGER         shift and go to state 69
    FLOAT           shift and go to state 94
    STRING          shift and go to state 70
    NULL            shift and go to state 71
    FALSE           shift and go to state 72
    TRUE            shift and go to state 73
    ID              shift and go to state 88

    expression                     shift and go to state 134
    arguments                      shift and go to state 152
    primary                        shift and go to state 85
    assign                         shift and go to state 86
    unary_op                       shift and go to state 87
    literal                        shift and go to state 65
    method_invocation              shift and go to state 89
    lhs                            shift and go to state 90
    field_access                   shift and go to state 61

state 147

    (57) primary -> NEW ID LPAREN arguments . RPAREN

    RPAREN          shift and go to state 153


state 148

    (27) method_decl -> modifier VOID ID LPAREN formals RPAREN block .

    RCURLY          reduce using rule 27 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    PUBLIC          reduce using rule 27 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 27 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    VOID            reduce using rule 27 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    ID              reduce using rule 27 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    INT             reduce using rule 27 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 27 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 27 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)


state 149

    (34) stmt -> IF LPAREN expression RPAREN stmt .
    (35) stmt -> IF LPAREN expression RPAREN stmt . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    RCURLY          reduce using rule 34 (stmt -> IF LPAREN expression RPAREN stmt .)
    ELSE            shift and go to state 154

  ! ELSE            [ reduce using rule 34 (stmt -> IF LPAREN expression RPAREN stmt .) ]


state 150

    (36) stmt -> WHILE LPAREN expression RPAREN stmt .

    RCURLY          reduce using rule 36 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    ELSE            reduce using rule 36 (stmt -> WHILE LPAREN expression RPAREN stmt .)


state 151

    (37) stmt -> FOR LPAREN stmt_expression SEMICOLON expression . SEMICOLON stmt_expression RPAREN stmt
    (69) expression -> expression . arith_op expression
    (70) expression -> expression . bool_op expression
    (73) arith_op -> . PLUS
    (74) arith_op -> . MINUS
    (75) arith_op -> . TIMES
    (76) arith_op -> . DIVIDE
    (77) bool_op -> . GREATER
    (78) bool_op -> . LESS
    (79) bool_op -> . GREATEREQ
    (80) bool_op -> . LESSEQ
    (81) bool_op -> . EQUAL
    (82) bool_op -> . NOTEQUAL
    (83) bool_op -> . AND
    (84) bool_op -> . OR

    SEMICOLON       shift and go to state 155
    PLUS            shift and go to state 115
    MINUS           shift and go to state 116
    TIMES           shift and go to state 117
    DIVIDE          shift and go to state 118
    GREATER         shift and go to state 119
    LESS            shift and go to state 120
    GREATEREQ       shift and go to state 121
    LESSEQ          shift and go to state 122
    EQUAL           shift and go to state 123
    NOTEQUAL        shift and go to state 124
    AND             shift and go to state 125
    OR              shift and go to state 126

    arith_op                       shift and go to state 113
    bool_op                        shift and go to state 114

state 152

    (61) arguments -> expression COMMA arguments .

    RPAREN          reduce using rule 61 (arguments -> expression COMMA arguments .)


state 153

    (57) primary -> NEW ID LPAREN arguments RPAREN .

    DOT             reduce using rule 57 (primary -> NEW ID LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 57 (primary -> NEW ID LPAREN arguments RPAREN .)
    PLUS            reduce using rule 57 (primary -> NEW ID LPAREN arguments RPAREN .)
    MINUS           reduce using rule 57 (primary -> NEW ID LPAREN arguments RPAREN .)
    TIMES           reduce using rule 57 (primary -> NEW ID LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 57 (primary -> NEW ID LPAREN arguments RPAREN .)
    GREATER         reduce using rule 57 (primary -> NEW ID LPAREN arguments RPAREN .)
    LESS            reduce using rule 57 (primary -> NEW ID LPAREN arguments RPAREN .)
    GREATEREQ       reduce using rule 57 (primary -> NEW ID LPAREN arguments RPAREN .)
    LESSEQ          reduce using rule 57 (primary -> NEW ID LPAREN arguments RPAREN .)
    EQUAL           reduce using rule 57 (primary -> NEW ID LPAREN arguments RPAREN .)
    NOTEQUAL        reduce using rule 57 (primary -> NEW ID LPAREN arguments RPAREN .)
    AND             reduce using rule 57 (primary -> NEW ID LPAREN arguments RPAREN .)
    OR              reduce using rule 57 (primary -> NEW ID LPAREN arguments RPAREN .)
    SEMICOLON       reduce using rule 57 (primary -> NEW ID LPAREN arguments RPAREN .)
    COMMA           reduce using rule 57 (primary -> NEW ID LPAREN arguments RPAREN .)


state 154

    (35) stmt -> IF LPAREN expression RPAREN stmt ELSE . stmt
    (34) stmt -> . IF LPAREN expression RPAREN stmt
    (35) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (36) stmt -> . WHILE LPAREN expression RPAREN stmt
    (37) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (38) stmt -> . RETURN expression SEMICOLON
    (39) stmt -> . RETURN SEMICOLON
    (40) stmt -> . stmt_expression SEMICOLON
    (41) stmt -> . BREAK SEMICOLON
    (42) stmt -> . CONTINUE SEMICOLON
    (43) stmt -> . block
    (44) stmt -> . var_decl
    (45) stmt -> . SEMICOLON
    (88) stmt_expression -> . assign
    (89) stmt_expression -> . method_invocation
    (33) block -> . LCURLY stmt RCURLY
    (16) var_decl -> . type variables SEMICOLON
    (72) assign -> . lhs SETEQUAL expression
    (65) method_invocation -> . field_access LPAREN arguments RPAREN
    (66) method_invocation -> . field_access LPAREN RPAREN
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . BOOLEAN
    (20) type -> . ID
    (62) lhs -> . field_access
    (63) field_access -> . primary DOT ID
    (64) field_access -> . ID
    (52) primary -> . literal
    (53) primary -> . THIS
    (54) primary -> . SUPER
    (55) primary -> . LPAREN expression RPAREN
    (56) primary -> . NEW ID
    (57) primary -> . NEW ID LPAREN arguments RPAREN
    (58) primary -> . method_invocation
    (59) primary -> . lhs
    (46) literal -> . INTEGER
    (47) literal -> . FLOAT
    (48) literal -> . STRING
    (49) literal -> . NULL
    (50) literal -> . FALSE
    (51) literal -> . TRUE

    IF              shift and go to state 46
    WHILE           shift and go to state 48
    FOR             shift and go to state 49
    RETURN          shift and go to state 52
    BREAK           shift and go to state 53
    CONTINUE        shift and go to state 54
    SEMICOLON       shift and go to state 51
    LCURLY          shift and go to state 36
    INT             shift and go to state 24
    FLOAT           shift and go to state 62
    BOOLEAN         shift and go to state 26
    ID              shift and go to state 63
    THIS            shift and go to state 66
    SUPER           shift and go to state 67
    LPAREN          shift and go to state 47
    NEW             shift and go to state 68
    INTEGER         shift and go to state 69
    STRING          shift and go to state 70
    NULL            shift and go to state 71
    FALSE           shift and go to state 72
    TRUE            shift and go to state 73

    stmt                           shift and go to state 156
    stmt_expression                shift and go to state 50
    block                          shift and go to state 55
    var_decl                       shift and go to state 56
    assign                         shift and go to state 57
    method_invocation              shift and go to state 58
    type                           shift and go to state 59
    lhs                            shift and go to state 60
    field_access                   shift and go to state 61
    primary                        shift and go to state 64
    literal                        shift and go to state 65

state 155

    (37) stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON . stmt_expression RPAREN stmt
    (88) stmt_expression -> . assign
    (89) stmt_expression -> . method_invocation
    (72) assign -> . lhs SETEQUAL expression
    (65) method_invocation -> . field_access LPAREN arguments RPAREN
    (66) method_invocation -> . field_access LPAREN RPAREN
    (62) lhs -> . field_access
    (63) field_access -> . primary DOT ID
    (64) field_access -> . ID
    (52) primary -> . literal
    (53) primary -> . THIS
    (54) primary -> . SUPER
    (55) primary -> . LPAREN expression RPAREN
    (56) primary -> . NEW ID
    (57) primary -> . NEW ID LPAREN arguments RPAREN
    (58) primary -> . method_invocation
    (59) primary -> . lhs
    (46) literal -> . INTEGER
    (47) literal -> . FLOAT
    (48) literal -> . STRING
    (49) literal -> . NULL
    (50) literal -> . FALSE
    (51) literal -> . TRUE

    ID              shift and go to state 88
    THIS            shift and go to state 66
    SUPER           shift and go to state 67
    LPAREN          shift and go to state 47
    NEW             shift and go to state 68
    INTEGER         shift and go to state 69
    FLOAT           shift and go to state 94
    STRING          shift and go to state 70
    NULL            shift and go to state 71
    FALSE           shift and go to state 72
    TRUE            shift and go to state 73

    stmt_expression                shift and go to state 157
    assign                         shift and go to state 57
    method_invocation              shift and go to state 58
    lhs                            shift and go to state 60
    field_access                   shift and go to state 61
    primary                        shift and go to state 64
    literal                        shift and go to state 65

state 156

    (35) stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .

    RCURLY          reduce using rule 35 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    ELSE            reduce using rule 35 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)


state 157

    (37) stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression . RPAREN stmt

    RPAREN          shift and go to state 158


state 158

    (37) stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN . stmt
    (34) stmt -> . IF LPAREN expression RPAREN stmt
    (35) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (36) stmt -> . WHILE LPAREN expression RPAREN stmt
    (37) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt
    (38) stmt -> . RETURN expression SEMICOLON
    (39) stmt -> . RETURN SEMICOLON
    (40) stmt -> . stmt_expression SEMICOLON
    (41) stmt -> . BREAK SEMICOLON
    (42) stmt -> . CONTINUE SEMICOLON
    (43) stmt -> . block
    (44) stmt -> . var_decl
    (45) stmt -> . SEMICOLON
    (88) stmt_expression -> . assign
    (89) stmt_expression -> . method_invocation
    (33) block -> . LCURLY stmt RCURLY
    (16) var_decl -> . type variables SEMICOLON
    (72) assign -> . lhs SETEQUAL expression
    (65) method_invocation -> . field_access LPAREN arguments RPAREN
    (66) method_invocation -> . field_access LPAREN RPAREN
    (17) type -> . INT
    (18) type -> . FLOAT
    (19) type -> . BOOLEAN
    (20) type -> . ID
    (62) lhs -> . field_access
    (63) field_access -> . primary DOT ID
    (64) field_access -> . ID
    (52) primary -> . literal
    (53) primary -> . THIS
    (54) primary -> . SUPER
    (55) primary -> . LPAREN expression RPAREN
    (56) primary -> . NEW ID
    (57) primary -> . NEW ID LPAREN arguments RPAREN
    (58) primary -> . method_invocation
    (59) primary -> . lhs
    (46) literal -> . INTEGER
    (47) literal -> . FLOAT
    (48) literal -> . STRING
    (49) literal -> . NULL
    (50) literal -> . FALSE
    (51) literal -> . TRUE

    IF              shift and go to state 46
    WHILE           shift and go to state 48
    FOR             shift and go to state 49
    RETURN          shift and go to state 52
    BREAK           shift and go to state 53
    CONTINUE        shift and go to state 54
    SEMICOLON       shift and go to state 51
    LCURLY          shift and go to state 36
    INT             shift and go to state 24
    FLOAT           shift and go to state 62
    BOOLEAN         shift and go to state 26
    ID              shift and go to state 63
    THIS            shift and go to state 66
    SUPER           shift and go to state 67
    LPAREN          shift and go to state 47
    NEW             shift and go to state 68
    INTEGER         shift and go to state 69
    STRING          shift and go to state 70
    NULL            shift and go to state 71
    FALSE           shift and go to state 72
    TRUE            shift and go to state 73

    stmt_expression                shift and go to state 50
    stmt                           shift and go to state 159
    block                          shift and go to state 55
    var_decl                       shift and go to state 56
    assign                         shift and go to state 57
    method_invocation              shift and go to state 58
    type                           shift and go to state 59
    lhs                            shift and go to state 60
    field_access                   shift and go to state 61
    primary                        shift and go to state 64
    literal                        shift and go to state 65

state 159

    (37) stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .

    RCURLY          reduce using rule 37 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)
    ELSE            reduce using rule 37 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN stmt .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 22 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 127 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 127 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 127 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 127 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 127 resolved as shift
WARNING: shift/reduce conflict for LESS in state 127 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 127 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 127 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 127 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 127 resolved as shift
WARNING: shift/reduce conflict for AND in state 127 resolved as shift
WARNING: shift/reduce conflict for OR in state 127 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 131 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 131 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 131 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 131 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 131 resolved as shift
WARNING: shift/reduce conflict for LESS in state 131 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 131 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 131 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 131 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 131 resolved as shift
WARNING: shift/reduce conflict for AND in state 131 resolved as shift
WARNING: shift/reduce conflict for OR in state 131 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 141 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 141 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 141 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 141 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 141 resolved as shift
WARNING: shift/reduce conflict for LESS in state 141 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 141 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 141 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 141 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 141 resolved as shift
WARNING: shift/reduce conflict for AND in state 141 resolved as shift
WARNING: shift/reduce conflict for OR in state 141 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 142 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 142 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 142 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 142 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 142 resolved as shift
WARNING: shift/reduce conflict for LESS in state 142 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 142 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 142 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 142 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 142 resolved as shift
WARNING: shift/reduce conflict for AND in state 142 resolved as shift
WARNING: shift/reduce conflict for OR in state 142 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 149 resolved as shift
