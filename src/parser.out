Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    DO
    DOUBLE
    ERROR
    LBRACKET
    RBRACKET
    float_const
    int_const
    string_const

Grammar

Rule 0     S' -> start
Rule 1     start -> class_decl
Rule 2     class_decl -> CLASS ID LCURLY class_body RCURLY
Rule 3     class_decl -> CLASS ID EXTENDS ID LCURLY class_body RCURLY
Rule 4     class_body -> field_decl
Rule 5     class_body -> method_decl
Rule 6     class_body -> constructor_decl
Rule 7     class_body -> class_body field_decl
Rule 8     class_body -> class_body constructor_decl
Rule 9     class_body -> class_body method_decl
Rule 10    class_body -> empty
Rule 11    field_decl -> var_decl
Rule 12    field_decl -> modifier var_decl
Rule 13    modifier -> PUBLIC
Rule 14    modifier -> PRIVATE
Rule 15    modifier -> STATIC
Rule 16    modifier -> PUBLIC STATIC
Rule 17    modifier -> PRIVATE STATIC
Rule 18    var_decl -> type variables SEMICOLON
Rule 19    type -> INT
Rule 20    type -> FLOAT
Rule 21    type -> BOOLEAN
Rule 22    type -> ID
Rule 23    variables -> variable
Rule 24    variables -> variable COMMA variables
Rule 25    variable -> ID
Rule 26    method_decl -> modifier type ID LPAREN RPAREN block
Rule 27    method_decl -> modifier type ID LPAREN formals RPAREN block
Rule 28    method_decl -> modifier VOID ID LPAREN RPAREN block
Rule 29    method_decl -> modifier VOID ID LPAREN formals RPAREN block
Rule 30    constructor_decl -> modifier ID LPAREN RPAREN block
Rule 31    constructor_decl -> modifier ID LPAREN formals RPAREN block
Rule 32    formals -> formal_param
Rule 33    formals -> formal_param COMMA formals
Rule 34    formal_param -> type variable
Rule 35    block -> LCURLY stmtlist RCURLY
Rule 36    block -> empty
Rule 37    stmtlist -> stmt
Rule 38    stmtlist -> stmtlist stmt
Rule 39    stmt -> IF LPAREN expression RPAREN stmt
Rule 40    stmt -> IF LPAREN expression RPAREN stmt ELSE stmt
Rule 41    stmt -> WHILE LPAREN expression RPAREN stmt
Rule 42    stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block
Rule 43    stmt -> RETURN expression SEMICOLON
Rule 44    stmt -> RETURN SEMICOLON
Rule 45    stmt -> stmt_expression SEMICOLON
Rule 46    stmt -> BREAK SEMICOLON
Rule 47    stmt -> CONTINUE SEMICOLON
Rule 48    stmt -> block
Rule 49    stmt -> var_decl
Rule 50    stmt -> SEMICOLON
Rule 51    literal -> INTEGER
Rule 52    literal -> FLOAT
Rule 53    literal -> STRING
Rule 54    literal -> NULL
Rule 55    literal -> FALSE
Rule 56    literal -> TRUE
Rule 57    primary -> literal
Rule 58    primary -> THIS
Rule 59    primary -> SUPER
Rule 60    primary -> LPAREN expression RPAREN
Rule 61    primary -> NEW ID LPAREN RPAREN
Rule 62    primary -> NEW ID LPAREN arguments RPAREN
Rule 63    primary -> method_invocation
Rule 64    primary -> lhs
Rule 65    arguments -> expression
Rule 66    arguments -> expression COMMA arguments
Rule 67    method_invocation -> field_access LPAREN arguments RPAREN
Rule 68    method_invocation -> field_access LPAREN RPAREN
Rule 69    expression -> primary
Rule 70    expression -> assign
Rule 71    expression -> expression arith_op expression
Rule 72    expression -> expression bool_op expression
Rule 73    expression -> unary_op expression
Rule 74    lhs -> field_access
Rule 75    field_access -> primary DOT ID
Rule 76    field_access -> ID
Rule 77    assign -> lhs SETEQUAL expression
Rule 78    arith_op -> PLUS
Rule 79    arith_op -> MINUS
Rule 80    arith_op -> TIMES
Rule 81    arith_op -> DIVIDE
Rule 82    bool_op -> GREATER
Rule 83    bool_op -> LESS
Rule 84    bool_op -> GREATEREQ
Rule 85    bool_op -> LESSEQ
Rule 86    bool_op -> EQUAL
Rule 87    bool_op -> NOTEQUAL
Rule 88    bool_op -> AND
Rule 89    bool_op -> OR
Rule 90    unary_op -> PLUS
Rule 91    unary_op -> MINUS
Rule 92    unary_op -> NOT
Rule 93    stmt_expression -> assign
Rule 94    stmt_expression -> method_invocation
Rule 95    empty -> <empty>

Terminals, with rules where they appear

AND                  : 88
BOOLEAN              : 21
BREAK                : 46
CLASS                : 2 3
COMMA                : 24 33 66
CONTINUE             : 47
DIVIDE               : 81
DO                   : 
DOT                  : 75
DOUBLE               : 
ELSE                 : 40
EQUAL                : 86
ERROR                : 
EXTENDS              : 3
FALSE                : 55
FLOAT                : 20 52
FOR                  : 42
GREATER              : 82
GREATEREQ            : 84
ID                   : 2 3 3 22 25 26 27 28 29 30 31 61 62 75 76
IF                   : 39 40
INT                  : 19
INTEGER              : 51
LBRACKET             : 
LCURLY               : 2 3 35
LESS                 : 83
LESSEQ               : 85
LPAREN               : 26 27 28 29 30 31 39 40 41 42 60 61 62 67 68
MINUS                : 79 91
NEW                  : 61 62
NOT                  : 92
NOTEQUAL             : 87
NULL                 : 54
OR                   : 89
PLUS                 : 78 90
PRIVATE              : 14 17
PUBLIC               : 13 16
RBRACKET             : 
RCURLY               : 2 3 35
RETURN               : 43 44
RPAREN               : 26 27 28 29 30 31 39 40 41 42 60 61 62 67 68
SEMICOLON            : 18 42 42 43 44 45 46 47 50
SETEQUAL             : 77
STATIC               : 15 16 17
STRING               : 53
SUPER                : 59
THIS                 : 58
TIMES                : 80
TRUE                 : 56
VOID                 : 28 29
WHILE                : 41
error                : 
float_const          : 
int_const            : 
string_const         : 

Nonterminals, with rules where they appear

arguments            : 62 66 67
arith_op             : 71
assign               : 70 93
block                : 26 27 28 29 30 31 42 48
bool_op              : 72
class_body           : 2 3 7 8 9
class_decl           : 1
constructor_decl     : 6 8
empty                : 10 36
expression           : 39 40 41 42 43 60 65 66 71 71 72 72 73 77
field_access         : 67 68 74
field_decl           : 4 7
formal_param         : 32 33
formals              : 27 29 31 33
lhs                  : 64 77
literal              : 57
method_decl          : 5 9
method_invocation    : 63 94
modifier             : 12 26 27 28 29 30 31
primary              : 69 75
start                : 0
stmt                 : 37 38 39 40 40 41
stmt_expression      : 42 42 45
stmtlist             : 35 38
type                 : 18 26 27 34
unary_op             : 73
var_decl             : 11 12 49
variable             : 23 24 34
variables            : 18 24

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . class_decl
    (2) class_decl -> . CLASS ID LCURLY class_body RCURLY
    (3) class_decl -> . CLASS ID EXTENDS ID LCURLY class_body RCURLY

    CLASS           shift and go to state 3

    start                          shift and go to state 1
    class_decl                     shift and go to state 2

state 1

    (0) S' -> start .



state 2

    (1) start -> class_decl .

    $end            reduce using rule 1 (start -> class_decl .)


state 3

    (2) class_decl -> CLASS . ID LCURLY class_body RCURLY
    (3) class_decl -> CLASS . ID EXTENDS ID LCURLY class_body RCURLY

    ID              shift and go to state 4


state 4

    (2) class_decl -> CLASS ID . LCURLY class_body RCURLY
    (3) class_decl -> CLASS ID . EXTENDS ID LCURLY class_body RCURLY

    LCURLY          shift and go to state 5
    EXTENDS         shift and go to state 6


state 5

    (2) class_decl -> CLASS ID LCURLY . class_body RCURLY
    (4) class_body -> . field_decl
    (5) class_body -> . method_decl
    (6) class_body -> . constructor_decl
    (7) class_body -> . class_body field_decl
    (8) class_body -> . class_body constructor_decl
    (9) class_body -> . class_body method_decl
    (10) class_body -> . empty
    (11) field_decl -> . var_decl
    (12) field_decl -> . modifier var_decl
    (26) method_decl -> . modifier type ID LPAREN RPAREN block
    (27) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (28) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (29) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (30) constructor_decl -> . modifier ID LPAREN RPAREN block
    (31) constructor_decl -> . modifier ID LPAREN formals RPAREN block
    (95) empty -> .
    (18) var_decl -> . type variables SEMICOLON
    (13) modifier -> . PUBLIC
    (14) modifier -> . PRIVATE
    (15) modifier -> . STATIC
    (16) modifier -> . PUBLIC STATIC
    (17) modifier -> . PRIVATE STATIC
    (19) type -> . INT
    (20) type -> . FLOAT
    (21) type -> . BOOLEAN
    (22) type -> . ID

  ! shift/reduce conflict for PUBLIC resolved as shift
  ! shift/reduce conflict for PRIVATE resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    RCURLY          reduce using rule 95 (empty -> .)
    PUBLIC          shift and go to state 16
    PRIVATE         shift and go to state 17
    STATIC          shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    BOOLEAN         shift and go to state 21
    ID              shift and go to state 7

  ! PUBLIC          [ reduce using rule 95 (empty -> .) ]
  ! PRIVATE         [ reduce using rule 95 (empty -> .) ]
  ! STATIC          [ reduce using rule 95 (empty -> .) ]
  ! INT             [ reduce using rule 95 (empty -> .) ]
  ! FLOAT           [ reduce using rule 95 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 95 (empty -> .) ]
  ! ID              [ reduce using rule 95 (empty -> .) ]

    class_body                     shift and go to state 8
    field_decl                     shift and go to state 9
    method_decl                    shift and go to state 10
    constructor_decl               shift and go to state 11
    empty                          shift and go to state 12
    var_decl                       shift and go to state 13
    modifier                       shift and go to state 14
    type                           shift and go to state 15

state 6

    (3) class_decl -> CLASS ID EXTENDS . ID LCURLY class_body RCURLY

    ID              shift and go to state 22


state 7

    (22) type -> ID .

    ID              reduce using rule 22 (type -> ID .)


state 8

    (2) class_decl -> CLASS ID LCURLY class_body . RCURLY
    (7) class_body -> class_body . field_decl
    (8) class_body -> class_body . constructor_decl
    (9) class_body -> class_body . method_decl
    (11) field_decl -> . var_decl
    (12) field_decl -> . modifier var_decl
    (30) constructor_decl -> . modifier ID LPAREN RPAREN block
    (31) constructor_decl -> . modifier ID LPAREN formals RPAREN block
    (26) method_decl -> . modifier type ID LPAREN RPAREN block
    (27) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (28) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (29) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (18) var_decl -> . type variables SEMICOLON
    (13) modifier -> . PUBLIC
    (14) modifier -> . PRIVATE
    (15) modifier -> . STATIC
    (16) modifier -> . PUBLIC STATIC
    (17) modifier -> . PRIVATE STATIC
    (19) type -> . INT
    (20) type -> . FLOAT
    (21) type -> . BOOLEAN
    (22) type -> . ID

    RCURLY          shift and go to state 23
    PUBLIC          shift and go to state 16
    PRIVATE         shift and go to state 17
    STATIC          shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    BOOLEAN         shift and go to state 21
    ID              shift and go to state 7

    field_decl                     shift and go to state 24
    constructor_decl               shift and go to state 25
    method_decl                    shift and go to state 26
    var_decl                       shift and go to state 13
    modifier                       shift and go to state 27
    type                           shift and go to state 15

state 9

    (4) class_body -> field_decl .

    RCURLY          reduce using rule 4 (class_body -> field_decl .)
    PUBLIC          reduce using rule 4 (class_body -> field_decl .)
    PRIVATE         reduce using rule 4 (class_body -> field_decl .)
    STATIC          reduce using rule 4 (class_body -> field_decl .)
    INT             reduce using rule 4 (class_body -> field_decl .)
    FLOAT           reduce using rule 4 (class_body -> field_decl .)
    BOOLEAN         reduce using rule 4 (class_body -> field_decl .)
    ID              reduce using rule 4 (class_body -> field_decl .)


state 10

    (5) class_body -> method_decl .

    RCURLY          reduce using rule 5 (class_body -> method_decl .)
    PUBLIC          reduce using rule 5 (class_body -> method_decl .)
    PRIVATE         reduce using rule 5 (class_body -> method_decl .)
    STATIC          reduce using rule 5 (class_body -> method_decl .)
    INT             reduce using rule 5 (class_body -> method_decl .)
    FLOAT           reduce using rule 5 (class_body -> method_decl .)
    BOOLEAN         reduce using rule 5 (class_body -> method_decl .)
    ID              reduce using rule 5 (class_body -> method_decl .)


state 11

    (6) class_body -> constructor_decl .

    RCURLY          reduce using rule 6 (class_body -> constructor_decl .)
    PUBLIC          reduce using rule 6 (class_body -> constructor_decl .)
    PRIVATE         reduce using rule 6 (class_body -> constructor_decl .)
    STATIC          reduce using rule 6 (class_body -> constructor_decl .)
    INT             reduce using rule 6 (class_body -> constructor_decl .)
    FLOAT           reduce using rule 6 (class_body -> constructor_decl .)
    BOOLEAN         reduce using rule 6 (class_body -> constructor_decl .)
    ID              reduce using rule 6 (class_body -> constructor_decl .)


state 12

    (10) class_body -> empty .

    RCURLY          reduce using rule 10 (class_body -> empty .)
    PUBLIC          reduce using rule 10 (class_body -> empty .)
    PRIVATE         reduce using rule 10 (class_body -> empty .)
    STATIC          reduce using rule 10 (class_body -> empty .)
    INT             reduce using rule 10 (class_body -> empty .)
    FLOAT           reduce using rule 10 (class_body -> empty .)
    BOOLEAN         reduce using rule 10 (class_body -> empty .)
    ID              reduce using rule 10 (class_body -> empty .)


state 13

    (11) field_decl -> var_decl .

    RCURLY          reduce using rule 11 (field_decl -> var_decl .)
    PUBLIC          reduce using rule 11 (field_decl -> var_decl .)
    PRIVATE         reduce using rule 11 (field_decl -> var_decl .)
    STATIC          reduce using rule 11 (field_decl -> var_decl .)
    INT             reduce using rule 11 (field_decl -> var_decl .)
    FLOAT           reduce using rule 11 (field_decl -> var_decl .)
    BOOLEAN         reduce using rule 11 (field_decl -> var_decl .)
    ID              reduce using rule 11 (field_decl -> var_decl .)


state 14

    (12) field_decl -> modifier . var_decl
    (26) method_decl -> modifier . type ID LPAREN RPAREN block
    (27) method_decl -> modifier . type ID LPAREN formals RPAREN block
    (28) method_decl -> modifier . VOID ID LPAREN RPAREN block
    (29) method_decl -> modifier . VOID ID LPAREN formals RPAREN block
    (30) constructor_decl -> modifier . ID LPAREN RPAREN block
    (31) constructor_decl -> modifier . ID LPAREN formals RPAREN block
    (18) var_decl -> . type variables SEMICOLON
    (19) type -> . INT
    (20) type -> . FLOAT
    (21) type -> . BOOLEAN
    (22) type -> . ID

    VOID            shift and go to state 31
    ID              shift and go to state 30
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    BOOLEAN         shift and go to state 21

    var_decl                       shift and go to state 28
    type                           shift and go to state 29

state 15

    (18) var_decl -> type . variables SEMICOLON
    (23) variables -> . variable
    (24) variables -> . variable COMMA variables
    (25) variable -> . ID

    ID              shift and go to state 34

    variables                      shift and go to state 32
    variable                       shift and go to state 33

state 16

    (13) modifier -> PUBLIC .
    (16) modifier -> PUBLIC . STATIC

    VOID            reduce using rule 13 (modifier -> PUBLIC .)
    ID              reduce using rule 13 (modifier -> PUBLIC .)
    INT             reduce using rule 13 (modifier -> PUBLIC .)
    FLOAT           reduce using rule 13 (modifier -> PUBLIC .)
    BOOLEAN         reduce using rule 13 (modifier -> PUBLIC .)
    STATIC          shift and go to state 35


state 17

    (14) modifier -> PRIVATE .
    (17) modifier -> PRIVATE . STATIC

    VOID            reduce using rule 14 (modifier -> PRIVATE .)
    ID              reduce using rule 14 (modifier -> PRIVATE .)
    INT             reduce using rule 14 (modifier -> PRIVATE .)
    FLOAT           reduce using rule 14 (modifier -> PRIVATE .)
    BOOLEAN         reduce using rule 14 (modifier -> PRIVATE .)
    STATIC          shift and go to state 36


state 18

    (15) modifier -> STATIC .

    VOID            reduce using rule 15 (modifier -> STATIC .)
    ID              reduce using rule 15 (modifier -> STATIC .)
    INT             reduce using rule 15 (modifier -> STATIC .)
    FLOAT           reduce using rule 15 (modifier -> STATIC .)
    BOOLEAN         reduce using rule 15 (modifier -> STATIC .)


state 19

    (19) type -> INT .

    ID              reduce using rule 19 (type -> INT .)


state 20

    (20) type -> FLOAT .

    ID              reduce using rule 20 (type -> FLOAT .)


state 21

    (21) type -> BOOLEAN .

    ID              reduce using rule 21 (type -> BOOLEAN .)


state 22

    (3) class_decl -> CLASS ID EXTENDS ID . LCURLY class_body RCURLY

    LCURLY          shift and go to state 37


state 23

    (2) class_decl -> CLASS ID LCURLY class_body RCURLY .

    $end            reduce using rule 2 (class_decl -> CLASS ID LCURLY class_body RCURLY .)


state 24

    (7) class_body -> class_body field_decl .

    RCURLY          reduce using rule 7 (class_body -> class_body field_decl .)
    PUBLIC          reduce using rule 7 (class_body -> class_body field_decl .)
    PRIVATE         reduce using rule 7 (class_body -> class_body field_decl .)
    STATIC          reduce using rule 7 (class_body -> class_body field_decl .)
    INT             reduce using rule 7 (class_body -> class_body field_decl .)
    FLOAT           reduce using rule 7 (class_body -> class_body field_decl .)
    BOOLEAN         reduce using rule 7 (class_body -> class_body field_decl .)
    ID              reduce using rule 7 (class_body -> class_body field_decl .)


state 25

    (8) class_body -> class_body constructor_decl .

    RCURLY          reduce using rule 8 (class_body -> class_body constructor_decl .)
    PUBLIC          reduce using rule 8 (class_body -> class_body constructor_decl .)
    PRIVATE         reduce using rule 8 (class_body -> class_body constructor_decl .)
    STATIC          reduce using rule 8 (class_body -> class_body constructor_decl .)
    INT             reduce using rule 8 (class_body -> class_body constructor_decl .)
    FLOAT           reduce using rule 8 (class_body -> class_body constructor_decl .)
    BOOLEAN         reduce using rule 8 (class_body -> class_body constructor_decl .)
    ID              reduce using rule 8 (class_body -> class_body constructor_decl .)


state 26

    (9) class_body -> class_body method_decl .

    RCURLY          reduce using rule 9 (class_body -> class_body method_decl .)
    PUBLIC          reduce using rule 9 (class_body -> class_body method_decl .)
    PRIVATE         reduce using rule 9 (class_body -> class_body method_decl .)
    STATIC          reduce using rule 9 (class_body -> class_body method_decl .)
    INT             reduce using rule 9 (class_body -> class_body method_decl .)
    FLOAT           reduce using rule 9 (class_body -> class_body method_decl .)
    BOOLEAN         reduce using rule 9 (class_body -> class_body method_decl .)
    ID              reduce using rule 9 (class_body -> class_body method_decl .)


state 27

    (12) field_decl -> modifier . var_decl
    (30) constructor_decl -> modifier . ID LPAREN RPAREN block
    (31) constructor_decl -> modifier . ID LPAREN formals RPAREN block
    (26) method_decl -> modifier . type ID LPAREN RPAREN block
    (27) method_decl -> modifier . type ID LPAREN formals RPAREN block
    (28) method_decl -> modifier . VOID ID LPAREN RPAREN block
    (29) method_decl -> modifier . VOID ID LPAREN formals RPAREN block
    (18) var_decl -> . type variables SEMICOLON
    (19) type -> . INT
    (20) type -> . FLOAT
    (21) type -> . BOOLEAN
    (22) type -> . ID

    ID              shift and go to state 30
    VOID            shift and go to state 31
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    BOOLEAN         shift and go to state 21

    var_decl                       shift and go to state 28
    type                           shift and go to state 29

state 28

    (12) field_decl -> modifier var_decl .

    RCURLY          reduce using rule 12 (field_decl -> modifier var_decl .)
    PUBLIC          reduce using rule 12 (field_decl -> modifier var_decl .)
    PRIVATE         reduce using rule 12 (field_decl -> modifier var_decl .)
    STATIC          reduce using rule 12 (field_decl -> modifier var_decl .)
    INT             reduce using rule 12 (field_decl -> modifier var_decl .)
    FLOAT           reduce using rule 12 (field_decl -> modifier var_decl .)
    BOOLEAN         reduce using rule 12 (field_decl -> modifier var_decl .)
    ID              reduce using rule 12 (field_decl -> modifier var_decl .)


state 29

    (26) method_decl -> modifier type . ID LPAREN RPAREN block
    (27) method_decl -> modifier type . ID LPAREN formals RPAREN block
    (18) var_decl -> type . variables SEMICOLON
    (23) variables -> . variable
    (24) variables -> . variable COMMA variables
    (25) variable -> . ID

    ID              shift and go to state 38

    variables                      shift and go to state 32
    variable                       shift and go to state 33

state 30

    (30) constructor_decl -> modifier ID . LPAREN RPAREN block
    (31) constructor_decl -> modifier ID . LPAREN formals RPAREN block
    (22) type -> ID .

    LPAREN          shift and go to state 39
    ID              reduce using rule 22 (type -> ID .)


state 31

    (28) method_decl -> modifier VOID . ID LPAREN RPAREN block
    (29) method_decl -> modifier VOID . ID LPAREN formals RPAREN block

    ID              shift and go to state 40


state 32

    (18) var_decl -> type variables . SEMICOLON

    SEMICOLON       shift and go to state 41


state 33

    (23) variables -> variable .
    (24) variables -> variable . COMMA variables

    SEMICOLON       reduce using rule 23 (variables -> variable .)
    COMMA           shift and go to state 42


state 34

    (25) variable -> ID .

    COMMA           reduce using rule 25 (variable -> ID .)
    SEMICOLON       reduce using rule 25 (variable -> ID .)
    RPAREN          reduce using rule 25 (variable -> ID .)


state 35

    (16) modifier -> PUBLIC STATIC .

    VOID            reduce using rule 16 (modifier -> PUBLIC STATIC .)
    ID              reduce using rule 16 (modifier -> PUBLIC STATIC .)
    INT             reduce using rule 16 (modifier -> PUBLIC STATIC .)
    FLOAT           reduce using rule 16 (modifier -> PUBLIC STATIC .)
    BOOLEAN         reduce using rule 16 (modifier -> PUBLIC STATIC .)


state 36

    (17) modifier -> PRIVATE STATIC .

    VOID            reduce using rule 17 (modifier -> PRIVATE STATIC .)
    ID              reduce using rule 17 (modifier -> PRIVATE STATIC .)
    INT             reduce using rule 17 (modifier -> PRIVATE STATIC .)
    FLOAT           reduce using rule 17 (modifier -> PRIVATE STATIC .)
    BOOLEAN         reduce using rule 17 (modifier -> PRIVATE STATIC .)


state 37

    (3) class_decl -> CLASS ID EXTENDS ID LCURLY . class_body RCURLY
    (4) class_body -> . field_decl
    (5) class_body -> . method_decl
    (6) class_body -> . constructor_decl
    (7) class_body -> . class_body field_decl
    (8) class_body -> . class_body constructor_decl
    (9) class_body -> . class_body method_decl
    (10) class_body -> . empty
    (11) field_decl -> . var_decl
    (12) field_decl -> . modifier var_decl
    (26) method_decl -> . modifier type ID LPAREN RPAREN block
    (27) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (28) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (29) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (30) constructor_decl -> . modifier ID LPAREN RPAREN block
    (31) constructor_decl -> . modifier ID LPAREN formals RPAREN block
    (95) empty -> .
    (18) var_decl -> . type variables SEMICOLON
    (13) modifier -> . PUBLIC
    (14) modifier -> . PRIVATE
    (15) modifier -> . STATIC
    (16) modifier -> . PUBLIC STATIC
    (17) modifier -> . PRIVATE STATIC
    (19) type -> . INT
    (20) type -> . FLOAT
    (21) type -> . BOOLEAN
    (22) type -> . ID

  ! shift/reduce conflict for PUBLIC resolved as shift
  ! shift/reduce conflict for PRIVATE resolved as shift
  ! shift/reduce conflict for STATIC resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
    RCURLY          reduce using rule 95 (empty -> .)
    PUBLIC          shift and go to state 16
    PRIVATE         shift and go to state 17
    STATIC          shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    BOOLEAN         shift and go to state 21
    ID              shift and go to state 7

  ! PUBLIC          [ reduce using rule 95 (empty -> .) ]
  ! PRIVATE         [ reduce using rule 95 (empty -> .) ]
  ! STATIC          [ reduce using rule 95 (empty -> .) ]
  ! INT             [ reduce using rule 95 (empty -> .) ]
  ! FLOAT           [ reduce using rule 95 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 95 (empty -> .) ]
  ! ID              [ reduce using rule 95 (empty -> .) ]

    class_body                     shift and go to state 43
    field_decl                     shift and go to state 9
    method_decl                    shift and go to state 10
    constructor_decl               shift and go to state 11
    empty                          shift and go to state 12
    var_decl                       shift and go to state 13
    modifier                       shift and go to state 14
    type                           shift and go to state 15

state 38

    (26) method_decl -> modifier type ID . LPAREN RPAREN block
    (27) method_decl -> modifier type ID . LPAREN formals RPAREN block
    (25) variable -> ID .

    LPAREN          shift and go to state 44
    COMMA           reduce using rule 25 (variable -> ID .)
    SEMICOLON       reduce using rule 25 (variable -> ID .)


state 39

    (30) constructor_decl -> modifier ID LPAREN . RPAREN block
    (31) constructor_decl -> modifier ID LPAREN . formals RPAREN block
    (32) formals -> . formal_param
    (33) formals -> . formal_param COMMA formals
    (34) formal_param -> . type variable
    (19) type -> . INT
    (20) type -> . FLOAT
    (21) type -> . BOOLEAN
    (22) type -> . ID

    RPAREN          shift and go to state 45
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    BOOLEAN         shift and go to state 21
    ID              shift and go to state 7

    formals                        shift and go to state 46
    formal_param                   shift and go to state 47
    type                           shift and go to state 48

state 40

    (28) method_decl -> modifier VOID ID . LPAREN RPAREN block
    (29) method_decl -> modifier VOID ID . LPAREN formals RPAREN block

    LPAREN          shift and go to state 49


state 41

    (18) var_decl -> type variables SEMICOLON .

    RCURLY          reduce using rule 18 (var_decl -> type variables SEMICOLON .)
    PUBLIC          reduce using rule 18 (var_decl -> type variables SEMICOLON .)
    PRIVATE         reduce using rule 18 (var_decl -> type variables SEMICOLON .)
    STATIC          reduce using rule 18 (var_decl -> type variables SEMICOLON .)
    INT             reduce using rule 18 (var_decl -> type variables SEMICOLON .)
    FLOAT           reduce using rule 18 (var_decl -> type variables SEMICOLON .)
    BOOLEAN         reduce using rule 18 (var_decl -> type variables SEMICOLON .)
    ID              reduce using rule 18 (var_decl -> type variables SEMICOLON .)
    IF              reduce using rule 18 (var_decl -> type variables SEMICOLON .)
    WHILE           reduce using rule 18 (var_decl -> type variables SEMICOLON .)
    FOR             reduce using rule 18 (var_decl -> type variables SEMICOLON .)
    RETURN          reduce using rule 18 (var_decl -> type variables SEMICOLON .)
    BREAK           reduce using rule 18 (var_decl -> type variables SEMICOLON .)
    CONTINUE        reduce using rule 18 (var_decl -> type variables SEMICOLON .)
    SEMICOLON       reduce using rule 18 (var_decl -> type variables SEMICOLON .)
    LCURLY          reduce using rule 18 (var_decl -> type variables SEMICOLON .)
    THIS            reduce using rule 18 (var_decl -> type variables SEMICOLON .)
    SUPER           reduce using rule 18 (var_decl -> type variables SEMICOLON .)
    LPAREN          reduce using rule 18 (var_decl -> type variables SEMICOLON .)
    NEW             reduce using rule 18 (var_decl -> type variables SEMICOLON .)
    INTEGER         reduce using rule 18 (var_decl -> type variables SEMICOLON .)
    STRING          reduce using rule 18 (var_decl -> type variables SEMICOLON .)
    NULL            reduce using rule 18 (var_decl -> type variables SEMICOLON .)
    FALSE           reduce using rule 18 (var_decl -> type variables SEMICOLON .)
    TRUE            reduce using rule 18 (var_decl -> type variables SEMICOLON .)
    ELSE            reduce using rule 18 (var_decl -> type variables SEMICOLON .)


state 42

    (24) variables -> variable COMMA . variables
    (23) variables -> . variable
    (24) variables -> . variable COMMA variables
    (25) variable -> . ID

    ID              shift and go to state 34

    variable                       shift and go to state 33
    variables                      shift and go to state 50

state 43

    (3) class_decl -> CLASS ID EXTENDS ID LCURLY class_body . RCURLY
    (7) class_body -> class_body . field_decl
    (8) class_body -> class_body . constructor_decl
    (9) class_body -> class_body . method_decl
    (11) field_decl -> . var_decl
    (12) field_decl -> . modifier var_decl
    (30) constructor_decl -> . modifier ID LPAREN RPAREN block
    (31) constructor_decl -> . modifier ID LPAREN formals RPAREN block
    (26) method_decl -> . modifier type ID LPAREN RPAREN block
    (27) method_decl -> . modifier type ID LPAREN formals RPAREN block
    (28) method_decl -> . modifier VOID ID LPAREN RPAREN block
    (29) method_decl -> . modifier VOID ID LPAREN formals RPAREN block
    (18) var_decl -> . type variables SEMICOLON
    (13) modifier -> . PUBLIC
    (14) modifier -> . PRIVATE
    (15) modifier -> . STATIC
    (16) modifier -> . PUBLIC STATIC
    (17) modifier -> . PRIVATE STATIC
    (19) type -> . INT
    (20) type -> . FLOAT
    (21) type -> . BOOLEAN
    (22) type -> . ID

    RCURLY          shift and go to state 51
    PUBLIC          shift and go to state 16
    PRIVATE         shift and go to state 17
    STATIC          shift and go to state 18
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    BOOLEAN         shift and go to state 21
    ID              shift and go to state 7

    field_decl                     shift and go to state 24
    constructor_decl               shift and go to state 25
    method_decl                    shift and go to state 26
    var_decl                       shift and go to state 13
    modifier                       shift and go to state 27
    type                           shift and go to state 15

state 44

    (26) method_decl -> modifier type ID LPAREN . RPAREN block
    (27) method_decl -> modifier type ID LPAREN . formals RPAREN block
    (32) formals -> . formal_param
    (33) formals -> . formal_param COMMA formals
    (34) formal_param -> . type variable
    (19) type -> . INT
    (20) type -> . FLOAT
    (21) type -> . BOOLEAN
    (22) type -> . ID

    RPAREN          shift and go to state 52
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    BOOLEAN         shift and go to state 21
    ID              shift and go to state 7

    type                           shift and go to state 48
    formals                        shift and go to state 53
    formal_param                   shift and go to state 47

state 45

    (30) constructor_decl -> modifier ID LPAREN RPAREN . block
    (35) block -> . LCURLY stmtlist RCURLY
    (36) block -> . empty
    (95) empty -> .

    LCURLY          shift and go to state 55
    RCURLY          reduce using rule 95 (empty -> .)
    PUBLIC          reduce using rule 95 (empty -> .)
    PRIVATE         reduce using rule 95 (empty -> .)
    STATIC          reduce using rule 95 (empty -> .)
    INT             reduce using rule 95 (empty -> .)
    FLOAT           reduce using rule 95 (empty -> .)
    BOOLEAN         reduce using rule 95 (empty -> .)
    ID              reduce using rule 95 (empty -> .)

    block                          shift and go to state 54
    empty                          shift and go to state 56

state 46

    (31) constructor_decl -> modifier ID LPAREN formals . RPAREN block

    RPAREN          shift and go to state 57


state 47

    (32) formals -> formal_param .
    (33) formals -> formal_param . COMMA formals

    RPAREN          reduce using rule 32 (formals -> formal_param .)
    COMMA           shift and go to state 58


state 48

    (34) formal_param -> type . variable
    (25) variable -> . ID

    ID              shift and go to state 34

    variable                       shift and go to state 59

state 49

    (28) method_decl -> modifier VOID ID LPAREN . RPAREN block
    (29) method_decl -> modifier VOID ID LPAREN . formals RPAREN block
    (32) formals -> . formal_param
    (33) formals -> . formal_param COMMA formals
    (34) formal_param -> . type variable
    (19) type -> . INT
    (20) type -> . FLOAT
    (21) type -> . BOOLEAN
    (22) type -> . ID

    RPAREN          shift and go to state 60
    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    BOOLEAN         shift and go to state 21
    ID              shift and go to state 7

    formals                        shift and go to state 61
    formal_param                   shift and go to state 47
    type                           shift and go to state 48

state 50

    (24) variables -> variable COMMA variables .

    SEMICOLON       reduce using rule 24 (variables -> variable COMMA variables .)


state 51

    (3) class_decl -> CLASS ID EXTENDS ID LCURLY class_body RCURLY .

    $end            reduce using rule 3 (class_decl -> CLASS ID EXTENDS ID LCURLY class_body RCURLY .)


state 52

    (26) method_decl -> modifier type ID LPAREN RPAREN . block
    (35) block -> . LCURLY stmtlist RCURLY
    (36) block -> . empty
    (95) empty -> .

    LCURLY          shift and go to state 55
    RCURLY          reduce using rule 95 (empty -> .)
    PUBLIC          reduce using rule 95 (empty -> .)
    PRIVATE         reduce using rule 95 (empty -> .)
    STATIC          reduce using rule 95 (empty -> .)
    INT             reduce using rule 95 (empty -> .)
    FLOAT           reduce using rule 95 (empty -> .)
    BOOLEAN         reduce using rule 95 (empty -> .)
    ID              reduce using rule 95 (empty -> .)

    block                          shift and go to state 62
    empty                          shift and go to state 56

state 53

    (27) method_decl -> modifier type ID LPAREN formals . RPAREN block

    RPAREN          shift and go to state 63


state 54

    (30) constructor_decl -> modifier ID LPAREN RPAREN block .

    RCURLY          reduce using rule 30 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    PUBLIC          reduce using rule 30 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    PRIVATE         reduce using rule 30 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    STATIC          reduce using rule 30 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    INT             reduce using rule 30 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    FLOAT           reduce using rule 30 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 30 (constructor_decl -> modifier ID LPAREN RPAREN block .)
    ID              reduce using rule 30 (constructor_decl -> modifier ID LPAREN RPAREN block .)


state 55

    (35) block -> LCURLY . stmtlist RCURLY
    (37) stmtlist -> . stmt
    (38) stmtlist -> . stmtlist stmt
    (39) stmt -> . IF LPAREN expression RPAREN stmt
    (40) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (41) stmt -> . WHILE LPAREN expression RPAREN stmt
    (42) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block
    (43) stmt -> . RETURN expression SEMICOLON
    (44) stmt -> . RETURN SEMICOLON
    (45) stmt -> . stmt_expression SEMICOLON
    (46) stmt -> . BREAK SEMICOLON
    (47) stmt -> . CONTINUE SEMICOLON
    (48) stmt -> . block
    (49) stmt -> . var_decl
    (50) stmt -> . SEMICOLON
    (93) stmt_expression -> . assign
    (94) stmt_expression -> . method_invocation
    (35) block -> . LCURLY stmtlist RCURLY
    (36) block -> . empty
    (18) var_decl -> . type variables SEMICOLON
    (77) assign -> . lhs SETEQUAL expression
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (95) empty -> .
    (19) type -> . INT
    (20) type -> . FLOAT
    (21) type -> . BOOLEAN
    (22) type -> . ID
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . LPAREN expression RPAREN
    (61) primary -> . NEW ID LPAREN RPAREN
    (62) primary -> . NEW ID LPAREN arguments RPAREN
    (63) primary -> . method_invocation
    (64) primary -> . lhs
    (51) literal -> . INTEGER
    (52) literal -> . FLOAT
    (53) literal -> . STRING
    (54) literal -> . NULL
    (55) literal -> . FALSE
    (56) literal -> . TRUE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    IF              shift and go to state 66
    WHILE           shift and go to state 68
    FOR             shift and go to state 69
    RETURN          shift and go to state 73
    BREAK           shift and go to state 74
    CONTINUE        shift and go to state 75
    SEMICOLON       shift and go to state 71
    LCURLY          shift and go to state 55
    RCURLY          reduce using rule 95 (empty -> .)
    INT             shift and go to state 19
    FLOAT           shift and go to state 81
    BOOLEAN         shift and go to state 21
    ID              shift and go to state 82
    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 67
    NEW             shift and go to state 87
    INTEGER         shift and go to state 88
    STRING          shift and go to state 89
    NULL            shift and go to state 90
    FALSE           shift and go to state 91
    TRUE            shift and go to state 92

  ! IF              [ reduce using rule 95 (empty -> .) ]
  ! WHILE           [ reduce using rule 95 (empty -> .) ]
  ! FOR             [ reduce using rule 95 (empty -> .) ]
  ! RETURN          [ reduce using rule 95 (empty -> .) ]
  ! BREAK           [ reduce using rule 95 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 95 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 95 (empty -> .) ]
  ! LCURLY          [ reduce using rule 95 (empty -> .) ]
  ! INT             [ reduce using rule 95 (empty -> .) ]
  ! FLOAT           [ reduce using rule 95 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 95 (empty -> .) ]
  ! ID              [ reduce using rule 95 (empty -> .) ]
  ! THIS            [ reduce using rule 95 (empty -> .) ]
  ! SUPER           [ reduce using rule 95 (empty -> .) ]
  ! LPAREN          [ reduce using rule 95 (empty -> .) ]
  ! NEW             [ reduce using rule 95 (empty -> .) ]
  ! INTEGER         [ reduce using rule 95 (empty -> .) ]
  ! STRING          [ reduce using rule 95 (empty -> .) ]
  ! NULL            [ reduce using rule 95 (empty -> .) ]
  ! FALSE           [ reduce using rule 95 (empty -> .) ]
  ! TRUE            [ reduce using rule 95 (empty -> .) ]

    stmtlist                       shift and go to state 64
    stmt                           shift and go to state 65
    stmt_expression                shift and go to state 70
    block                          shift and go to state 72
    var_decl                       shift and go to state 76
    assign                         shift and go to state 77
    method_invocation              shift and go to state 78
    empty                          shift and go to state 56
    type                           shift and go to state 15
    lhs                            shift and go to state 79
    field_access                   shift and go to state 80
    primary                        shift and go to state 83
    literal                        shift and go to state 84

state 56

    (36) block -> empty .

    RCURLY          reduce using rule 36 (block -> empty .)
    PUBLIC          reduce using rule 36 (block -> empty .)
    PRIVATE         reduce using rule 36 (block -> empty .)
    STATIC          reduce using rule 36 (block -> empty .)
    INT             reduce using rule 36 (block -> empty .)
    FLOAT           reduce using rule 36 (block -> empty .)
    BOOLEAN         reduce using rule 36 (block -> empty .)
    ID              reduce using rule 36 (block -> empty .)
    IF              reduce using rule 36 (block -> empty .)
    WHILE           reduce using rule 36 (block -> empty .)
    FOR             reduce using rule 36 (block -> empty .)
    RETURN          reduce using rule 36 (block -> empty .)
    BREAK           reduce using rule 36 (block -> empty .)
    CONTINUE        reduce using rule 36 (block -> empty .)
    SEMICOLON       reduce using rule 36 (block -> empty .)
    LCURLY          reduce using rule 36 (block -> empty .)
    THIS            reduce using rule 36 (block -> empty .)
    SUPER           reduce using rule 36 (block -> empty .)
    LPAREN          reduce using rule 36 (block -> empty .)
    NEW             reduce using rule 36 (block -> empty .)
    INTEGER         reduce using rule 36 (block -> empty .)
    STRING          reduce using rule 36 (block -> empty .)
    NULL            reduce using rule 36 (block -> empty .)
    FALSE           reduce using rule 36 (block -> empty .)
    TRUE            reduce using rule 36 (block -> empty .)
    ELSE            reduce using rule 36 (block -> empty .)


state 57

    (31) constructor_decl -> modifier ID LPAREN formals RPAREN . block
    (35) block -> . LCURLY stmtlist RCURLY
    (36) block -> . empty
    (95) empty -> .

    LCURLY          shift and go to state 55
    RCURLY          reduce using rule 95 (empty -> .)
    PUBLIC          reduce using rule 95 (empty -> .)
    PRIVATE         reduce using rule 95 (empty -> .)
    STATIC          reduce using rule 95 (empty -> .)
    INT             reduce using rule 95 (empty -> .)
    FLOAT           reduce using rule 95 (empty -> .)
    BOOLEAN         reduce using rule 95 (empty -> .)
    ID              reduce using rule 95 (empty -> .)

    block                          shift and go to state 93
    empty                          shift and go to state 56

state 58

    (33) formals -> formal_param COMMA . formals
    (32) formals -> . formal_param
    (33) formals -> . formal_param COMMA formals
    (34) formal_param -> . type variable
    (19) type -> . INT
    (20) type -> . FLOAT
    (21) type -> . BOOLEAN
    (22) type -> . ID

    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    BOOLEAN         shift and go to state 21
    ID              shift and go to state 7

    formal_param                   shift and go to state 47
    formals                        shift and go to state 94
    type                           shift and go to state 48

state 59

    (34) formal_param -> type variable .

    COMMA           reduce using rule 34 (formal_param -> type variable .)
    RPAREN          reduce using rule 34 (formal_param -> type variable .)


state 60

    (28) method_decl -> modifier VOID ID LPAREN RPAREN . block
    (35) block -> . LCURLY stmtlist RCURLY
    (36) block -> . empty
    (95) empty -> .

    LCURLY          shift and go to state 55
    RCURLY          reduce using rule 95 (empty -> .)
    PUBLIC          reduce using rule 95 (empty -> .)
    PRIVATE         reduce using rule 95 (empty -> .)
    STATIC          reduce using rule 95 (empty -> .)
    INT             reduce using rule 95 (empty -> .)
    FLOAT           reduce using rule 95 (empty -> .)
    BOOLEAN         reduce using rule 95 (empty -> .)
    ID              reduce using rule 95 (empty -> .)

    block                          shift and go to state 95
    empty                          shift and go to state 56

state 61

    (29) method_decl -> modifier VOID ID LPAREN formals . RPAREN block

    RPAREN          shift and go to state 96


state 62

    (26) method_decl -> modifier type ID LPAREN RPAREN block .

    RCURLY          reduce using rule 26 (method_decl -> modifier type ID LPAREN RPAREN block .)
    PUBLIC          reduce using rule 26 (method_decl -> modifier type ID LPAREN RPAREN block .)
    PRIVATE         reduce using rule 26 (method_decl -> modifier type ID LPAREN RPAREN block .)
    STATIC          reduce using rule 26 (method_decl -> modifier type ID LPAREN RPAREN block .)
    INT             reduce using rule 26 (method_decl -> modifier type ID LPAREN RPAREN block .)
    FLOAT           reduce using rule 26 (method_decl -> modifier type ID LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 26 (method_decl -> modifier type ID LPAREN RPAREN block .)
    ID              reduce using rule 26 (method_decl -> modifier type ID LPAREN RPAREN block .)


state 63

    (27) method_decl -> modifier type ID LPAREN formals RPAREN . block
    (35) block -> . LCURLY stmtlist RCURLY
    (36) block -> . empty
    (95) empty -> .

    LCURLY          shift and go to state 55
    RCURLY          reduce using rule 95 (empty -> .)
    PUBLIC          reduce using rule 95 (empty -> .)
    PRIVATE         reduce using rule 95 (empty -> .)
    STATIC          reduce using rule 95 (empty -> .)
    INT             reduce using rule 95 (empty -> .)
    FLOAT           reduce using rule 95 (empty -> .)
    BOOLEAN         reduce using rule 95 (empty -> .)
    ID              reduce using rule 95 (empty -> .)

    block                          shift and go to state 97
    empty                          shift and go to state 56

state 64

    (35) block -> LCURLY stmtlist . RCURLY
    (38) stmtlist -> stmtlist . stmt
    (39) stmt -> . IF LPAREN expression RPAREN stmt
    (40) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (41) stmt -> . WHILE LPAREN expression RPAREN stmt
    (42) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block
    (43) stmt -> . RETURN expression SEMICOLON
    (44) stmt -> . RETURN SEMICOLON
    (45) stmt -> . stmt_expression SEMICOLON
    (46) stmt -> . BREAK SEMICOLON
    (47) stmt -> . CONTINUE SEMICOLON
    (48) stmt -> . block
    (49) stmt -> . var_decl
    (50) stmt -> . SEMICOLON
    (93) stmt_expression -> . assign
    (94) stmt_expression -> . method_invocation
    (35) block -> . LCURLY stmtlist RCURLY
    (36) block -> . empty
    (18) var_decl -> . type variables SEMICOLON
    (77) assign -> . lhs SETEQUAL expression
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (95) empty -> .
    (19) type -> . INT
    (20) type -> . FLOAT
    (21) type -> . BOOLEAN
    (22) type -> . ID
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . LPAREN expression RPAREN
    (61) primary -> . NEW ID LPAREN RPAREN
    (62) primary -> . NEW ID LPAREN arguments RPAREN
    (63) primary -> . method_invocation
    (64) primary -> . lhs
    (51) literal -> . INTEGER
    (52) literal -> . FLOAT
    (53) literal -> . STRING
    (54) literal -> . NULL
    (55) literal -> . FALSE
    (56) literal -> . TRUE

  ! shift/reduce conflict for RCURLY resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    RCURLY          shift and go to state 98
    IF              shift and go to state 66
    WHILE           shift and go to state 68
    FOR             shift and go to state 69
    RETURN          shift and go to state 73
    BREAK           shift and go to state 74
    CONTINUE        shift and go to state 75
    SEMICOLON       shift and go to state 71
    LCURLY          shift and go to state 55
    INT             shift and go to state 19
    FLOAT           shift and go to state 81
    BOOLEAN         shift and go to state 21
    ID              shift and go to state 82
    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 67
    NEW             shift and go to state 87
    INTEGER         shift and go to state 88
    STRING          shift and go to state 89
    NULL            shift and go to state 90
    FALSE           shift and go to state 91
    TRUE            shift and go to state 92

  ! RCURLY          [ reduce using rule 95 (empty -> .) ]
  ! IF              [ reduce using rule 95 (empty -> .) ]
  ! WHILE           [ reduce using rule 95 (empty -> .) ]
  ! FOR             [ reduce using rule 95 (empty -> .) ]
  ! RETURN          [ reduce using rule 95 (empty -> .) ]
  ! BREAK           [ reduce using rule 95 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 95 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 95 (empty -> .) ]
  ! LCURLY          [ reduce using rule 95 (empty -> .) ]
  ! INT             [ reduce using rule 95 (empty -> .) ]
  ! FLOAT           [ reduce using rule 95 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 95 (empty -> .) ]
  ! ID              [ reduce using rule 95 (empty -> .) ]
  ! THIS            [ reduce using rule 95 (empty -> .) ]
  ! SUPER           [ reduce using rule 95 (empty -> .) ]
  ! LPAREN          [ reduce using rule 95 (empty -> .) ]
  ! NEW             [ reduce using rule 95 (empty -> .) ]
  ! INTEGER         [ reduce using rule 95 (empty -> .) ]
  ! STRING          [ reduce using rule 95 (empty -> .) ]
  ! NULL            [ reduce using rule 95 (empty -> .) ]
  ! FALSE           [ reduce using rule 95 (empty -> .) ]
  ! TRUE            [ reduce using rule 95 (empty -> .) ]

    stmt                           shift and go to state 99
    stmt_expression                shift and go to state 70
    block                          shift and go to state 72
    var_decl                       shift and go to state 76
    assign                         shift and go to state 77
    method_invocation              shift and go to state 78
    empty                          shift and go to state 56
    type                           shift and go to state 15
    lhs                            shift and go to state 79
    field_access                   shift and go to state 80
    primary                        shift and go to state 83
    literal                        shift and go to state 84

state 65

    (37) stmtlist -> stmt .

    RCURLY          reduce using rule 37 (stmtlist -> stmt .)
    IF              reduce using rule 37 (stmtlist -> stmt .)
    WHILE           reduce using rule 37 (stmtlist -> stmt .)
    FOR             reduce using rule 37 (stmtlist -> stmt .)
    RETURN          reduce using rule 37 (stmtlist -> stmt .)
    BREAK           reduce using rule 37 (stmtlist -> stmt .)
    CONTINUE        reduce using rule 37 (stmtlist -> stmt .)
    SEMICOLON       reduce using rule 37 (stmtlist -> stmt .)
    LCURLY          reduce using rule 37 (stmtlist -> stmt .)
    INT             reduce using rule 37 (stmtlist -> stmt .)
    FLOAT           reduce using rule 37 (stmtlist -> stmt .)
    BOOLEAN         reduce using rule 37 (stmtlist -> stmt .)
    ID              reduce using rule 37 (stmtlist -> stmt .)
    THIS            reduce using rule 37 (stmtlist -> stmt .)
    SUPER           reduce using rule 37 (stmtlist -> stmt .)
    LPAREN          reduce using rule 37 (stmtlist -> stmt .)
    NEW             reduce using rule 37 (stmtlist -> stmt .)
    INTEGER         reduce using rule 37 (stmtlist -> stmt .)
    STRING          reduce using rule 37 (stmtlist -> stmt .)
    NULL            reduce using rule 37 (stmtlist -> stmt .)
    FALSE           reduce using rule 37 (stmtlist -> stmt .)
    TRUE            reduce using rule 37 (stmtlist -> stmt .)


state 66

    (39) stmt -> IF . LPAREN expression RPAREN stmt
    (40) stmt -> IF . LPAREN expression RPAREN stmt ELSE stmt

    LPAREN          shift and go to state 100


state 67

    (60) primary -> LPAREN . expression RPAREN
    (69) expression -> . primary
    (70) expression -> . assign
    (71) expression -> . expression arith_op expression
    (72) expression -> . expression bool_op expression
    (73) expression -> . unary_op expression
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . LPAREN expression RPAREN
    (61) primary -> . NEW ID LPAREN RPAREN
    (62) primary -> . NEW ID LPAREN arguments RPAREN
    (63) primary -> . method_invocation
    (64) primary -> . lhs
    (77) assign -> . lhs SETEQUAL expression
    (90) unary_op -> . PLUS
    (91) unary_op -> . MINUS
    (92) unary_op -> . NOT
    (51) literal -> . INTEGER
    (52) literal -> . FLOAT
    (53) literal -> . STRING
    (54) literal -> . NULL
    (55) literal -> . FALSE
    (56) literal -> . TRUE
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 67
    NEW             shift and go to state 87
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    NOT             shift and go to state 110
    INTEGER         shift and go to state 88
    FLOAT           shift and go to state 111
    STRING          shift and go to state 89
    NULL            shift and go to state 90
    FALSE           shift and go to state 91
    TRUE            shift and go to state 92
    ID              shift and go to state 105

    expression                     shift and go to state 101
    primary                        shift and go to state 102
    assign                         shift and go to state 103
    unary_op                       shift and go to state 104
    literal                        shift and go to state 84
    method_invocation              shift and go to state 106
    lhs                            shift and go to state 107
    field_access                   shift and go to state 80

state 68

    (41) stmt -> WHILE . LPAREN expression RPAREN stmt

    LPAREN          shift and go to state 112


state 69

    (42) stmt -> FOR . LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block

    LPAREN          shift and go to state 113


state 70

    (45) stmt -> stmt_expression . SEMICOLON

    SEMICOLON       shift and go to state 114


state 71

    (50) stmt -> SEMICOLON .

    RCURLY          reduce using rule 50 (stmt -> SEMICOLON .)
    IF              reduce using rule 50 (stmt -> SEMICOLON .)
    WHILE           reduce using rule 50 (stmt -> SEMICOLON .)
    FOR             reduce using rule 50 (stmt -> SEMICOLON .)
    RETURN          reduce using rule 50 (stmt -> SEMICOLON .)
    BREAK           reduce using rule 50 (stmt -> SEMICOLON .)
    CONTINUE        reduce using rule 50 (stmt -> SEMICOLON .)
    SEMICOLON       reduce using rule 50 (stmt -> SEMICOLON .)
    LCURLY          reduce using rule 50 (stmt -> SEMICOLON .)
    INT             reduce using rule 50 (stmt -> SEMICOLON .)
    FLOAT           reduce using rule 50 (stmt -> SEMICOLON .)
    BOOLEAN         reduce using rule 50 (stmt -> SEMICOLON .)
    ID              reduce using rule 50 (stmt -> SEMICOLON .)
    THIS            reduce using rule 50 (stmt -> SEMICOLON .)
    SUPER           reduce using rule 50 (stmt -> SEMICOLON .)
    LPAREN          reduce using rule 50 (stmt -> SEMICOLON .)
    NEW             reduce using rule 50 (stmt -> SEMICOLON .)
    INTEGER         reduce using rule 50 (stmt -> SEMICOLON .)
    STRING          reduce using rule 50 (stmt -> SEMICOLON .)
    NULL            reduce using rule 50 (stmt -> SEMICOLON .)
    FALSE           reduce using rule 50 (stmt -> SEMICOLON .)
    TRUE            reduce using rule 50 (stmt -> SEMICOLON .)
    ELSE            reduce using rule 50 (stmt -> SEMICOLON .)


state 72

    (48) stmt -> block .

    RCURLY          reduce using rule 48 (stmt -> block .)
    IF              reduce using rule 48 (stmt -> block .)
    WHILE           reduce using rule 48 (stmt -> block .)
    FOR             reduce using rule 48 (stmt -> block .)
    RETURN          reduce using rule 48 (stmt -> block .)
    BREAK           reduce using rule 48 (stmt -> block .)
    CONTINUE        reduce using rule 48 (stmt -> block .)
    SEMICOLON       reduce using rule 48 (stmt -> block .)
    LCURLY          reduce using rule 48 (stmt -> block .)
    INT             reduce using rule 48 (stmt -> block .)
    FLOAT           reduce using rule 48 (stmt -> block .)
    BOOLEAN         reduce using rule 48 (stmt -> block .)
    ID              reduce using rule 48 (stmt -> block .)
    THIS            reduce using rule 48 (stmt -> block .)
    SUPER           reduce using rule 48 (stmt -> block .)
    LPAREN          reduce using rule 48 (stmt -> block .)
    NEW             reduce using rule 48 (stmt -> block .)
    INTEGER         reduce using rule 48 (stmt -> block .)
    STRING          reduce using rule 48 (stmt -> block .)
    NULL            reduce using rule 48 (stmt -> block .)
    FALSE           reduce using rule 48 (stmt -> block .)
    TRUE            reduce using rule 48 (stmt -> block .)
    ELSE            reduce using rule 48 (stmt -> block .)


state 73

    (43) stmt -> RETURN . expression SEMICOLON
    (44) stmt -> RETURN . SEMICOLON
    (69) expression -> . primary
    (70) expression -> . assign
    (71) expression -> . expression arith_op expression
    (72) expression -> . expression bool_op expression
    (73) expression -> . unary_op expression
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . LPAREN expression RPAREN
    (61) primary -> . NEW ID LPAREN RPAREN
    (62) primary -> . NEW ID LPAREN arguments RPAREN
    (63) primary -> . method_invocation
    (64) primary -> . lhs
    (77) assign -> . lhs SETEQUAL expression
    (90) unary_op -> . PLUS
    (91) unary_op -> . MINUS
    (92) unary_op -> . NOT
    (51) literal -> . INTEGER
    (52) literal -> . FLOAT
    (53) literal -> . STRING
    (54) literal -> . NULL
    (55) literal -> . FALSE
    (56) literal -> . TRUE
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    SEMICOLON       shift and go to state 116
    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 67
    NEW             shift and go to state 87
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    NOT             shift and go to state 110
    INTEGER         shift and go to state 88
    FLOAT           shift and go to state 111
    STRING          shift and go to state 89
    NULL            shift and go to state 90
    FALSE           shift and go to state 91
    TRUE            shift and go to state 92
    ID              shift and go to state 105

    expression                     shift and go to state 115
    primary                        shift and go to state 102
    assign                         shift and go to state 103
    unary_op                       shift and go to state 104
    literal                        shift and go to state 84
    method_invocation              shift and go to state 106
    lhs                            shift and go to state 107
    field_access                   shift and go to state 80

state 74

    (46) stmt -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 117


state 75

    (47) stmt -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 118


state 76

    (49) stmt -> var_decl .

    RCURLY          reduce using rule 49 (stmt -> var_decl .)
    IF              reduce using rule 49 (stmt -> var_decl .)
    WHILE           reduce using rule 49 (stmt -> var_decl .)
    FOR             reduce using rule 49 (stmt -> var_decl .)
    RETURN          reduce using rule 49 (stmt -> var_decl .)
    BREAK           reduce using rule 49 (stmt -> var_decl .)
    CONTINUE        reduce using rule 49 (stmt -> var_decl .)
    SEMICOLON       reduce using rule 49 (stmt -> var_decl .)
    LCURLY          reduce using rule 49 (stmt -> var_decl .)
    INT             reduce using rule 49 (stmt -> var_decl .)
    FLOAT           reduce using rule 49 (stmt -> var_decl .)
    BOOLEAN         reduce using rule 49 (stmt -> var_decl .)
    ID              reduce using rule 49 (stmt -> var_decl .)
    THIS            reduce using rule 49 (stmt -> var_decl .)
    SUPER           reduce using rule 49 (stmt -> var_decl .)
    LPAREN          reduce using rule 49 (stmt -> var_decl .)
    NEW             reduce using rule 49 (stmt -> var_decl .)
    INTEGER         reduce using rule 49 (stmt -> var_decl .)
    STRING          reduce using rule 49 (stmt -> var_decl .)
    NULL            reduce using rule 49 (stmt -> var_decl .)
    FALSE           reduce using rule 49 (stmt -> var_decl .)
    TRUE            reduce using rule 49 (stmt -> var_decl .)
    ELSE            reduce using rule 49 (stmt -> var_decl .)


state 77

    (93) stmt_expression -> assign .

    SEMICOLON       reduce using rule 93 (stmt_expression -> assign .)
    RPAREN          reduce using rule 93 (stmt_expression -> assign .)


state 78

    (94) stmt_expression -> method_invocation .
    (63) primary -> method_invocation .

    SEMICOLON       reduce using rule 94 (stmt_expression -> method_invocation .)
    RPAREN          reduce using rule 94 (stmt_expression -> method_invocation .)
    DOT             reduce using rule 63 (primary -> method_invocation .)


state 79

    (77) assign -> lhs . SETEQUAL expression
    (64) primary -> lhs .

    SETEQUAL        shift and go to state 119
    DOT             reduce using rule 64 (primary -> lhs .)


state 80

    (67) method_invocation -> field_access . LPAREN arguments RPAREN
    (68) method_invocation -> field_access . LPAREN RPAREN
    (74) lhs -> field_access .

    LPAREN          shift and go to state 120
    SETEQUAL        reduce using rule 74 (lhs -> field_access .)
    DOT             reduce using rule 74 (lhs -> field_access .)
    RPAREN          reduce using rule 74 (lhs -> field_access .)
    PLUS            reduce using rule 74 (lhs -> field_access .)
    MINUS           reduce using rule 74 (lhs -> field_access .)
    TIMES           reduce using rule 74 (lhs -> field_access .)
    DIVIDE          reduce using rule 74 (lhs -> field_access .)
    GREATER         reduce using rule 74 (lhs -> field_access .)
    LESS            reduce using rule 74 (lhs -> field_access .)
    GREATEREQ       reduce using rule 74 (lhs -> field_access .)
    LESSEQ          reduce using rule 74 (lhs -> field_access .)
    EQUAL           reduce using rule 74 (lhs -> field_access .)
    NOTEQUAL        reduce using rule 74 (lhs -> field_access .)
    AND             reduce using rule 74 (lhs -> field_access .)
    OR              reduce using rule 74 (lhs -> field_access .)
    SEMICOLON       reduce using rule 74 (lhs -> field_access .)
    COMMA           reduce using rule 74 (lhs -> field_access .)


state 81

    (20) type -> FLOAT .
    (52) literal -> FLOAT .

    ID              reduce using rule 20 (type -> FLOAT .)
    DOT             reduce using rule 52 (literal -> FLOAT .)


state 82

    (22) type -> ID .
    (76) field_access -> ID .

    ID              reduce using rule 22 (type -> ID .)
    LPAREN          reduce using rule 76 (field_access -> ID .)
    SETEQUAL        reduce using rule 76 (field_access -> ID .)
    DOT             reduce using rule 76 (field_access -> ID .)


state 83

    (75) field_access -> primary . DOT ID

    DOT             shift and go to state 121


state 84

    (57) primary -> literal .

    DOT             reduce using rule 57 (primary -> literal .)
    RPAREN          reduce using rule 57 (primary -> literal .)
    PLUS            reduce using rule 57 (primary -> literal .)
    MINUS           reduce using rule 57 (primary -> literal .)
    TIMES           reduce using rule 57 (primary -> literal .)
    DIVIDE          reduce using rule 57 (primary -> literal .)
    GREATER         reduce using rule 57 (primary -> literal .)
    LESS            reduce using rule 57 (primary -> literal .)
    GREATEREQ       reduce using rule 57 (primary -> literal .)
    LESSEQ          reduce using rule 57 (primary -> literal .)
    EQUAL           reduce using rule 57 (primary -> literal .)
    NOTEQUAL        reduce using rule 57 (primary -> literal .)
    AND             reduce using rule 57 (primary -> literal .)
    OR              reduce using rule 57 (primary -> literal .)
    SEMICOLON       reduce using rule 57 (primary -> literal .)
    COMMA           reduce using rule 57 (primary -> literal .)


state 85

    (58) primary -> THIS .

    DOT             reduce using rule 58 (primary -> THIS .)
    RPAREN          reduce using rule 58 (primary -> THIS .)
    PLUS            reduce using rule 58 (primary -> THIS .)
    MINUS           reduce using rule 58 (primary -> THIS .)
    TIMES           reduce using rule 58 (primary -> THIS .)
    DIVIDE          reduce using rule 58 (primary -> THIS .)
    GREATER         reduce using rule 58 (primary -> THIS .)
    LESS            reduce using rule 58 (primary -> THIS .)
    GREATEREQ       reduce using rule 58 (primary -> THIS .)
    LESSEQ          reduce using rule 58 (primary -> THIS .)
    EQUAL           reduce using rule 58 (primary -> THIS .)
    NOTEQUAL        reduce using rule 58 (primary -> THIS .)
    AND             reduce using rule 58 (primary -> THIS .)
    OR              reduce using rule 58 (primary -> THIS .)
    SEMICOLON       reduce using rule 58 (primary -> THIS .)
    COMMA           reduce using rule 58 (primary -> THIS .)


state 86

    (59) primary -> SUPER .

    DOT             reduce using rule 59 (primary -> SUPER .)
    RPAREN          reduce using rule 59 (primary -> SUPER .)
    PLUS            reduce using rule 59 (primary -> SUPER .)
    MINUS           reduce using rule 59 (primary -> SUPER .)
    TIMES           reduce using rule 59 (primary -> SUPER .)
    DIVIDE          reduce using rule 59 (primary -> SUPER .)
    GREATER         reduce using rule 59 (primary -> SUPER .)
    LESS            reduce using rule 59 (primary -> SUPER .)
    GREATEREQ       reduce using rule 59 (primary -> SUPER .)
    LESSEQ          reduce using rule 59 (primary -> SUPER .)
    EQUAL           reduce using rule 59 (primary -> SUPER .)
    NOTEQUAL        reduce using rule 59 (primary -> SUPER .)
    AND             reduce using rule 59 (primary -> SUPER .)
    OR              reduce using rule 59 (primary -> SUPER .)
    SEMICOLON       reduce using rule 59 (primary -> SUPER .)
    COMMA           reduce using rule 59 (primary -> SUPER .)


state 87

    (61) primary -> NEW . ID LPAREN RPAREN
    (62) primary -> NEW . ID LPAREN arguments RPAREN

    ID              shift and go to state 122


state 88

    (51) literal -> INTEGER .

    DOT             reduce using rule 51 (literal -> INTEGER .)
    RPAREN          reduce using rule 51 (literal -> INTEGER .)
    PLUS            reduce using rule 51 (literal -> INTEGER .)
    MINUS           reduce using rule 51 (literal -> INTEGER .)
    TIMES           reduce using rule 51 (literal -> INTEGER .)
    DIVIDE          reduce using rule 51 (literal -> INTEGER .)
    GREATER         reduce using rule 51 (literal -> INTEGER .)
    LESS            reduce using rule 51 (literal -> INTEGER .)
    GREATEREQ       reduce using rule 51 (literal -> INTEGER .)
    LESSEQ          reduce using rule 51 (literal -> INTEGER .)
    EQUAL           reduce using rule 51 (literal -> INTEGER .)
    NOTEQUAL        reduce using rule 51 (literal -> INTEGER .)
    AND             reduce using rule 51 (literal -> INTEGER .)
    OR              reduce using rule 51 (literal -> INTEGER .)
    SEMICOLON       reduce using rule 51 (literal -> INTEGER .)
    COMMA           reduce using rule 51 (literal -> INTEGER .)


state 89

    (53) literal -> STRING .

    DOT             reduce using rule 53 (literal -> STRING .)
    RPAREN          reduce using rule 53 (literal -> STRING .)
    PLUS            reduce using rule 53 (literal -> STRING .)
    MINUS           reduce using rule 53 (literal -> STRING .)
    TIMES           reduce using rule 53 (literal -> STRING .)
    DIVIDE          reduce using rule 53 (literal -> STRING .)
    GREATER         reduce using rule 53 (literal -> STRING .)
    LESS            reduce using rule 53 (literal -> STRING .)
    GREATEREQ       reduce using rule 53 (literal -> STRING .)
    LESSEQ          reduce using rule 53 (literal -> STRING .)
    EQUAL           reduce using rule 53 (literal -> STRING .)
    NOTEQUAL        reduce using rule 53 (literal -> STRING .)
    AND             reduce using rule 53 (literal -> STRING .)
    OR              reduce using rule 53 (literal -> STRING .)
    SEMICOLON       reduce using rule 53 (literal -> STRING .)
    COMMA           reduce using rule 53 (literal -> STRING .)


state 90

    (54) literal -> NULL .

    DOT             reduce using rule 54 (literal -> NULL .)
    RPAREN          reduce using rule 54 (literal -> NULL .)
    PLUS            reduce using rule 54 (literal -> NULL .)
    MINUS           reduce using rule 54 (literal -> NULL .)
    TIMES           reduce using rule 54 (literal -> NULL .)
    DIVIDE          reduce using rule 54 (literal -> NULL .)
    GREATER         reduce using rule 54 (literal -> NULL .)
    LESS            reduce using rule 54 (literal -> NULL .)
    GREATEREQ       reduce using rule 54 (literal -> NULL .)
    LESSEQ          reduce using rule 54 (literal -> NULL .)
    EQUAL           reduce using rule 54 (literal -> NULL .)
    NOTEQUAL        reduce using rule 54 (literal -> NULL .)
    AND             reduce using rule 54 (literal -> NULL .)
    OR              reduce using rule 54 (literal -> NULL .)
    SEMICOLON       reduce using rule 54 (literal -> NULL .)
    COMMA           reduce using rule 54 (literal -> NULL .)


state 91

    (55) literal -> FALSE .

    DOT             reduce using rule 55 (literal -> FALSE .)
    RPAREN          reduce using rule 55 (literal -> FALSE .)
    PLUS            reduce using rule 55 (literal -> FALSE .)
    MINUS           reduce using rule 55 (literal -> FALSE .)
    TIMES           reduce using rule 55 (literal -> FALSE .)
    DIVIDE          reduce using rule 55 (literal -> FALSE .)
    GREATER         reduce using rule 55 (literal -> FALSE .)
    LESS            reduce using rule 55 (literal -> FALSE .)
    GREATEREQ       reduce using rule 55 (literal -> FALSE .)
    LESSEQ          reduce using rule 55 (literal -> FALSE .)
    EQUAL           reduce using rule 55 (literal -> FALSE .)
    NOTEQUAL        reduce using rule 55 (literal -> FALSE .)
    AND             reduce using rule 55 (literal -> FALSE .)
    OR              reduce using rule 55 (literal -> FALSE .)
    SEMICOLON       reduce using rule 55 (literal -> FALSE .)
    COMMA           reduce using rule 55 (literal -> FALSE .)


state 92

    (56) literal -> TRUE .

    DOT             reduce using rule 56 (literal -> TRUE .)
    RPAREN          reduce using rule 56 (literal -> TRUE .)
    PLUS            reduce using rule 56 (literal -> TRUE .)
    MINUS           reduce using rule 56 (literal -> TRUE .)
    TIMES           reduce using rule 56 (literal -> TRUE .)
    DIVIDE          reduce using rule 56 (literal -> TRUE .)
    GREATER         reduce using rule 56 (literal -> TRUE .)
    LESS            reduce using rule 56 (literal -> TRUE .)
    GREATEREQ       reduce using rule 56 (literal -> TRUE .)
    LESSEQ          reduce using rule 56 (literal -> TRUE .)
    EQUAL           reduce using rule 56 (literal -> TRUE .)
    NOTEQUAL        reduce using rule 56 (literal -> TRUE .)
    AND             reduce using rule 56 (literal -> TRUE .)
    OR              reduce using rule 56 (literal -> TRUE .)
    SEMICOLON       reduce using rule 56 (literal -> TRUE .)
    COMMA           reduce using rule 56 (literal -> TRUE .)


state 93

    (31) constructor_decl -> modifier ID LPAREN formals RPAREN block .

    RCURLY          reduce using rule 31 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    PUBLIC          reduce using rule 31 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 31 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    STATIC          reduce using rule 31 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    INT             reduce using rule 31 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 31 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 31 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)
    ID              reduce using rule 31 (constructor_decl -> modifier ID LPAREN formals RPAREN block .)


state 94

    (33) formals -> formal_param COMMA formals .

    RPAREN          reduce using rule 33 (formals -> formal_param COMMA formals .)


state 95

    (28) method_decl -> modifier VOID ID LPAREN RPAREN block .

    RCURLY          reduce using rule 28 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    PUBLIC          reduce using rule 28 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    PRIVATE         reduce using rule 28 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    STATIC          reduce using rule 28 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    INT             reduce using rule 28 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    FLOAT           reduce using rule 28 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    BOOLEAN         reduce using rule 28 (method_decl -> modifier VOID ID LPAREN RPAREN block .)
    ID              reduce using rule 28 (method_decl -> modifier VOID ID LPAREN RPAREN block .)


state 96

    (29) method_decl -> modifier VOID ID LPAREN formals RPAREN . block
    (35) block -> . LCURLY stmtlist RCURLY
    (36) block -> . empty
    (95) empty -> .

    LCURLY          shift and go to state 55
    RCURLY          reduce using rule 95 (empty -> .)
    PUBLIC          reduce using rule 95 (empty -> .)
    PRIVATE         reduce using rule 95 (empty -> .)
    STATIC          reduce using rule 95 (empty -> .)
    INT             reduce using rule 95 (empty -> .)
    FLOAT           reduce using rule 95 (empty -> .)
    BOOLEAN         reduce using rule 95 (empty -> .)
    ID              reduce using rule 95 (empty -> .)

    block                          shift and go to state 123
    empty                          shift and go to state 56

state 97

    (27) method_decl -> modifier type ID LPAREN formals RPAREN block .

    RCURLY          reduce using rule 27 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    PUBLIC          reduce using rule 27 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 27 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    STATIC          reduce using rule 27 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    INT             reduce using rule 27 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 27 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 27 (method_decl -> modifier type ID LPAREN formals RPAREN block .)
    ID              reduce using rule 27 (method_decl -> modifier type ID LPAREN formals RPAREN block .)


state 98

    (35) block -> LCURLY stmtlist RCURLY .

    RCURLY          reduce using rule 35 (block -> LCURLY stmtlist RCURLY .)
    PUBLIC          reduce using rule 35 (block -> LCURLY stmtlist RCURLY .)
    PRIVATE         reduce using rule 35 (block -> LCURLY stmtlist RCURLY .)
    STATIC          reduce using rule 35 (block -> LCURLY stmtlist RCURLY .)
    INT             reduce using rule 35 (block -> LCURLY stmtlist RCURLY .)
    FLOAT           reduce using rule 35 (block -> LCURLY stmtlist RCURLY .)
    BOOLEAN         reduce using rule 35 (block -> LCURLY stmtlist RCURLY .)
    ID              reduce using rule 35 (block -> LCURLY stmtlist RCURLY .)
    IF              reduce using rule 35 (block -> LCURLY stmtlist RCURLY .)
    WHILE           reduce using rule 35 (block -> LCURLY stmtlist RCURLY .)
    FOR             reduce using rule 35 (block -> LCURLY stmtlist RCURLY .)
    RETURN          reduce using rule 35 (block -> LCURLY stmtlist RCURLY .)
    BREAK           reduce using rule 35 (block -> LCURLY stmtlist RCURLY .)
    CONTINUE        reduce using rule 35 (block -> LCURLY stmtlist RCURLY .)
    SEMICOLON       reduce using rule 35 (block -> LCURLY stmtlist RCURLY .)
    LCURLY          reduce using rule 35 (block -> LCURLY stmtlist RCURLY .)
    THIS            reduce using rule 35 (block -> LCURLY stmtlist RCURLY .)
    SUPER           reduce using rule 35 (block -> LCURLY stmtlist RCURLY .)
    LPAREN          reduce using rule 35 (block -> LCURLY stmtlist RCURLY .)
    NEW             reduce using rule 35 (block -> LCURLY stmtlist RCURLY .)
    INTEGER         reduce using rule 35 (block -> LCURLY stmtlist RCURLY .)
    STRING          reduce using rule 35 (block -> LCURLY stmtlist RCURLY .)
    NULL            reduce using rule 35 (block -> LCURLY stmtlist RCURLY .)
    FALSE           reduce using rule 35 (block -> LCURLY stmtlist RCURLY .)
    TRUE            reduce using rule 35 (block -> LCURLY stmtlist RCURLY .)
    ELSE            reduce using rule 35 (block -> LCURLY stmtlist RCURLY .)


state 99

    (38) stmtlist -> stmtlist stmt .

    RCURLY          reduce using rule 38 (stmtlist -> stmtlist stmt .)
    IF              reduce using rule 38 (stmtlist -> stmtlist stmt .)
    WHILE           reduce using rule 38 (stmtlist -> stmtlist stmt .)
    FOR             reduce using rule 38 (stmtlist -> stmtlist stmt .)
    RETURN          reduce using rule 38 (stmtlist -> stmtlist stmt .)
    BREAK           reduce using rule 38 (stmtlist -> stmtlist stmt .)
    CONTINUE        reduce using rule 38 (stmtlist -> stmtlist stmt .)
    SEMICOLON       reduce using rule 38 (stmtlist -> stmtlist stmt .)
    LCURLY          reduce using rule 38 (stmtlist -> stmtlist stmt .)
    INT             reduce using rule 38 (stmtlist -> stmtlist stmt .)
    FLOAT           reduce using rule 38 (stmtlist -> stmtlist stmt .)
    BOOLEAN         reduce using rule 38 (stmtlist -> stmtlist stmt .)
    ID              reduce using rule 38 (stmtlist -> stmtlist stmt .)
    THIS            reduce using rule 38 (stmtlist -> stmtlist stmt .)
    SUPER           reduce using rule 38 (stmtlist -> stmtlist stmt .)
    LPAREN          reduce using rule 38 (stmtlist -> stmtlist stmt .)
    NEW             reduce using rule 38 (stmtlist -> stmtlist stmt .)
    INTEGER         reduce using rule 38 (stmtlist -> stmtlist stmt .)
    STRING          reduce using rule 38 (stmtlist -> stmtlist stmt .)
    NULL            reduce using rule 38 (stmtlist -> stmtlist stmt .)
    FALSE           reduce using rule 38 (stmtlist -> stmtlist stmt .)
    TRUE            reduce using rule 38 (stmtlist -> stmtlist stmt .)


state 100

    (39) stmt -> IF LPAREN . expression RPAREN stmt
    (40) stmt -> IF LPAREN . expression RPAREN stmt ELSE stmt
    (69) expression -> . primary
    (70) expression -> . assign
    (71) expression -> . expression arith_op expression
    (72) expression -> . expression bool_op expression
    (73) expression -> . unary_op expression
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . LPAREN expression RPAREN
    (61) primary -> . NEW ID LPAREN RPAREN
    (62) primary -> . NEW ID LPAREN arguments RPAREN
    (63) primary -> . method_invocation
    (64) primary -> . lhs
    (77) assign -> . lhs SETEQUAL expression
    (90) unary_op -> . PLUS
    (91) unary_op -> . MINUS
    (92) unary_op -> . NOT
    (51) literal -> . INTEGER
    (52) literal -> . FLOAT
    (53) literal -> . STRING
    (54) literal -> . NULL
    (55) literal -> . FALSE
    (56) literal -> . TRUE
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 67
    NEW             shift and go to state 87
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    NOT             shift and go to state 110
    INTEGER         shift and go to state 88
    FLOAT           shift and go to state 111
    STRING          shift and go to state 89
    NULL            shift and go to state 90
    FALSE           shift and go to state 91
    TRUE            shift and go to state 92
    ID              shift and go to state 105

    expression                     shift and go to state 124
    primary                        shift and go to state 102
    assign                         shift and go to state 103
    unary_op                       shift and go to state 104
    literal                        shift and go to state 84
    method_invocation              shift and go to state 106
    lhs                            shift and go to state 107
    field_access                   shift and go to state 80

state 101

    (60) primary -> LPAREN expression . RPAREN
    (71) expression -> expression . arith_op expression
    (72) expression -> expression . bool_op expression
    (78) arith_op -> . PLUS
    (79) arith_op -> . MINUS
    (80) arith_op -> . TIMES
    (81) arith_op -> . DIVIDE
    (82) bool_op -> . GREATER
    (83) bool_op -> . LESS
    (84) bool_op -> . GREATEREQ
    (85) bool_op -> . LESSEQ
    (86) bool_op -> . EQUAL
    (87) bool_op -> . NOTEQUAL
    (88) bool_op -> . AND
    (89) bool_op -> . OR

    RPAREN          shift and go to state 125
    PLUS            shift and go to state 128
    MINUS           shift and go to state 129
    TIMES           shift and go to state 130
    DIVIDE          shift and go to state 131
    GREATER         shift and go to state 132
    LESS            shift and go to state 133
    GREATEREQ       shift and go to state 134
    LESSEQ          shift and go to state 135
    EQUAL           shift and go to state 136
    NOTEQUAL        shift and go to state 137
    AND             shift and go to state 138
    OR              shift and go to state 139

    arith_op                       shift and go to state 126
    bool_op                        shift and go to state 127

state 102

    (69) expression -> primary .
    (75) field_access -> primary . DOT ID

    RPAREN          reduce using rule 69 (expression -> primary .)
    PLUS            reduce using rule 69 (expression -> primary .)
    MINUS           reduce using rule 69 (expression -> primary .)
    TIMES           reduce using rule 69 (expression -> primary .)
    DIVIDE          reduce using rule 69 (expression -> primary .)
    GREATER         reduce using rule 69 (expression -> primary .)
    LESS            reduce using rule 69 (expression -> primary .)
    GREATEREQ       reduce using rule 69 (expression -> primary .)
    LESSEQ          reduce using rule 69 (expression -> primary .)
    EQUAL           reduce using rule 69 (expression -> primary .)
    NOTEQUAL        reduce using rule 69 (expression -> primary .)
    AND             reduce using rule 69 (expression -> primary .)
    OR              reduce using rule 69 (expression -> primary .)
    SEMICOLON       reduce using rule 69 (expression -> primary .)
    COMMA           reduce using rule 69 (expression -> primary .)
    DOT             shift and go to state 121


state 103

    (70) expression -> assign .

    RPAREN          reduce using rule 70 (expression -> assign .)
    PLUS            reduce using rule 70 (expression -> assign .)
    MINUS           reduce using rule 70 (expression -> assign .)
    TIMES           reduce using rule 70 (expression -> assign .)
    DIVIDE          reduce using rule 70 (expression -> assign .)
    GREATER         reduce using rule 70 (expression -> assign .)
    LESS            reduce using rule 70 (expression -> assign .)
    GREATEREQ       reduce using rule 70 (expression -> assign .)
    LESSEQ          reduce using rule 70 (expression -> assign .)
    EQUAL           reduce using rule 70 (expression -> assign .)
    NOTEQUAL        reduce using rule 70 (expression -> assign .)
    AND             reduce using rule 70 (expression -> assign .)
    OR              reduce using rule 70 (expression -> assign .)
    SEMICOLON       reduce using rule 70 (expression -> assign .)
    COMMA           reduce using rule 70 (expression -> assign .)


state 104

    (73) expression -> unary_op . expression
    (69) expression -> . primary
    (70) expression -> . assign
    (71) expression -> . expression arith_op expression
    (72) expression -> . expression bool_op expression
    (73) expression -> . unary_op expression
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . LPAREN expression RPAREN
    (61) primary -> . NEW ID LPAREN RPAREN
    (62) primary -> . NEW ID LPAREN arguments RPAREN
    (63) primary -> . method_invocation
    (64) primary -> . lhs
    (77) assign -> . lhs SETEQUAL expression
    (90) unary_op -> . PLUS
    (91) unary_op -> . MINUS
    (92) unary_op -> . NOT
    (51) literal -> . INTEGER
    (52) literal -> . FLOAT
    (53) literal -> . STRING
    (54) literal -> . NULL
    (55) literal -> . FALSE
    (56) literal -> . TRUE
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 67
    NEW             shift and go to state 87
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    NOT             shift and go to state 110
    INTEGER         shift and go to state 88
    FLOAT           shift and go to state 111
    STRING          shift and go to state 89
    NULL            shift and go to state 90
    FALSE           shift and go to state 91
    TRUE            shift and go to state 92
    ID              shift and go to state 105

    unary_op                       shift and go to state 104
    expression                     shift and go to state 140
    primary                        shift and go to state 102
    assign                         shift and go to state 103
    literal                        shift and go to state 84
    method_invocation              shift and go to state 106
    lhs                            shift and go to state 107
    field_access                   shift and go to state 80

state 105

    (76) field_access -> ID .

    LPAREN          reduce using rule 76 (field_access -> ID .)
    SETEQUAL        reduce using rule 76 (field_access -> ID .)
    DOT             reduce using rule 76 (field_access -> ID .)
    RPAREN          reduce using rule 76 (field_access -> ID .)
    PLUS            reduce using rule 76 (field_access -> ID .)
    MINUS           reduce using rule 76 (field_access -> ID .)
    TIMES           reduce using rule 76 (field_access -> ID .)
    DIVIDE          reduce using rule 76 (field_access -> ID .)
    GREATER         reduce using rule 76 (field_access -> ID .)
    LESS            reduce using rule 76 (field_access -> ID .)
    GREATEREQ       reduce using rule 76 (field_access -> ID .)
    LESSEQ          reduce using rule 76 (field_access -> ID .)
    EQUAL           reduce using rule 76 (field_access -> ID .)
    NOTEQUAL        reduce using rule 76 (field_access -> ID .)
    AND             reduce using rule 76 (field_access -> ID .)
    OR              reduce using rule 76 (field_access -> ID .)
    SEMICOLON       reduce using rule 76 (field_access -> ID .)
    COMMA           reduce using rule 76 (field_access -> ID .)


state 106

    (63) primary -> method_invocation .

    DOT             reduce using rule 63 (primary -> method_invocation .)
    RPAREN          reduce using rule 63 (primary -> method_invocation .)
    PLUS            reduce using rule 63 (primary -> method_invocation .)
    MINUS           reduce using rule 63 (primary -> method_invocation .)
    TIMES           reduce using rule 63 (primary -> method_invocation .)
    DIVIDE          reduce using rule 63 (primary -> method_invocation .)
    GREATER         reduce using rule 63 (primary -> method_invocation .)
    LESS            reduce using rule 63 (primary -> method_invocation .)
    GREATEREQ       reduce using rule 63 (primary -> method_invocation .)
    LESSEQ          reduce using rule 63 (primary -> method_invocation .)
    EQUAL           reduce using rule 63 (primary -> method_invocation .)
    NOTEQUAL        reduce using rule 63 (primary -> method_invocation .)
    AND             reduce using rule 63 (primary -> method_invocation .)
    OR              reduce using rule 63 (primary -> method_invocation .)
    SEMICOLON       reduce using rule 63 (primary -> method_invocation .)
    COMMA           reduce using rule 63 (primary -> method_invocation .)


state 107

    (64) primary -> lhs .
    (77) assign -> lhs . SETEQUAL expression

    DOT             reduce using rule 64 (primary -> lhs .)
    RPAREN          reduce using rule 64 (primary -> lhs .)
    PLUS            reduce using rule 64 (primary -> lhs .)
    MINUS           reduce using rule 64 (primary -> lhs .)
    TIMES           reduce using rule 64 (primary -> lhs .)
    DIVIDE          reduce using rule 64 (primary -> lhs .)
    GREATER         reduce using rule 64 (primary -> lhs .)
    LESS            reduce using rule 64 (primary -> lhs .)
    GREATEREQ       reduce using rule 64 (primary -> lhs .)
    LESSEQ          reduce using rule 64 (primary -> lhs .)
    EQUAL           reduce using rule 64 (primary -> lhs .)
    NOTEQUAL        reduce using rule 64 (primary -> lhs .)
    AND             reduce using rule 64 (primary -> lhs .)
    OR              reduce using rule 64 (primary -> lhs .)
    SEMICOLON       reduce using rule 64 (primary -> lhs .)
    COMMA           reduce using rule 64 (primary -> lhs .)
    SETEQUAL        shift and go to state 119


state 108

    (90) unary_op -> PLUS .

    THIS            reduce using rule 90 (unary_op -> PLUS .)
    SUPER           reduce using rule 90 (unary_op -> PLUS .)
    LPAREN          reduce using rule 90 (unary_op -> PLUS .)
    NEW             reduce using rule 90 (unary_op -> PLUS .)
    PLUS            reduce using rule 90 (unary_op -> PLUS .)
    MINUS           reduce using rule 90 (unary_op -> PLUS .)
    NOT             reduce using rule 90 (unary_op -> PLUS .)
    INTEGER         reduce using rule 90 (unary_op -> PLUS .)
    FLOAT           reduce using rule 90 (unary_op -> PLUS .)
    STRING          reduce using rule 90 (unary_op -> PLUS .)
    NULL            reduce using rule 90 (unary_op -> PLUS .)
    FALSE           reduce using rule 90 (unary_op -> PLUS .)
    TRUE            reduce using rule 90 (unary_op -> PLUS .)
    ID              reduce using rule 90 (unary_op -> PLUS .)


state 109

    (91) unary_op -> MINUS .

    THIS            reduce using rule 91 (unary_op -> MINUS .)
    SUPER           reduce using rule 91 (unary_op -> MINUS .)
    LPAREN          reduce using rule 91 (unary_op -> MINUS .)
    NEW             reduce using rule 91 (unary_op -> MINUS .)
    PLUS            reduce using rule 91 (unary_op -> MINUS .)
    MINUS           reduce using rule 91 (unary_op -> MINUS .)
    NOT             reduce using rule 91 (unary_op -> MINUS .)
    INTEGER         reduce using rule 91 (unary_op -> MINUS .)
    FLOAT           reduce using rule 91 (unary_op -> MINUS .)
    STRING          reduce using rule 91 (unary_op -> MINUS .)
    NULL            reduce using rule 91 (unary_op -> MINUS .)
    FALSE           reduce using rule 91 (unary_op -> MINUS .)
    TRUE            reduce using rule 91 (unary_op -> MINUS .)
    ID              reduce using rule 91 (unary_op -> MINUS .)


state 110

    (92) unary_op -> NOT .

    THIS            reduce using rule 92 (unary_op -> NOT .)
    SUPER           reduce using rule 92 (unary_op -> NOT .)
    LPAREN          reduce using rule 92 (unary_op -> NOT .)
    NEW             reduce using rule 92 (unary_op -> NOT .)
    PLUS            reduce using rule 92 (unary_op -> NOT .)
    MINUS           reduce using rule 92 (unary_op -> NOT .)
    NOT             reduce using rule 92 (unary_op -> NOT .)
    INTEGER         reduce using rule 92 (unary_op -> NOT .)
    FLOAT           reduce using rule 92 (unary_op -> NOT .)
    STRING          reduce using rule 92 (unary_op -> NOT .)
    NULL            reduce using rule 92 (unary_op -> NOT .)
    FALSE           reduce using rule 92 (unary_op -> NOT .)
    TRUE            reduce using rule 92 (unary_op -> NOT .)
    ID              reduce using rule 92 (unary_op -> NOT .)


state 111

    (52) literal -> FLOAT .

    DOT             reduce using rule 52 (literal -> FLOAT .)
    RPAREN          reduce using rule 52 (literal -> FLOAT .)
    PLUS            reduce using rule 52 (literal -> FLOAT .)
    MINUS           reduce using rule 52 (literal -> FLOAT .)
    TIMES           reduce using rule 52 (literal -> FLOAT .)
    DIVIDE          reduce using rule 52 (literal -> FLOAT .)
    GREATER         reduce using rule 52 (literal -> FLOAT .)
    LESS            reduce using rule 52 (literal -> FLOAT .)
    GREATEREQ       reduce using rule 52 (literal -> FLOAT .)
    LESSEQ          reduce using rule 52 (literal -> FLOAT .)
    EQUAL           reduce using rule 52 (literal -> FLOAT .)
    NOTEQUAL        reduce using rule 52 (literal -> FLOAT .)
    AND             reduce using rule 52 (literal -> FLOAT .)
    OR              reduce using rule 52 (literal -> FLOAT .)
    SEMICOLON       reduce using rule 52 (literal -> FLOAT .)
    COMMA           reduce using rule 52 (literal -> FLOAT .)


state 112

    (41) stmt -> WHILE LPAREN . expression RPAREN stmt
    (69) expression -> . primary
    (70) expression -> . assign
    (71) expression -> . expression arith_op expression
    (72) expression -> . expression bool_op expression
    (73) expression -> . unary_op expression
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . LPAREN expression RPAREN
    (61) primary -> . NEW ID LPAREN RPAREN
    (62) primary -> . NEW ID LPAREN arguments RPAREN
    (63) primary -> . method_invocation
    (64) primary -> . lhs
    (77) assign -> . lhs SETEQUAL expression
    (90) unary_op -> . PLUS
    (91) unary_op -> . MINUS
    (92) unary_op -> . NOT
    (51) literal -> . INTEGER
    (52) literal -> . FLOAT
    (53) literal -> . STRING
    (54) literal -> . NULL
    (55) literal -> . FALSE
    (56) literal -> . TRUE
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 67
    NEW             shift and go to state 87
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    NOT             shift and go to state 110
    INTEGER         shift and go to state 88
    FLOAT           shift and go to state 111
    STRING          shift and go to state 89
    NULL            shift and go to state 90
    FALSE           shift and go to state 91
    TRUE            shift and go to state 92
    ID              shift and go to state 105

    expression                     shift and go to state 141
    primary                        shift and go to state 102
    assign                         shift and go to state 103
    unary_op                       shift and go to state 104
    literal                        shift and go to state 84
    method_invocation              shift and go to state 106
    lhs                            shift and go to state 107
    field_access                   shift and go to state 80

state 113

    (42) stmt -> FOR LPAREN . stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block
    (93) stmt_expression -> . assign
    (94) stmt_expression -> . method_invocation
    (77) assign -> . lhs SETEQUAL expression
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . LPAREN expression RPAREN
    (61) primary -> . NEW ID LPAREN RPAREN
    (62) primary -> . NEW ID LPAREN arguments RPAREN
    (63) primary -> . method_invocation
    (64) primary -> . lhs
    (51) literal -> . INTEGER
    (52) literal -> . FLOAT
    (53) literal -> . STRING
    (54) literal -> . NULL
    (55) literal -> . FALSE
    (56) literal -> . TRUE

    ID              shift and go to state 105
    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 67
    NEW             shift and go to state 87
    INTEGER         shift and go to state 88
    FLOAT           shift and go to state 111
    STRING          shift and go to state 89
    NULL            shift and go to state 90
    FALSE           shift and go to state 91
    TRUE            shift and go to state 92

    stmt_expression                shift and go to state 142
    assign                         shift and go to state 77
    method_invocation              shift and go to state 78
    lhs                            shift and go to state 79
    field_access                   shift and go to state 80
    primary                        shift and go to state 83
    literal                        shift and go to state 84

state 114

    (45) stmt -> stmt_expression SEMICOLON .

    RCURLY          reduce using rule 45 (stmt -> stmt_expression SEMICOLON .)
    IF              reduce using rule 45 (stmt -> stmt_expression SEMICOLON .)
    WHILE           reduce using rule 45 (stmt -> stmt_expression SEMICOLON .)
    FOR             reduce using rule 45 (stmt -> stmt_expression SEMICOLON .)
    RETURN          reduce using rule 45 (stmt -> stmt_expression SEMICOLON .)
    BREAK           reduce using rule 45 (stmt -> stmt_expression SEMICOLON .)
    CONTINUE        reduce using rule 45 (stmt -> stmt_expression SEMICOLON .)
    SEMICOLON       reduce using rule 45 (stmt -> stmt_expression SEMICOLON .)
    LCURLY          reduce using rule 45 (stmt -> stmt_expression SEMICOLON .)
    INT             reduce using rule 45 (stmt -> stmt_expression SEMICOLON .)
    FLOAT           reduce using rule 45 (stmt -> stmt_expression SEMICOLON .)
    BOOLEAN         reduce using rule 45 (stmt -> stmt_expression SEMICOLON .)
    ID              reduce using rule 45 (stmt -> stmt_expression SEMICOLON .)
    THIS            reduce using rule 45 (stmt -> stmt_expression SEMICOLON .)
    SUPER           reduce using rule 45 (stmt -> stmt_expression SEMICOLON .)
    LPAREN          reduce using rule 45 (stmt -> stmt_expression SEMICOLON .)
    NEW             reduce using rule 45 (stmt -> stmt_expression SEMICOLON .)
    INTEGER         reduce using rule 45 (stmt -> stmt_expression SEMICOLON .)
    STRING          reduce using rule 45 (stmt -> stmt_expression SEMICOLON .)
    NULL            reduce using rule 45 (stmt -> stmt_expression SEMICOLON .)
    FALSE           reduce using rule 45 (stmt -> stmt_expression SEMICOLON .)
    TRUE            reduce using rule 45 (stmt -> stmt_expression SEMICOLON .)
    ELSE            reduce using rule 45 (stmt -> stmt_expression SEMICOLON .)


state 115

    (43) stmt -> RETURN expression . SEMICOLON
    (71) expression -> expression . arith_op expression
    (72) expression -> expression . bool_op expression
    (78) arith_op -> . PLUS
    (79) arith_op -> . MINUS
    (80) arith_op -> . TIMES
    (81) arith_op -> . DIVIDE
    (82) bool_op -> . GREATER
    (83) bool_op -> . LESS
    (84) bool_op -> . GREATEREQ
    (85) bool_op -> . LESSEQ
    (86) bool_op -> . EQUAL
    (87) bool_op -> . NOTEQUAL
    (88) bool_op -> . AND
    (89) bool_op -> . OR

    SEMICOLON       shift and go to state 143
    PLUS            shift and go to state 128
    MINUS           shift and go to state 129
    TIMES           shift and go to state 130
    DIVIDE          shift and go to state 131
    GREATER         shift and go to state 132
    LESS            shift and go to state 133
    GREATEREQ       shift and go to state 134
    LESSEQ          shift and go to state 135
    EQUAL           shift and go to state 136
    NOTEQUAL        shift and go to state 137
    AND             shift and go to state 138
    OR              shift and go to state 139

    arith_op                       shift and go to state 126
    bool_op                        shift and go to state 127

state 116

    (44) stmt -> RETURN SEMICOLON .

    RCURLY          reduce using rule 44 (stmt -> RETURN SEMICOLON .)
    IF              reduce using rule 44 (stmt -> RETURN SEMICOLON .)
    WHILE           reduce using rule 44 (stmt -> RETURN SEMICOLON .)
    FOR             reduce using rule 44 (stmt -> RETURN SEMICOLON .)
    RETURN          reduce using rule 44 (stmt -> RETURN SEMICOLON .)
    BREAK           reduce using rule 44 (stmt -> RETURN SEMICOLON .)
    CONTINUE        reduce using rule 44 (stmt -> RETURN SEMICOLON .)
    SEMICOLON       reduce using rule 44 (stmt -> RETURN SEMICOLON .)
    LCURLY          reduce using rule 44 (stmt -> RETURN SEMICOLON .)
    INT             reduce using rule 44 (stmt -> RETURN SEMICOLON .)
    FLOAT           reduce using rule 44 (stmt -> RETURN SEMICOLON .)
    BOOLEAN         reduce using rule 44 (stmt -> RETURN SEMICOLON .)
    ID              reduce using rule 44 (stmt -> RETURN SEMICOLON .)
    THIS            reduce using rule 44 (stmt -> RETURN SEMICOLON .)
    SUPER           reduce using rule 44 (stmt -> RETURN SEMICOLON .)
    LPAREN          reduce using rule 44 (stmt -> RETURN SEMICOLON .)
    NEW             reduce using rule 44 (stmt -> RETURN SEMICOLON .)
    INTEGER         reduce using rule 44 (stmt -> RETURN SEMICOLON .)
    STRING          reduce using rule 44 (stmt -> RETURN SEMICOLON .)
    NULL            reduce using rule 44 (stmt -> RETURN SEMICOLON .)
    FALSE           reduce using rule 44 (stmt -> RETURN SEMICOLON .)
    TRUE            reduce using rule 44 (stmt -> RETURN SEMICOLON .)
    ELSE            reduce using rule 44 (stmt -> RETURN SEMICOLON .)


state 117

    (46) stmt -> BREAK SEMICOLON .

    RCURLY          reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    IF              reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    SEMICOLON       reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    LCURLY          reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    INT             reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    BOOLEAN         reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    ID              reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    THIS            reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    SUPER           reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    LPAREN          reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    NEW             reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    INTEGER         reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    STRING          reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    NULL            reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    FALSE           reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    TRUE            reduce using rule 46 (stmt -> BREAK SEMICOLON .)
    ELSE            reduce using rule 46 (stmt -> BREAK SEMICOLON .)


state 118

    (47) stmt -> CONTINUE SEMICOLON .

    RCURLY          reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    IF              reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    SEMICOLON       reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    LCURLY          reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    INT             reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    BOOLEAN         reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    ID              reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    THIS            reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    SUPER           reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    LPAREN          reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    NEW             reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    INTEGER         reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    STRING          reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    NULL            reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    FALSE           reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    TRUE            reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)
    ELSE            reduce using rule 47 (stmt -> CONTINUE SEMICOLON .)


state 119

    (77) assign -> lhs SETEQUAL . expression
    (69) expression -> . primary
    (70) expression -> . assign
    (71) expression -> . expression arith_op expression
    (72) expression -> . expression bool_op expression
    (73) expression -> . unary_op expression
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . LPAREN expression RPAREN
    (61) primary -> . NEW ID LPAREN RPAREN
    (62) primary -> . NEW ID LPAREN arguments RPAREN
    (63) primary -> . method_invocation
    (64) primary -> . lhs
    (77) assign -> . lhs SETEQUAL expression
    (90) unary_op -> . PLUS
    (91) unary_op -> . MINUS
    (92) unary_op -> . NOT
    (51) literal -> . INTEGER
    (52) literal -> . FLOAT
    (53) literal -> . STRING
    (54) literal -> . NULL
    (55) literal -> . FALSE
    (56) literal -> . TRUE
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 67
    NEW             shift and go to state 87
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    NOT             shift and go to state 110
    INTEGER         shift and go to state 88
    FLOAT           shift and go to state 111
    STRING          shift and go to state 89
    NULL            shift and go to state 90
    FALSE           shift and go to state 91
    TRUE            shift and go to state 92
    ID              shift and go to state 105

    lhs                            shift and go to state 107
    expression                     shift and go to state 144
    primary                        shift and go to state 102
    assign                         shift and go to state 103
    unary_op                       shift and go to state 104
    literal                        shift and go to state 84
    method_invocation              shift and go to state 106
    field_access                   shift and go to state 80

state 120

    (67) method_invocation -> field_access LPAREN . arguments RPAREN
    (68) method_invocation -> field_access LPAREN . RPAREN
    (65) arguments -> . expression
    (66) arguments -> . expression COMMA arguments
    (69) expression -> . primary
    (70) expression -> . assign
    (71) expression -> . expression arith_op expression
    (72) expression -> . expression bool_op expression
    (73) expression -> . unary_op expression
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . LPAREN expression RPAREN
    (61) primary -> . NEW ID LPAREN RPAREN
    (62) primary -> . NEW ID LPAREN arguments RPAREN
    (63) primary -> . method_invocation
    (64) primary -> . lhs
    (77) assign -> . lhs SETEQUAL expression
    (90) unary_op -> . PLUS
    (91) unary_op -> . MINUS
    (92) unary_op -> . NOT
    (51) literal -> . INTEGER
    (52) literal -> . FLOAT
    (53) literal -> . STRING
    (54) literal -> . NULL
    (55) literal -> . FALSE
    (56) literal -> . TRUE
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    RPAREN          shift and go to state 146
    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 67
    NEW             shift and go to state 87
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    NOT             shift and go to state 110
    INTEGER         shift and go to state 88
    FLOAT           shift and go to state 111
    STRING          shift and go to state 89
    NULL            shift and go to state 90
    FALSE           shift and go to state 91
    TRUE            shift and go to state 92
    ID              shift and go to state 105

    field_access                   shift and go to state 80
    arguments                      shift and go to state 145
    expression                     shift and go to state 147
    primary                        shift and go to state 102
    assign                         shift and go to state 103
    unary_op                       shift and go to state 104
    literal                        shift and go to state 84
    method_invocation              shift and go to state 106
    lhs                            shift and go to state 107

state 121

    (75) field_access -> primary DOT . ID

    ID              shift and go to state 148


state 122

    (61) primary -> NEW ID . LPAREN RPAREN
    (62) primary -> NEW ID . LPAREN arguments RPAREN

    LPAREN          shift and go to state 149


state 123

    (29) method_decl -> modifier VOID ID LPAREN formals RPAREN block .

    RCURLY          reduce using rule 29 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    PUBLIC          reduce using rule 29 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    PRIVATE         reduce using rule 29 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    STATIC          reduce using rule 29 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    INT             reduce using rule 29 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    FLOAT           reduce using rule 29 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    BOOLEAN         reduce using rule 29 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)
    ID              reduce using rule 29 (method_decl -> modifier VOID ID LPAREN formals RPAREN block .)


state 124

    (39) stmt -> IF LPAREN expression . RPAREN stmt
    (40) stmt -> IF LPAREN expression . RPAREN stmt ELSE stmt
    (71) expression -> expression . arith_op expression
    (72) expression -> expression . bool_op expression
    (78) arith_op -> . PLUS
    (79) arith_op -> . MINUS
    (80) arith_op -> . TIMES
    (81) arith_op -> . DIVIDE
    (82) bool_op -> . GREATER
    (83) bool_op -> . LESS
    (84) bool_op -> . GREATEREQ
    (85) bool_op -> . LESSEQ
    (86) bool_op -> . EQUAL
    (87) bool_op -> . NOTEQUAL
    (88) bool_op -> . AND
    (89) bool_op -> . OR

    RPAREN          shift and go to state 150
    PLUS            shift and go to state 128
    MINUS           shift and go to state 129
    TIMES           shift and go to state 130
    DIVIDE          shift and go to state 131
    GREATER         shift and go to state 132
    LESS            shift and go to state 133
    GREATEREQ       shift and go to state 134
    LESSEQ          shift and go to state 135
    EQUAL           shift and go to state 136
    NOTEQUAL        shift and go to state 137
    AND             shift and go to state 138
    OR              shift and go to state 139

    arith_op                       shift and go to state 126
    bool_op                        shift and go to state 127

state 125

    (60) primary -> LPAREN expression RPAREN .

    DOT             reduce using rule 60 (primary -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 60 (primary -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 60 (primary -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 60 (primary -> LPAREN expression RPAREN .)
    TIMES           reduce using rule 60 (primary -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 60 (primary -> LPAREN expression RPAREN .)
    GREATER         reduce using rule 60 (primary -> LPAREN expression RPAREN .)
    LESS            reduce using rule 60 (primary -> LPAREN expression RPAREN .)
    GREATEREQ       reduce using rule 60 (primary -> LPAREN expression RPAREN .)
    LESSEQ          reduce using rule 60 (primary -> LPAREN expression RPAREN .)
    EQUAL           reduce using rule 60 (primary -> LPAREN expression RPAREN .)
    NOTEQUAL        reduce using rule 60 (primary -> LPAREN expression RPAREN .)
    AND             reduce using rule 60 (primary -> LPAREN expression RPAREN .)
    OR              reduce using rule 60 (primary -> LPAREN expression RPAREN .)
    SEMICOLON       reduce using rule 60 (primary -> LPAREN expression RPAREN .)
    COMMA           reduce using rule 60 (primary -> LPAREN expression RPAREN .)


state 126

    (71) expression -> expression arith_op . expression
    (69) expression -> . primary
    (70) expression -> . assign
    (71) expression -> . expression arith_op expression
    (72) expression -> . expression bool_op expression
    (73) expression -> . unary_op expression
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . LPAREN expression RPAREN
    (61) primary -> . NEW ID LPAREN RPAREN
    (62) primary -> . NEW ID LPAREN arguments RPAREN
    (63) primary -> . method_invocation
    (64) primary -> . lhs
    (77) assign -> . lhs SETEQUAL expression
    (90) unary_op -> . PLUS
    (91) unary_op -> . MINUS
    (92) unary_op -> . NOT
    (51) literal -> . INTEGER
    (52) literal -> . FLOAT
    (53) literal -> . STRING
    (54) literal -> . NULL
    (55) literal -> . FALSE
    (56) literal -> . TRUE
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 67
    NEW             shift and go to state 87
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    NOT             shift and go to state 110
    INTEGER         shift and go to state 88
    FLOAT           shift and go to state 111
    STRING          shift and go to state 89
    NULL            shift and go to state 90
    FALSE           shift and go to state 91
    TRUE            shift and go to state 92
    ID              shift and go to state 105

    expression                     shift and go to state 151
    primary                        shift and go to state 102
    assign                         shift and go to state 103
    unary_op                       shift and go to state 104
    literal                        shift and go to state 84
    method_invocation              shift and go to state 106
    lhs                            shift and go to state 107
    field_access                   shift and go to state 80

state 127

    (72) expression -> expression bool_op . expression
    (69) expression -> . primary
    (70) expression -> . assign
    (71) expression -> . expression arith_op expression
    (72) expression -> . expression bool_op expression
    (73) expression -> . unary_op expression
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . LPAREN expression RPAREN
    (61) primary -> . NEW ID LPAREN RPAREN
    (62) primary -> . NEW ID LPAREN arguments RPAREN
    (63) primary -> . method_invocation
    (64) primary -> . lhs
    (77) assign -> . lhs SETEQUAL expression
    (90) unary_op -> . PLUS
    (91) unary_op -> . MINUS
    (92) unary_op -> . NOT
    (51) literal -> . INTEGER
    (52) literal -> . FLOAT
    (53) literal -> . STRING
    (54) literal -> . NULL
    (55) literal -> . FALSE
    (56) literal -> . TRUE
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 67
    NEW             shift and go to state 87
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    NOT             shift and go to state 110
    INTEGER         shift and go to state 88
    FLOAT           shift and go to state 111
    STRING          shift and go to state 89
    NULL            shift and go to state 90
    FALSE           shift and go to state 91
    TRUE            shift and go to state 92
    ID              shift and go to state 105

    expression                     shift and go to state 152
    primary                        shift and go to state 102
    assign                         shift and go to state 103
    unary_op                       shift and go to state 104
    literal                        shift and go to state 84
    method_invocation              shift and go to state 106
    lhs                            shift and go to state 107
    field_access                   shift and go to state 80

state 128

    (78) arith_op -> PLUS .

    THIS            reduce using rule 78 (arith_op -> PLUS .)
    SUPER           reduce using rule 78 (arith_op -> PLUS .)
    LPAREN          reduce using rule 78 (arith_op -> PLUS .)
    NEW             reduce using rule 78 (arith_op -> PLUS .)
    PLUS            reduce using rule 78 (arith_op -> PLUS .)
    MINUS           reduce using rule 78 (arith_op -> PLUS .)
    NOT             reduce using rule 78 (arith_op -> PLUS .)
    INTEGER         reduce using rule 78 (arith_op -> PLUS .)
    FLOAT           reduce using rule 78 (arith_op -> PLUS .)
    STRING          reduce using rule 78 (arith_op -> PLUS .)
    NULL            reduce using rule 78 (arith_op -> PLUS .)
    FALSE           reduce using rule 78 (arith_op -> PLUS .)
    TRUE            reduce using rule 78 (arith_op -> PLUS .)
    ID              reduce using rule 78 (arith_op -> PLUS .)


state 129

    (79) arith_op -> MINUS .

    THIS            reduce using rule 79 (arith_op -> MINUS .)
    SUPER           reduce using rule 79 (arith_op -> MINUS .)
    LPAREN          reduce using rule 79 (arith_op -> MINUS .)
    NEW             reduce using rule 79 (arith_op -> MINUS .)
    PLUS            reduce using rule 79 (arith_op -> MINUS .)
    MINUS           reduce using rule 79 (arith_op -> MINUS .)
    NOT             reduce using rule 79 (arith_op -> MINUS .)
    INTEGER         reduce using rule 79 (arith_op -> MINUS .)
    FLOAT           reduce using rule 79 (arith_op -> MINUS .)
    STRING          reduce using rule 79 (arith_op -> MINUS .)
    NULL            reduce using rule 79 (arith_op -> MINUS .)
    FALSE           reduce using rule 79 (arith_op -> MINUS .)
    TRUE            reduce using rule 79 (arith_op -> MINUS .)
    ID              reduce using rule 79 (arith_op -> MINUS .)


state 130

    (80) arith_op -> TIMES .

    THIS            reduce using rule 80 (arith_op -> TIMES .)
    SUPER           reduce using rule 80 (arith_op -> TIMES .)
    LPAREN          reduce using rule 80 (arith_op -> TIMES .)
    NEW             reduce using rule 80 (arith_op -> TIMES .)
    PLUS            reduce using rule 80 (arith_op -> TIMES .)
    MINUS           reduce using rule 80 (arith_op -> TIMES .)
    NOT             reduce using rule 80 (arith_op -> TIMES .)
    INTEGER         reduce using rule 80 (arith_op -> TIMES .)
    FLOAT           reduce using rule 80 (arith_op -> TIMES .)
    STRING          reduce using rule 80 (arith_op -> TIMES .)
    NULL            reduce using rule 80 (arith_op -> TIMES .)
    FALSE           reduce using rule 80 (arith_op -> TIMES .)
    TRUE            reduce using rule 80 (arith_op -> TIMES .)
    ID              reduce using rule 80 (arith_op -> TIMES .)


state 131

    (81) arith_op -> DIVIDE .

    THIS            reduce using rule 81 (arith_op -> DIVIDE .)
    SUPER           reduce using rule 81 (arith_op -> DIVIDE .)
    LPAREN          reduce using rule 81 (arith_op -> DIVIDE .)
    NEW             reduce using rule 81 (arith_op -> DIVIDE .)
    PLUS            reduce using rule 81 (arith_op -> DIVIDE .)
    MINUS           reduce using rule 81 (arith_op -> DIVIDE .)
    NOT             reduce using rule 81 (arith_op -> DIVIDE .)
    INTEGER         reduce using rule 81 (arith_op -> DIVIDE .)
    FLOAT           reduce using rule 81 (arith_op -> DIVIDE .)
    STRING          reduce using rule 81 (arith_op -> DIVIDE .)
    NULL            reduce using rule 81 (arith_op -> DIVIDE .)
    FALSE           reduce using rule 81 (arith_op -> DIVIDE .)
    TRUE            reduce using rule 81 (arith_op -> DIVIDE .)
    ID              reduce using rule 81 (arith_op -> DIVIDE .)


state 132

    (82) bool_op -> GREATER .

    THIS            reduce using rule 82 (bool_op -> GREATER .)
    SUPER           reduce using rule 82 (bool_op -> GREATER .)
    LPAREN          reduce using rule 82 (bool_op -> GREATER .)
    NEW             reduce using rule 82 (bool_op -> GREATER .)
    PLUS            reduce using rule 82 (bool_op -> GREATER .)
    MINUS           reduce using rule 82 (bool_op -> GREATER .)
    NOT             reduce using rule 82 (bool_op -> GREATER .)
    INTEGER         reduce using rule 82 (bool_op -> GREATER .)
    FLOAT           reduce using rule 82 (bool_op -> GREATER .)
    STRING          reduce using rule 82 (bool_op -> GREATER .)
    NULL            reduce using rule 82 (bool_op -> GREATER .)
    FALSE           reduce using rule 82 (bool_op -> GREATER .)
    TRUE            reduce using rule 82 (bool_op -> GREATER .)
    ID              reduce using rule 82 (bool_op -> GREATER .)


state 133

    (83) bool_op -> LESS .

    THIS            reduce using rule 83 (bool_op -> LESS .)
    SUPER           reduce using rule 83 (bool_op -> LESS .)
    LPAREN          reduce using rule 83 (bool_op -> LESS .)
    NEW             reduce using rule 83 (bool_op -> LESS .)
    PLUS            reduce using rule 83 (bool_op -> LESS .)
    MINUS           reduce using rule 83 (bool_op -> LESS .)
    NOT             reduce using rule 83 (bool_op -> LESS .)
    INTEGER         reduce using rule 83 (bool_op -> LESS .)
    FLOAT           reduce using rule 83 (bool_op -> LESS .)
    STRING          reduce using rule 83 (bool_op -> LESS .)
    NULL            reduce using rule 83 (bool_op -> LESS .)
    FALSE           reduce using rule 83 (bool_op -> LESS .)
    TRUE            reduce using rule 83 (bool_op -> LESS .)
    ID              reduce using rule 83 (bool_op -> LESS .)


state 134

    (84) bool_op -> GREATEREQ .

    THIS            reduce using rule 84 (bool_op -> GREATEREQ .)
    SUPER           reduce using rule 84 (bool_op -> GREATEREQ .)
    LPAREN          reduce using rule 84 (bool_op -> GREATEREQ .)
    NEW             reduce using rule 84 (bool_op -> GREATEREQ .)
    PLUS            reduce using rule 84 (bool_op -> GREATEREQ .)
    MINUS           reduce using rule 84 (bool_op -> GREATEREQ .)
    NOT             reduce using rule 84 (bool_op -> GREATEREQ .)
    INTEGER         reduce using rule 84 (bool_op -> GREATEREQ .)
    FLOAT           reduce using rule 84 (bool_op -> GREATEREQ .)
    STRING          reduce using rule 84 (bool_op -> GREATEREQ .)
    NULL            reduce using rule 84 (bool_op -> GREATEREQ .)
    FALSE           reduce using rule 84 (bool_op -> GREATEREQ .)
    TRUE            reduce using rule 84 (bool_op -> GREATEREQ .)
    ID              reduce using rule 84 (bool_op -> GREATEREQ .)


state 135

    (85) bool_op -> LESSEQ .

    THIS            reduce using rule 85 (bool_op -> LESSEQ .)
    SUPER           reduce using rule 85 (bool_op -> LESSEQ .)
    LPAREN          reduce using rule 85 (bool_op -> LESSEQ .)
    NEW             reduce using rule 85 (bool_op -> LESSEQ .)
    PLUS            reduce using rule 85 (bool_op -> LESSEQ .)
    MINUS           reduce using rule 85 (bool_op -> LESSEQ .)
    NOT             reduce using rule 85 (bool_op -> LESSEQ .)
    INTEGER         reduce using rule 85 (bool_op -> LESSEQ .)
    FLOAT           reduce using rule 85 (bool_op -> LESSEQ .)
    STRING          reduce using rule 85 (bool_op -> LESSEQ .)
    NULL            reduce using rule 85 (bool_op -> LESSEQ .)
    FALSE           reduce using rule 85 (bool_op -> LESSEQ .)
    TRUE            reduce using rule 85 (bool_op -> LESSEQ .)
    ID              reduce using rule 85 (bool_op -> LESSEQ .)


state 136

    (86) bool_op -> EQUAL .

    THIS            reduce using rule 86 (bool_op -> EQUAL .)
    SUPER           reduce using rule 86 (bool_op -> EQUAL .)
    LPAREN          reduce using rule 86 (bool_op -> EQUAL .)
    NEW             reduce using rule 86 (bool_op -> EQUAL .)
    PLUS            reduce using rule 86 (bool_op -> EQUAL .)
    MINUS           reduce using rule 86 (bool_op -> EQUAL .)
    NOT             reduce using rule 86 (bool_op -> EQUAL .)
    INTEGER         reduce using rule 86 (bool_op -> EQUAL .)
    FLOAT           reduce using rule 86 (bool_op -> EQUAL .)
    STRING          reduce using rule 86 (bool_op -> EQUAL .)
    NULL            reduce using rule 86 (bool_op -> EQUAL .)
    FALSE           reduce using rule 86 (bool_op -> EQUAL .)
    TRUE            reduce using rule 86 (bool_op -> EQUAL .)
    ID              reduce using rule 86 (bool_op -> EQUAL .)


state 137

    (87) bool_op -> NOTEQUAL .

    THIS            reduce using rule 87 (bool_op -> NOTEQUAL .)
    SUPER           reduce using rule 87 (bool_op -> NOTEQUAL .)
    LPAREN          reduce using rule 87 (bool_op -> NOTEQUAL .)
    NEW             reduce using rule 87 (bool_op -> NOTEQUAL .)
    PLUS            reduce using rule 87 (bool_op -> NOTEQUAL .)
    MINUS           reduce using rule 87 (bool_op -> NOTEQUAL .)
    NOT             reduce using rule 87 (bool_op -> NOTEQUAL .)
    INTEGER         reduce using rule 87 (bool_op -> NOTEQUAL .)
    FLOAT           reduce using rule 87 (bool_op -> NOTEQUAL .)
    STRING          reduce using rule 87 (bool_op -> NOTEQUAL .)
    NULL            reduce using rule 87 (bool_op -> NOTEQUAL .)
    FALSE           reduce using rule 87 (bool_op -> NOTEQUAL .)
    TRUE            reduce using rule 87 (bool_op -> NOTEQUAL .)
    ID              reduce using rule 87 (bool_op -> NOTEQUAL .)


state 138

    (88) bool_op -> AND .

    THIS            reduce using rule 88 (bool_op -> AND .)
    SUPER           reduce using rule 88 (bool_op -> AND .)
    LPAREN          reduce using rule 88 (bool_op -> AND .)
    NEW             reduce using rule 88 (bool_op -> AND .)
    PLUS            reduce using rule 88 (bool_op -> AND .)
    MINUS           reduce using rule 88 (bool_op -> AND .)
    NOT             reduce using rule 88 (bool_op -> AND .)
    INTEGER         reduce using rule 88 (bool_op -> AND .)
    FLOAT           reduce using rule 88 (bool_op -> AND .)
    STRING          reduce using rule 88 (bool_op -> AND .)
    NULL            reduce using rule 88 (bool_op -> AND .)
    FALSE           reduce using rule 88 (bool_op -> AND .)
    TRUE            reduce using rule 88 (bool_op -> AND .)
    ID              reduce using rule 88 (bool_op -> AND .)


state 139

    (89) bool_op -> OR .

    THIS            reduce using rule 89 (bool_op -> OR .)
    SUPER           reduce using rule 89 (bool_op -> OR .)
    LPAREN          reduce using rule 89 (bool_op -> OR .)
    NEW             reduce using rule 89 (bool_op -> OR .)
    PLUS            reduce using rule 89 (bool_op -> OR .)
    MINUS           reduce using rule 89 (bool_op -> OR .)
    NOT             reduce using rule 89 (bool_op -> OR .)
    INTEGER         reduce using rule 89 (bool_op -> OR .)
    FLOAT           reduce using rule 89 (bool_op -> OR .)
    STRING          reduce using rule 89 (bool_op -> OR .)
    NULL            reduce using rule 89 (bool_op -> OR .)
    FALSE           reduce using rule 89 (bool_op -> OR .)
    TRUE            reduce using rule 89 (bool_op -> OR .)
    ID              reduce using rule 89 (bool_op -> OR .)


state 140

    (73) expression -> unary_op expression .
    (71) expression -> expression . arith_op expression
    (72) expression -> expression . bool_op expression
    (78) arith_op -> . PLUS
    (79) arith_op -> . MINUS
    (80) arith_op -> . TIMES
    (81) arith_op -> . DIVIDE
    (82) bool_op -> . GREATER
    (83) bool_op -> . LESS
    (84) bool_op -> . GREATEREQ
    (85) bool_op -> . LESSEQ
    (86) bool_op -> . EQUAL
    (87) bool_op -> . NOTEQUAL
    (88) bool_op -> . AND
    (89) bool_op -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 73 (expression -> unary_op expression .)
    SEMICOLON       reduce using rule 73 (expression -> unary_op expression .)
    COMMA           reduce using rule 73 (expression -> unary_op expression .)
    PLUS            shift and go to state 128
    MINUS           shift and go to state 129
    TIMES           shift and go to state 130
    DIVIDE          shift and go to state 131
    GREATER         shift and go to state 132
    LESS            shift and go to state 133
    GREATEREQ       shift and go to state 134
    LESSEQ          shift and go to state 135
    EQUAL           shift and go to state 136
    NOTEQUAL        shift and go to state 137
    AND             shift and go to state 138
    OR              shift and go to state 139

  ! PLUS            [ reduce using rule 73 (expression -> unary_op expression .) ]
  ! MINUS           [ reduce using rule 73 (expression -> unary_op expression .) ]
  ! TIMES           [ reduce using rule 73 (expression -> unary_op expression .) ]
  ! DIVIDE          [ reduce using rule 73 (expression -> unary_op expression .) ]
  ! GREATER         [ reduce using rule 73 (expression -> unary_op expression .) ]
  ! LESS            [ reduce using rule 73 (expression -> unary_op expression .) ]
  ! GREATEREQ       [ reduce using rule 73 (expression -> unary_op expression .) ]
  ! LESSEQ          [ reduce using rule 73 (expression -> unary_op expression .) ]
  ! EQUAL           [ reduce using rule 73 (expression -> unary_op expression .) ]
  ! NOTEQUAL        [ reduce using rule 73 (expression -> unary_op expression .) ]
  ! AND             [ reduce using rule 73 (expression -> unary_op expression .) ]
  ! OR              [ reduce using rule 73 (expression -> unary_op expression .) ]

    arith_op                       shift and go to state 126
    bool_op                        shift and go to state 127

state 141

    (41) stmt -> WHILE LPAREN expression . RPAREN stmt
    (71) expression -> expression . arith_op expression
    (72) expression -> expression . bool_op expression
    (78) arith_op -> . PLUS
    (79) arith_op -> . MINUS
    (80) arith_op -> . TIMES
    (81) arith_op -> . DIVIDE
    (82) bool_op -> . GREATER
    (83) bool_op -> . LESS
    (84) bool_op -> . GREATEREQ
    (85) bool_op -> . LESSEQ
    (86) bool_op -> . EQUAL
    (87) bool_op -> . NOTEQUAL
    (88) bool_op -> . AND
    (89) bool_op -> . OR

    RPAREN          shift and go to state 153
    PLUS            shift and go to state 128
    MINUS           shift and go to state 129
    TIMES           shift and go to state 130
    DIVIDE          shift and go to state 131
    GREATER         shift and go to state 132
    LESS            shift and go to state 133
    GREATEREQ       shift and go to state 134
    LESSEQ          shift and go to state 135
    EQUAL           shift and go to state 136
    NOTEQUAL        shift and go to state 137
    AND             shift and go to state 138
    OR              shift and go to state 139

    arith_op                       shift and go to state 126
    bool_op                        shift and go to state 127

state 142

    (42) stmt -> FOR LPAREN stmt_expression . SEMICOLON expression SEMICOLON stmt_expression RPAREN block

    SEMICOLON       shift and go to state 154


state 143

    (43) stmt -> RETURN expression SEMICOLON .

    RCURLY          reduce using rule 43 (stmt -> RETURN expression SEMICOLON .)
    IF              reduce using rule 43 (stmt -> RETURN expression SEMICOLON .)
    WHILE           reduce using rule 43 (stmt -> RETURN expression SEMICOLON .)
    FOR             reduce using rule 43 (stmt -> RETURN expression SEMICOLON .)
    RETURN          reduce using rule 43 (stmt -> RETURN expression SEMICOLON .)
    BREAK           reduce using rule 43 (stmt -> RETURN expression SEMICOLON .)
    CONTINUE        reduce using rule 43 (stmt -> RETURN expression SEMICOLON .)
    SEMICOLON       reduce using rule 43 (stmt -> RETURN expression SEMICOLON .)
    LCURLY          reduce using rule 43 (stmt -> RETURN expression SEMICOLON .)
    INT             reduce using rule 43 (stmt -> RETURN expression SEMICOLON .)
    FLOAT           reduce using rule 43 (stmt -> RETURN expression SEMICOLON .)
    BOOLEAN         reduce using rule 43 (stmt -> RETURN expression SEMICOLON .)
    ID              reduce using rule 43 (stmt -> RETURN expression SEMICOLON .)
    THIS            reduce using rule 43 (stmt -> RETURN expression SEMICOLON .)
    SUPER           reduce using rule 43 (stmt -> RETURN expression SEMICOLON .)
    LPAREN          reduce using rule 43 (stmt -> RETURN expression SEMICOLON .)
    NEW             reduce using rule 43 (stmt -> RETURN expression SEMICOLON .)
    INTEGER         reduce using rule 43 (stmt -> RETURN expression SEMICOLON .)
    STRING          reduce using rule 43 (stmt -> RETURN expression SEMICOLON .)
    NULL            reduce using rule 43 (stmt -> RETURN expression SEMICOLON .)
    FALSE           reduce using rule 43 (stmt -> RETURN expression SEMICOLON .)
    TRUE            reduce using rule 43 (stmt -> RETURN expression SEMICOLON .)
    ELSE            reduce using rule 43 (stmt -> RETURN expression SEMICOLON .)


state 144

    (77) assign -> lhs SETEQUAL expression .
    (71) expression -> expression . arith_op expression
    (72) expression -> expression . bool_op expression
    (78) arith_op -> . PLUS
    (79) arith_op -> . MINUS
    (80) arith_op -> . TIMES
    (81) arith_op -> . DIVIDE
    (82) bool_op -> . GREATER
    (83) bool_op -> . LESS
    (84) bool_op -> . GREATEREQ
    (85) bool_op -> . LESSEQ
    (86) bool_op -> . EQUAL
    (87) bool_op -> . NOTEQUAL
    (88) bool_op -> . AND
    (89) bool_op -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 77 (assign -> lhs SETEQUAL expression .)
    RPAREN          reduce using rule 77 (assign -> lhs SETEQUAL expression .)
    COMMA           reduce using rule 77 (assign -> lhs SETEQUAL expression .)
    PLUS            shift and go to state 128
    MINUS           shift and go to state 129
    TIMES           shift and go to state 130
    DIVIDE          shift and go to state 131
    GREATER         shift and go to state 132
    LESS            shift and go to state 133
    GREATEREQ       shift and go to state 134
    LESSEQ          shift and go to state 135
    EQUAL           shift and go to state 136
    NOTEQUAL        shift and go to state 137
    AND             shift and go to state 138
    OR              shift and go to state 139

  ! PLUS            [ reduce using rule 77 (assign -> lhs SETEQUAL expression .) ]
  ! MINUS           [ reduce using rule 77 (assign -> lhs SETEQUAL expression .) ]
  ! TIMES           [ reduce using rule 77 (assign -> lhs SETEQUAL expression .) ]
  ! DIVIDE          [ reduce using rule 77 (assign -> lhs SETEQUAL expression .) ]
  ! GREATER         [ reduce using rule 77 (assign -> lhs SETEQUAL expression .) ]
  ! LESS            [ reduce using rule 77 (assign -> lhs SETEQUAL expression .) ]
  ! GREATEREQ       [ reduce using rule 77 (assign -> lhs SETEQUAL expression .) ]
  ! LESSEQ          [ reduce using rule 77 (assign -> lhs SETEQUAL expression .) ]
  ! EQUAL           [ reduce using rule 77 (assign -> lhs SETEQUAL expression .) ]
  ! NOTEQUAL        [ reduce using rule 77 (assign -> lhs SETEQUAL expression .) ]
  ! AND             [ reduce using rule 77 (assign -> lhs SETEQUAL expression .) ]
  ! OR              [ reduce using rule 77 (assign -> lhs SETEQUAL expression .) ]

    arith_op                       shift and go to state 126
    bool_op                        shift and go to state 127

state 145

    (67) method_invocation -> field_access LPAREN arguments . RPAREN

    RPAREN          shift and go to state 155


state 146

    (68) method_invocation -> field_access LPAREN RPAREN .

    SEMICOLON       reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    DOT             reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    RPAREN          reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    PLUS            reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    MINUS           reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    TIMES           reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    DIVIDE          reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    GREATER         reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    LESS            reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    GREATEREQ       reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    LESSEQ          reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    EQUAL           reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    NOTEQUAL        reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    AND             reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    OR              reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)
    COMMA           reduce using rule 68 (method_invocation -> field_access LPAREN RPAREN .)


state 147

    (65) arguments -> expression .
    (66) arguments -> expression . COMMA arguments
    (71) expression -> expression . arith_op expression
    (72) expression -> expression . bool_op expression
    (78) arith_op -> . PLUS
    (79) arith_op -> . MINUS
    (80) arith_op -> . TIMES
    (81) arith_op -> . DIVIDE
    (82) bool_op -> . GREATER
    (83) bool_op -> . LESS
    (84) bool_op -> . GREATEREQ
    (85) bool_op -> . LESSEQ
    (86) bool_op -> . EQUAL
    (87) bool_op -> . NOTEQUAL
    (88) bool_op -> . AND
    (89) bool_op -> . OR

    RPAREN          reduce using rule 65 (arguments -> expression .)
    COMMA           shift and go to state 156
    PLUS            shift and go to state 128
    MINUS           shift and go to state 129
    TIMES           shift and go to state 130
    DIVIDE          shift and go to state 131
    GREATER         shift and go to state 132
    LESS            shift and go to state 133
    GREATEREQ       shift and go to state 134
    LESSEQ          shift and go to state 135
    EQUAL           shift and go to state 136
    NOTEQUAL        shift and go to state 137
    AND             shift and go to state 138
    OR              shift and go to state 139

    arith_op                       shift and go to state 126
    bool_op                        shift and go to state 127

state 148

    (75) field_access -> primary DOT ID .

    LPAREN          reduce using rule 75 (field_access -> primary DOT ID .)
    SETEQUAL        reduce using rule 75 (field_access -> primary DOT ID .)
    DOT             reduce using rule 75 (field_access -> primary DOT ID .)
    RPAREN          reduce using rule 75 (field_access -> primary DOT ID .)
    PLUS            reduce using rule 75 (field_access -> primary DOT ID .)
    MINUS           reduce using rule 75 (field_access -> primary DOT ID .)
    TIMES           reduce using rule 75 (field_access -> primary DOT ID .)
    DIVIDE          reduce using rule 75 (field_access -> primary DOT ID .)
    GREATER         reduce using rule 75 (field_access -> primary DOT ID .)
    LESS            reduce using rule 75 (field_access -> primary DOT ID .)
    GREATEREQ       reduce using rule 75 (field_access -> primary DOT ID .)
    LESSEQ          reduce using rule 75 (field_access -> primary DOT ID .)
    EQUAL           reduce using rule 75 (field_access -> primary DOT ID .)
    NOTEQUAL        reduce using rule 75 (field_access -> primary DOT ID .)
    AND             reduce using rule 75 (field_access -> primary DOT ID .)
    OR              reduce using rule 75 (field_access -> primary DOT ID .)
    SEMICOLON       reduce using rule 75 (field_access -> primary DOT ID .)
    COMMA           reduce using rule 75 (field_access -> primary DOT ID .)


state 149

    (61) primary -> NEW ID LPAREN . RPAREN
    (62) primary -> NEW ID LPAREN . arguments RPAREN
    (65) arguments -> . expression
    (66) arguments -> . expression COMMA arguments
    (69) expression -> . primary
    (70) expression -> . assign
    (71) expression -> . expression arith_op expression
    (72) expression -> . expression bool_op expression
    (73) expression -> . unary_op expression
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . LPAREN expression RPAREN
    (61) primary -> . NEW ID LPAREN RPAREN
    (62) primary -> . NEW ID LPAREN arguments RPAREN
    (63) primary -> . method_invocation
    (64) primary -> . lhs
    (77) assign -> . lhs SETEQUAL expression
    (90) unary_op -> . PLUS
    (91) unary_op -> . MINUS
    (92) unary_op -> . NOT
    (51) literal -> . INTEGER
    (52) literal -> . FLOAT
    (53) literal -> . STRING
    (54) literal -> . NULL
    (55) literal -> . FALSE
    (56) literal -> . TRUE
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    RPAREN          shift and go to state 157
    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 67
    NEW             shift and go to state 87
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    NOT             shift and go to state 110
    INTEGER         shift and go to state 88
    FLOAT           shift and go to state 111
    STRING          shift and go to state 89
    NULL            shift and go to state 90
    FALSE           shift and go to state 91
    TRUE            shift and go to state 92
    ID              shift and go to state 105

    arguments                      shift and go to state 158
    expression                     shift and go to state 147
    primary                        shift and go to state 102
    assign                         shift and go to state 103
    unary_op                       shift and go to state 104
    literal                        shift and go to state 84
    method_invocation              shift and go to state 106
    lhs                            shift and go to state 107
    field_access                   shift and go to state 80

state 150

    (39) stmt -> IF LPAREN expression RPAREN . stmt
    (40) stmt -> IF LPAREN expression RPAREN . stmt ELSE stmt
    (39) stmt -> . IF LPAREN expression RPAREN stmt
    (40) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (41) stmt -> . WHILE LPAREN expression RPAREN stmt
    (42) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block
    (43) stmt -> . RETURN expression SEMICOLON
    (44) stmt -> . RETURN SEMICOLON
    (45) stmt -> . stmt_expression SEMICOLON
    (46) stmt -> . BREAK SEMICOLON
    (47) stmt -> . CONTINUE SEMICOLON
    (48) stmt -> . block
    (49) stmt -> . var_decl
    (50) stmt -> . SEMICOLON
    (93) stmt_expression -> . assign
    (94) stmt_expression -> . method_invocation
    (35) block -> . LCURLY stmtlist RCURLY
    (36) block -> . empty
    (18) var_decl -> . type variables SEMICOLON
    (77) assign -> . lhs SETEQUAL expression
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (95) empty -> .
    (19) type -> . INT
    (20) type -> . FLOAT
    (21) type -> . BOOLEAN
    (22) type -> . ID
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . LPAREN expression RPAREN
    (61) primary -> . NEW ID LPAREN RPAREN
    (62) primary -> . NEW ID LPAREN arguments RPAREN
    (63) primary -> . method_invocation
    (64) primary -> . lhs
    (51) literal -> . INTEGER
    (52) literal -> . FLOAT
    (53) literal -> . STRING
    (54) literal -> . NULL
    (55) literal -> . FALSE
    (56) literal -> . TRUE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    IF              shift and go to state 66
    WHILE           shift and go to state 68
    FOR             shift and go to state 69
    RETURN          shift and go to state 73
    BREAK           shift and go to state 74
    CONTINUE        shift and go to state 75
    SEMICOLON       shift and go to state 71
    LCURLY          shift and go to state 55
    ELSE            reduce using rule 95 (empty -> .)
    RCURLY          reduce using rule 95 (empty -> .)
    INT             shift and go to state 19
    FLOAT           shift and go to state 81
    BOOLEAN         shift and go to state 21
    ID              shift and go to state 82
    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 67
    NEW             shift and go to state 87
    INTEGER         shift and go to state 88
    STRING          shift and go to state 89
    NULL            shift and go to state 90
    FALSE           shift and go to state 91
    TRUE            shift and go to state 92

  ! IF              [ reduce using rule 95 (empty -> .) ]
  ! WHILE           [ reduce using rule 95 (empty -> .) ]
  ! FOR             [ reduce using rule 95 (empty -> .) ]
  ! RETURN          [ reduce using rule 95 (empty -> .) ]
  ! BREAK           [ reduce using rule 95 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 95 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 95 (empty -> .) ]
  ! LCURLY          [ reduce using rule 95 (empty -> .) ]
  ! INT             [ reduce using rule 95 (empty -> .) ]
  ! FLOAT           [ reduce using rule 95 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 95 (empty -> .) ]
  ! ID              [ reduce using rule 95 (empty -> .) ]
  ! THIS            [ reduce using rule 95 (empty -> .) ]
  ! SUPER           [ reduce using rule 95 (empty -> .) ]
  ! LPAREN          [ reduce using rule 95 (empty -> .) ]
  ! NEW             [ reduce using rule 95 (empty -> .) ]
  ! INTEGER         [ reduce using rule 95 (empty -> .) ]
  ! STRING          [ reduce using rule 95 (empty -> .) ]
  ! NULL            [ reduce using rule 95 (empty -> .) ]
  ! FALSE           [ reduce using rule 95 (empty -> .) ]
  ! TRUE            [ reduce using rule 95 (empty -> .) ]

    stmt                           shift and go to state 159
    stmt_expression                shift and go to state 70
    block                          shift and go to state 72
    var_decl                       shift and go to state 76
    assign                         shift and go to state 77
    method_invocation              shift and go to state 78
    empty                          shift and go to state 56
    type                           shift and go to state 15
    lhs                            shift and go to state 79
    field_access                   shift and go to state 80
    primary                        shift and go to state 83
    literal                        shift and go to state 84

state 151

    (71) expression -> expression arith_op expression .
    (71) expression -> expression . arith_op expression
    (72) expression -> expression . bool_op expression
    (78) arith_op -> . PLUS
    (79) arith_op -> . MINUS
    (80) arith_op -> . TIMES
    (81) arith_op -> . DIVIDE
    (82) bool_op -> . GREATER
    (83) bool_op -> . LESS
    (84) bool_op -> . GREATEREQ
    (85) bool_op -> . LESSEQ
    (86) bool_op -> . EQUAL
    (87) bool_op -> . NOTEQUAL
    (88) bool_op -> . AND
    (89) bool_op -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 71 (expression -> expression arith_op expression .)
    SEMICOLON       reduce using rule 71 (expression -> expression arith_op expression .)
    COMMA           reduce using rule 71 (expression -> expression arith_op expression .)
    PLUS            shift and go to state 128
    MINUS           shift and go to state 129
    TIMES           shift and go to state 130
    DIVIDE          shift and go to state 131
    GREATER         shift and go to state 132
    LESS            shift and go to state 133
    GREATEREQ       shift and go to state 134
    LESSEQ          shift and go to state 135
    EQUAL           shift and go to state 136
    NOTEQUAL        shift and go to state 137
    AND             shift and go to state 138
    OR              shift and go to state 139

  ! PLUS            [ reduce using rule 71 (expression -> expression arith_op expression .) ]
  ! MINUS           [ reduce using rule 71 (expression -> expression arith_op expression .) ]
  ! TIMES           [ reduce using rule 71 (expression -> expression arith_op expression .) ]
  ! DIVIDE          [ reduce using rule 71 (expression -> expression arith_op expression .) ]
  ! GREATER         [ reduce using rule 71 (expression -> expression arith_op expression .) ]
  ! LESS            [ reduce using rule 71 (expression -> expression arith_op expression .) ]
  ! GREATEREQ       [ reduce using rule 71 (expression -> expression arith_op expression .) ]
  ! LESSEQ          [ reduce using rule 71 (expression -> expression arith_op expression .) ]
  ! EQUAL           [ reduce using rule 71 (expression -> expression arith_op expression .) ]
  ! NOTEQUAL        [ reduce using rule 71 (expression -> expression arith_op expression .) ]
  ! AND             [ reduce using rule 71 (expression -> expression arith_op expression .) ]
  ! OR              [ reduce using rule 71 (expression -> expression arith_op expression .) ]

    arith_op                       shift and go to state 126
    bool_op                        shift and go to state 127

state 152

    (72) expression -> expression bool_op expression .
    (71) expression -> expression . arith_op expression
    (72) expression -> expression . bool_op expression
    (78) arith_op -> . PLUS
    (79) arith_op -> . MINUS
    (80) arith_op -> . TIMES
    (81) arith_op -> . DIVIDE
    (82) bool_op -> . GREATER
    (83) bool_op -> . LESS
    (84) bool_op -> . GREATEREQ
    (85) bool_op -> . LESSEQ
    (86) bool_op -> . EQUAL
    (87) bool_op -> . NOTEQUAL
    (88) bool_op -> . AND
    (89) bool_op -> . OR

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for LESS resolved as shift
  ! shift/reduce conflict for GREATEREQ resolved as shift
  ! shift/reduce conflict for LESSEQ resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for NOTEQUAL resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    RPAREN          reduce using rule 72 (expression -> expression bool_op expression .)
    SEMICOLON       reduce using rule 72 (expression -> expression bool_op expression .)
    COMMA           reduce using rule 72 (expression -> expression bool_op expression .)
    PLUS            shift and go to state 128
    MINUS           shift and go to state 129
    TIMES           shift and go to state 130
    DIVIDE          shift and go to state 131
    GREATER         shift and go to state 132
    LESS            shift and go to state 133
    GREATEREQ       shift and go to state 134
    LESSEQ          shift and go to state 135
    EQUAL           shift and go to state 136
    NOTEQUAL        shift and go to state 137
    AND             shift and go to state 138
    OR              shift and go to state 139

  ! PLUS            [ reduce using rule 72 (expression -> expression bool_op expression .) ]
  ! MINUS           [ reduce using rule 72 (expression -> expression bool_op expression .) ]
  ! TIMES           [ reduce using rule 72 (expression -> expression bool_op expression .) ]
  ! DIVIDE          [ reduce using rule 72 (expression -> expression bool_op expression .) ]
  ! GREATER         [ reduce using rule 72 (expression -> expression bool_op expression .) ]
  ! LESS            [ reduce using rule 72 (expression -> expression bool_op expression .) ]
  ! GREATEREQ       [ reduce using rule 72 (expression -> expression bool_op expression .) ]
  ! LESSEQ          [ reduce using rule 72 (expression -> expression bool_op expression .) ]
  ! EQUAL           [ reduce using rule 72 (expression -> expression bool_op expression .) ]
  ! NOTEQUAL        [ reduce using rule 72 (expression -> expression bool_op expression .) ]
  ! AND             [ reduce using rule 72 (expression -> expression bool_op expression .) ]
  ! OR              [ reduce using rule 72 (expression -> expression bool_op expression .) ]

    bool_op                        shift and go to state 127
    arith_op                       shift and go to state 126

state 153

    (41) stmt -> WHILE LPAREN expression RPAREN . stmt
    (39) stmt -> . IF LPAREN expression RPAREN stmt
    (40) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (41) stmt -> . WHILE LPAREN expression RPAREN stmt
    (42) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block
    (43) stmt -> . RETURN expression SEMICOLON
    (44) stmt -> . RETURN SEMICOLON
    (45) stmt -> . stmt_expression SEMICOLON
    (46) stmt -> . BREAK SEMICOLON
    (47) stmt -> . CONTINUE SEMICOLON
    (48) stmt -> . block
    (49) stmt -> . var_decl
    (50) stmt -> . SEMICOLON
    (93) stmt_expression -> . assign
    (94) stmt_expression -> . method_invocation
    (35) block -> . LCURLY stmtlist RCURLY
    (36) block -> . empty
    (18) var_decl -> . type variables SEMICOLON
    (77) assign -> . lhs SETEQUAL expression
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (95) empty -> .
    (19) type -> . INT
    (20) type -> . FLOAT
    (21) type -> . BOOLEAN
    (22) type -> . ID
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . LPAREN expression RPAREN
    (61) primary -> . NEW ID LPAREN RPAREN
    (62) primary -> . NEW ID LPAREN arguments RPAREN
    (63) primary -> . method_invocation
    (64) primary -> . lhs
    (51) literal -> . INTEGER
    (52) literal -> . FLOAT
    (53) literal -> . STRING
    (54) literal -> . NULL
    (55) literal -> . FALSE
    (56) literal -> . TRUE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    IF              shift and go to state 66
    WHILE           shift and go to state 68
    FOR             shift and go to state 69
    RETURN          shift and go to state 73
    BREAK           shift and go to state 74
    CONTINUE        shift and go to state 75
    SEMICOLON       shift and go to state 71
    LCURLY          shift and go to state 55
    ELSE            reduce using rule 95 (empty -> .)
    RCURLY          reduce using rule 95 (empty -> .)
    INT             shift and go to state 19
    FLOAT           shift and go to state 81
    BOOLEAN         shift and go to state 21
    ID              shift and go to state 82
    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 67
    NEW             shift and go to state 87
    INTEGER         shift and go to state 88
    STRING          shift and go to state 89
    NULL            shift and go to state 90
    FALSE           shift and go to state 91
    TRUE            shift and go to state 92

  ! IF              [ reduce using rule 95 (empty -> .) ]
  ! WHILE           [ reduce using rule 95 (empty -> .) ]
  ! FOR             [ reduce using rule 95 (empty -> .) ]
  ! RETURN          [ reduce using rule 95 (empty -> .) ]
  ! BREAK           [ reduce using rule 95 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 95 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 95 (empty -> .) ]
  ! LCURLY          [ reduce using rule 95 (empty -> .) ]
  ! INT             [ reduce using rule 95 (empty -> .) ]
  ! FLOAT           [ reduce using rule 95 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 95 (empty -> .) ]
  ! ID              [ reduce using rule 95 (empty -> .) ]
  ! THIS            [ reduce using rule 95 (empty -> .) ]
  ! SUPER           [ reduce using rule 95 (empty -> .) ]
  ! LPAREN          [ reduce using rule 95 (empty -> .) ]
  ! NEW             [ reduce using rule 95 (empty -> .) ]
  ! INTEGER         [ reduce using rule 95 (empty -> .) ]
  ! STRING          [ reduce using rule 95 (empty -> .) ]
  ! NULL            [ reduce using rule 95 (empty -> .) ]
  ! FALSE           [ reduce using rule 95 (empty -> .) ]
  ! TRUE            [ reduce using rule 95 (empty -> .) ]

    stmt                           shift and go to state 160
    stmt_expression                shift and go to state 70
    block                          shift and go to state 72
    var_decl                       shift and go to state 76
    assign                         shift and go to state 77
    method_invocation              shift and go to state 78
    empty                          shift and go to state 56
    type                           shift and go to state 15
    lhs                            shift and go to state 79
    field_access                   shift and go to state 80
    primary                        shift and go to state 83
    literal                        shift and go to state 84

state 154

    (42) stmt -> FOR LPAREN stmt_expression SEMICOLON . expression SEMICOLON stmt_expression RPAREN block
    (69) expression -> . primary
    (70) expression -> . assign
    (71) expression -> . expression arith_op expression
    (72) expression -> . expression bool_op expression
    (73) expression -> . unary_op expression
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . LPAREN expression RPAREN
    (61) primary -> . NEW ID LPAREN RPAREN
    (62) primary -> . NEW ID LPAREN arguments RPAREN
    (63) primary -> . method_invocation
    (64) primary -> . lhs
    (77) assign -> . lhs SETEQUAL expression
    (90) unary_op -> . PLUS
    (91) unary_op -> . MINUS
    (92) unary_op -> . NOT
    (51) literal -> . INTEGER
    (52) literal -> . FLOAT
    (53) literal -> . STRING
    (54) literal -> . NULL
    (55) literal -> . FALSE
    (56) literal -> . TRUE
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 67
    NEW             shift and go to state 87
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    NOT             shift and go to state 110
    INTEGER         shift and go to state 88
    FLOAT           shift and go to state 111
    STRING          shift and go to state 89
    NULL            shift and go to state 90
    FALSE           shift and go to state 91
    TRUE            shift and go to state 92
    ID              shift and go to state 105

    expression                     shift and go to state 161
    primary                        shift and go to state 102
    assign                         shift and go to state 103
    unary_op                       shift and go to state 104
    literal                        shift and go to state 84
    method_invocation              shift and go to state 106
    lhs                            shift and go to state 107
    field_access                   shift and go to state 80

state 155

    (67) method_invocation -> field_access LPAREN arguments RPAREN .

    SEMICOLON       reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    DOT             reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    PLUS            reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    MINUS           reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    TIMES           reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    GREATER         reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    LESS            reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    GREATEREQ       reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    LESSEQ          reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    EQUAL           reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    NOTEQUAL        reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    AND             reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    OR              reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)
    COMMA           reduce using rule 67 (method_invocation -> field_access LPAREN arguments RPAREN .)


state 156

    (66) arguments -> expression COMMA . arguments
    (65) arguments -> . expression
    (66) arguments -> . expression COMMA arguments
    (69) expression -> . primary
    (70) expression -> . assign
    (71) expression -> . expression arith_op expression
    (72) expression -> . expression bool_op expression
    (73) expression -> . unary_op expression
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . LPAREN expression RPAREN
    (61) primary -> . NEW ID LPAREN RPAREN
    (62) primary -> . NEW ID LPAREN arguments RPAREN
    (63) primary -> . method_invocation
    (64) primary -> . lhs
    (77) assign -> . lhs SETEQUAL expression
    (90) unary_op -> . PLUS
    (91) unary_op -> . MINUS
    (92) unary_op -> . NOT
    (51) literal -> . INTEGER
    (52) literal -> . FLOAT
    (53) literal -> . STRING
    (54) literal -> . NULL
    (55) literal -> . FALSE
    (56) literal -> . TRUE
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID

    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 67
    NEW             shift and go to state 87
    PLUS            shift and go to state 108
    MINUS           shift and go to state 109
    NOT             shift and go to state 110
    INTEGER         shift and go to state 88
    FLOAT           shift and go to state 111
    STRING          shift and go to state 89
    NULL            shift and go to state 90
    FALSE           shift and go to state 91
    TRUE            shift and go to state 92
    ID              shift and go to state 105

    expression                     shift and go to state 147
    arguments                      shift and go to state 162
    primary                        shift and go to state 102
    assign                         shift and go to state 103
    unary_op                       shift and go to state 104
    literal                        shift and go to state 84
    method_invocation              shift and go to state 106
    lhs                            shift and go to state 107
    field_access                   shift and go to state 80

state 157

    (61) primary -> NEW ID LPAREN RPAREN .

    DOT             reduce using rule 61 (primary -> NEW ID LPAREN RPAREN .)
    RPAREN          reduce using rule 61 (primary -> NEW ID LPAREN RPAREN .)
    PLUS            reduce using rule 61 (primary -> NEW ID LPAREN RPAREN .)
    MINUS           reduce using rule 61 (primary -> NEW ID LPAREN RPAREN .)
    TIMES           reduce using rule 61 (primary -> NEW ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 61 (primary -> NEW ID LPAREN RPAREN .)
    GREATER         reduce using rule 61 (primary -> NEW ID LPAREN RPAREN .)
    LESS            reduce using rule 61 (primary -> NEW ID LPAREN RPAREN .)
    GREATEREQ       reduce using rule 61 (primary -> NEW ID LPAREN RPAREN .)
    LESSEQ          reduce using rule 61 (primary -> NEW ID LPAREN RPAREN .)
    EQUAL           reduce using rule 61 (primary -> NEW ID LPAREN RPAREN .)
    NOTEQUAL        reduce using rule 61 (primary -> NEW ID LPAREN RPAREN .)
    AND             reduce using rule 61 (primary -> NEW ID LPAREN RPAREN .)
    OR              reduce using rule 61 (primary -> NEW ID LPAREN RPAREN .)
    SEMICOLON       reduce using rule 61 (primary -> NEW ID LPAREN RPAREN .)
    COMMA           reduce using rule 61 (primary -> NEW ID LPAREN RPAREN .)


state 158

    (62) primary -> NEW ID LPAREN arguments . RPAREN

    RPAREN          shift and go to state 163


state 159

    (39) stmt -> IF LPAREN expression RPAREN stmt .
    (40) stmt -> IF LPAREN expression RPAREN stmt . ELSE stmt

  ! shift/reduce conflict for ELSE resolved as shift
    RCURLY          reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt .)
    IF              reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt .)
    WHILE           reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt .)
    FOR             reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt .)
    RETURN          reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt .)
    BREAK           reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt .)
    CONTINUE        reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt .)
    SEMICOLON       reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt .)
    LCURLY          reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt .)
    INT             reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt .)
    FLOAT           reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt .)
    BOOLEAN         reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt .)
    ID              reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt .)
    THIS            reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt .)
    SUPER           reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt .)
    LPAREN          reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt .)
    NEW             reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt .)
    INTEGER         reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt .)
    STRING          reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt .)
    NULL            reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt .)
    FALSE           reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt .)
    TRUE            reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt .)
    ELSE            shift and go to state 164

  ! ELSE            [ reduce using rule 39 (stmt -> IF LPAREN expression RPAREN stmt .) ]


state 160

    (41) stmt -> WHILE LPAREN expression RPAREN stmt .

    RCURLY          reduce using rule 41 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    IF              reduce using rule 41 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    WHILE           reduce using rule 41 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    FOR             reduce using rule 41 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    RETURN          reduce using rule 41 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    BREAK           reduce using rule 41 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    CONTINUE        reduce using rule 41 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    SEMICOLON       reduce using rule 41 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    LCURLY          reduce using rule 41 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    INT             reduce using rule 41 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    FLOAT           reduce using rule 41 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    BOOLEAN         reduce using rule 41 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    ID              reduce using rule 41 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    THIS            reduce using rule 41 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    SUPER           reduce using rule 41 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    LPAREN          reduce using rule 41 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    NEW             reduce using rule 41 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    INTEGER         reduce using rule 41 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    STRING          reduce using rule 41 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    NULL            reduce using rule 41 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    FALSE           reduce using rule 41 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    TRUE            reduce using rule 41 (stmt -> WHILE LPAREN expression RPAREN stmt .)
    ELSE            reduce using rule 41 (stmt -> WHILE LPAREN expression RPAREN stmt .)


state 161

    (42) stmt -> FOR LPAREN stmt_expression SEMICOLON expression . SEMICOLON stmt_expression RPAREN block
    (71) expression -> expression . arith_op expression
    (72) expression -> expression . bool_op expression
    (78) arith_op -> . PLUS
    (79) arith_op -> . MINUS
    (80) arith_op -> . TIMES
    (81) arith_op -> . DIVIDE
    (82) bool_op -> . GREATER
    (83) bool_op -> . LESS
    (84) bool_op -> . GREATEREQ
    (85) bool_op -> . LESSEQ
    (86) bool_op -> . EQUAL
    (87) bool_op -> . NOTEQUAL
    (88) bool_op -> . AND
    (89) bool_op -> . OR

    SEMICOLON       shift and go to state 165
    PLUS            shift and go to state 128
    MINUS           shift and go to state 129
    TIMES           shift and go to state 130
    DIVIDE          shift and go to state 131
    GREATER         shift and go to state 132
    LESS            shift and go to state 133
    GREATEREQ       shift and go to state 134
    LESSEQ          shift and go to state 135
    EQUAL           shift and go to state 136
    NOTEQUAL        shift and go to state 137
    AND             shift and go to state 138
    OR              shift and go to state 139

    arith_op                       shift and go to state 126
    bool_op                        shift and go to state 127

state 162

    (66) arguments -> expression COMMA arguments .

    RPAREN          reduce using rule 66 (arguments -> expression COMMA arguments .)


state 163

    (62) primary -> NEW ID LPAREN arguments RPAREN .

    DOT             reduce using rule 62 (primary -> NEW ID LPAREN arguments RPAREN .)
    RPAREN          reduce using rule 62 (primary -> NEW ID LPAREN arguments RPAREN .)
    PLUS            reduce using rule 62 (primary -> NEW ID LPAREN arguments RPAREN .)
    MINUS           reduce using rule 62 (primary -> NEW ID LPAREN arguments RPAREN .)
    TIMES           reduce using rule 62 (primary -> NEW ID LPAREN arguments RPAREN .)
    DIVIDE          reduce using rule 62 (primary -> NEW ID LPAREN arguments RPAREN .)
    GREATER         reduce using rule 62 (primary -> NEW ID LPAREN arguments RPAREN .)
    LESS            reduce using rule 62 (primary -> NEW ID LPAREN arguments RPAREN .)
    GREATEREQ       reduce using rule 62 (primary -> NEW ID LPAREN arguments RPAREN .)
    LESSEQ          reduce using rule 62 (primary -> NEW ID LPAREN arguments RPAREN .)
    EQUAL           reduce using rule 62 (primary -> NEW ID LPAREN arguments RPAREN .)
    NOTEQUAL        reduce using rule 62 (primary -> NEW ID LPAREN arguments RPAREN .)
    AND             reduce using rule 62 (primary -> NEW ID LPAREN arguments RPAREN .)
    OR              reduce using rule 62 (primary -> NEW ID LPAREN arguments RPAREN .)
    SEMICOLON       reduce using rule 62 (primary -> NEW ID LPAREN arguments RPAREN .)
    COMMA           reduce using rule 62 (primary -> NEW ID LPAREN arguments RPAREN .)


state 164

    (40) stmt -> IF LPAREN expression RPAREN stmt ELSE . stmt
    (39) stmt -> . IF LPAREN expression RPAREN stmt
    (40) stmt -> . IF LPAREN expression RPAREN stmt ELSE stmt
    (41) stmt -> . WHILE LPAREN expression RPAREN stmt
    (42) stmt -> . FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block
    (43) stmt -> . RETURN expression SEMICOLON
    (44) stmt -> . RETURN SEMICOLON
    (45) stmt -> . stmt_expression SEMICOLON
    (46) stmt -> . BREAK SEMICOLON
    (47) stmt -> . CONTINUE SEMICOLON
    (48) stmt -> . block
    (49) stmt -> . var_decl
    (50) stmt -> . SEMICOLON
    (93) stmt_expression -> . assign
    (94) stmt_expression -> . method_invocation
    (35) block -> . LCURLY stmtlist RCURLY
    (36) block -> . empty
    (18) var_decl -> . type variables SEMICOLON
    (77) assign -> . lhs SETEQUAL expression
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (95) empty -> .
    (19) type -> . INT
    (20) type -> . FLOAT
    (21) type -> . BOOLEAN
    (22) type -> . ID
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . LPAREN expression RPAREN
    (61) primary -> . NEW ID LPAREN RPAREN
    (62) primary -> . NEW ID LPAREN arguments RPAREN
    (63) primary -> . method_invocation
    (64) primary -> . lhs
    (51) literal -> . INTEGER
    (52) literal -> . FLOAT
    (53) literal -> . STRING
    (54) literal -> . NULL
    (55) literal -> . FALSE
    (56) literal -> . TRUE

  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FOR resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for BREAK resolved as shift
  ! shift/reduce conflict for CONTINUE resolved as shift
  ! shift/reduce conflict for SEMICOLON resolved as shift
  ! shift/reduce conflict for LCURLY resolved as shift
  ! shift/reduce conflict for INT resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for BOOLEAN resolved as shift
  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for THIS resolved as shift
  ! shift/reduce conflict for SUPER resolved as shift
  ! shift/reduce conflict for LPAREN resolved as shift
  ! shift/reduce conflict for NEW resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for STRING resolved as shift
  ! shift/reduce conflict for NULL resolved as shift
  ! shift/reduce conflict for FALSE resolved as shift
  ! shift/reduce conflict for TRUE resolved as shift
    IF              shift and go to state 66
    WHILE           shift and go to state 68
    FOR             shift and go to state 69
    RETURN          shift and go to state 73
    BREAK           shift and go to state 74
    CONTINUE        shift and go to state 75
    SEMICOLON       shift and go to state 71
    LCURLY          shift and go to state 55
    ELSE            reduce using rule 95 (empty -> .)
    RCURLY          reduce using rule 95 (empty -> .)
    INT             shift and go to state 19
    FLOAT           shift and go to state 81
    BOOLEAN         shift and go to state 21
    ID              shift and go to state 82
    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 67
    NEW             shift and go to state 87
    INTEGER         shift and go to state 88
    STRING          shift and go to state 89
    NULL            shift and go to state 90
    FALSE           shift and go to state 91
    TRUE            shift and go to state 92

  ! IF              [ reduce using rule 95 (empty -> .) ]
  ! WHILE           [ reduce using rule 95 (empty -> .) ]
  ! FOR             [ reduce using rule 95 (empty -> .) ]
  ! RETURN          [ reduce using rule 95 (empty -> .) ]
  ! BREAK           [ reduce using rule 95 (empty -> .) ]
  ! CONTINUE        [ reduce using rule 95 (empty -> .) ]
  ! SEMICOLON       [ reduce using rule 95 (empty -> .) ]
  ! LCURLY          [ reduce using rule 95 (empty -> .) ]
  ! INT             [ reduce using rule 95 (empty -> .) ]
  ! FLOAT           [ reduce using rule 95 (empty -> .) ]
  ! BOOLEAN         [ reduce using rule 95 (empty -> .) ]
  ! ID              [ reduce using rule 95 (empty -> .) ]
  ! THIS            [ reduce using rule 95 (empty -> .) ]
  ! SUPER           [ reduce using rule 95 (empty -> .) ]
  ! LPAREN          [ reduce using rule 95 (empty -> .) ]
  ! NEW             [ reduce using rule 95 (empty -> .) ]
  ! INTEGER         [ reduce using rule 95 (empty -> .) ]
  ! STRING          [ reduce using rule 95 (empty -> .) ]
  ! NULL            [ reduce using rule 95 (empty -> .) ]
  ! FALSE           [ reduce using rule 95 (empty -> .) ]
  ! TRUE            [ reduce using rule 95 (empty -> .) ]

    stmt                           shift and go to state 166
    stmt_expression                shift and go to state 70
    block                          shift and go to state 72
    var_decl                       shift and go to state 76
    assign                         shift and go to state 77
    method_invocation              shift and go to state 78
    empty                          shift and go to state 56
    type                           shift and go to state 15
    lhs                            shift and go to state 79
    field_access                   shift and go to state 80
    primary                        shift and go to state 83
    literal                        shift and go to state 84

state 165

    (42) stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON . stmt_expression RPAREN block
    (93) stmt_expression -> . assign
    (94) stmt_expression -> . method_invocation
    (77) assign -> . lhs SETEQUAL expression
    (67) method_invocation -> . field_access LPAREN arguments RPAREN
    (68) method_invocation -> . field_access LPAREN RPAREN
    (74) lhs -> . field_access
    (75) field_access -> . primary DOT ID
    (76) field_access -> . ID
    (57) primary -> . literal
    (58) primary -> . THIS
    (59) primary -> . SUPER
    (60) primary -> . LPAREN expression RPAREN
    (61) primary -> . NEW ID LPAREN RPAREN
    (62) primary -> . NEW ID LPAREN arguments RPAREN
    (63) primary -> . method_invocation
    (64) primary -> . lhs
    (51) literal -> . INTEGER
    (52) literal -> . FLOAT
    (53) literal -> . STRING
    (54) literal -> . NULL
    (55) literal -> . FALSE
    (56) literal -> . TRUE

    ID              shift and go to state 105
    THIS            shift and go to state 85
    SUPER           shift and go to state 86
    LPAREN          shift and go to state 67
    NEW             shift and go to state 87
    INTEGER         shift and go to state 88
    FLOAT           shift and go to state 111
    STRING          shift and go to state 89
    NULL            shift and go to state 90
    FALSE           shift and go to state 91
    TRUE            shift and go to state 92

    stmt_expression                shift and go to state 167
    assign                         shift and go to state 77
    method_invocation              shift and go to state 78
    lhs                            shift and go to state 79
    field_access                   shift and go to state 80
    primary                        shift and go to state 83
    literal                        shift and go to state 84

state 166

    (40) stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .

    RCURLY          reduce using rule 40 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    IF              reduce using rule 40 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    WHILE           reduce using rule 40 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    FOR             reduce using rule 40 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    RETURN          reduce using rule 40 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    BREAK           reduce using rule 40 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    CONTINUE        reduce using rule 40 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    SEMICOLON       reduce using rule 40 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    LCURLY          reduce using rule 40 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    INT             reduce using rule 40 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    FLOAT           reduce using rule 40 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    BOOLEAN         reduce using rule 40 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    ID              reduce using rule 40 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    THIS            reduce using rule 40 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    SUPER           reduce using rule 40 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    LPAREN          reduce using rule 40 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    NEW             reduce using rule 40 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    INTEGER         reduce using rule 40 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    STRING          reduce using rule 40 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    NULL            reduce using rule 40 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    FALSE           reduce using rule 40 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    TRUE            reduce using rule 40 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)
    ELSE            reduce using rule 40 (stmt -> IF LPAREN expression RPAREN stmt ELSE stmt .)


state 167

    (42) stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression . RPAREN block

    RPAREN          shift and go to state 168


state 168

    (42) stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN . block
    (35) block -> . LCURLY stmtlist RCURLY
    (36) block -> . empty
    (95) empty -> .

  ! shift/reduce conflict for LCURLY resolved as shift
    LCURLY          shift and go to state 55
    RCURLY          reduce using rule 95 (empty -> .)
    IF              reduce using rule 95 (empty -> .)
    WHILE           reduce using rule 95 (empty -> .)
    FOR             reduce using rule 95 (empty -> .)
    RETURN          reduce using rule 95 (empty -> .)
    BREAK           reduce using rule 95 (empty -> .)
    CONTINUE        reduce using rule 95 (empty -> .)
    SEMICOLON       reduce using rule 95 (empty -> .)
    INT             reduce using rule 95 (empty -> .)
    FLOAT           reduce using rule 95 (empty -> .)
    BOOLEAN         reduce using rule 95 (empty -> .)
    ID              reduce using rule 95 (empty -> .)
    THIS            reduce using rule 95 (empty -> .)
    SUPER           reduce using rule 95 (empty -> .)
    LPAREN          reduce using rule 95 (empty -> .)
    NEW             reduce using rule 95 (empty -> .)
    INTEGER         reduce using rule 95 (empty -> .)
    STRING          reduce using rule 95 (empty -> .)
    NULL            reduce using rule 95 (empty -> .)
    FALSE           reduce using rule 95 (empty -> .)
    TRUE            reduce using rule 95 (empty -> .)
    ELSE            reduce using rule 95 (empty -> .)

  ! LCURLY          [ reduce using rule 95 (empty -> .) ]

    block                          shift and go to state 169
    empty                          shift and go to state 56

state 169

    (42) stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block .

    RCURLY          reduce using rule 42 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block .)
    IF              reduce using rule 42 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block .)
    WHILE           reduce using rule 42 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block .)
    FOR             reduce using rule 42 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block .)
    RETURN          reduce using rule 42 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block .)
    BREAK           reduce using rule 42 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block .)
    CONTINUE        reduce using rule 42 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block .)
    SEMICOLON       reduce using rule 42 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block .)
    LCURLY          reduce using rule 42 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block .)
    INT             reduce using rule 42 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block .)
    FLOAT           reduce using rule 42 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block .)
    BOOLEAN         reduce using rule 42 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block .)
    ID              reduce using rule 42 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block .)
    THIS            reduce using rule 42 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block .)
    SUPER           reduce using rule 42 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block .)
    LPAREN          reduce using rule 42 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block .)
    NEW             reduce using rule 42 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block .)
    INTEGER         reduce using rule 42 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block .)
    STRING          reduce using rule 42 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block .)
    NULL            reduce using rule 42 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block .)
    FALSE           reduce using rule 42 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block .)
    TRUE            reduce using rule 42 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block .)
    ELSE            reduce using rule 42 (stmt -> FOR LPAREN stmt_expression SEMICOLON expression SEMICOLON stmt_expression RPAREN block .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PUBLIC in state 5 resolved as shift
WARNING: shift/reduce conflict for PRIVATE in state 5 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 5 resolved as shift
WARNING: shift/reduce conflict for INT in state 5 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 5 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 5 resolved as shift
WARNING: shift/reduce conflict for ID in state 5 resolved as shift
WARNING: shift/reduce conflict for PUBLIC in state 37 resolved as shift
WARNING: shift/reduce conflict for PRIVATE in state 37 resolved as shift
WARNING: shift/reduce conflict for STATIC in state 37 resolved as shift
WARNING: shift/reduce conflict for INT in state 37 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 37 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 37 resolved as shift
WARNING: shift/reduce conflict for ID in state 37 resolved as shift
WARNING: shift/reduce conflict for IF in state 55 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 55 resolved as shift
WARNING: shift/reduce conflict for FOR in state 55 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 55 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 55 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 55 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 55 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 55 resolved as shift
WARNING: shift/reduce conflict for INT in state 55 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 55 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 55 resolved as shift
WARNING: shift/reduce conflict for ID in state 55 resolved as shift
WARNING: shift/reduce conflict for THIS in state 55 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 55 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 55 resolved as shift
WARNING: shift/reduce conflict for NEW in state 55 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 55 resolved as shift
WARNING: shift/reduce conflict for STRING in state 55 resolved as shift
WARNING: shift/reduce conflict for NULL in state 55 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 55 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 55 resolved as shift
WARNING: shift/reduce conflict for RCURLY in state 64 resolved as shift
WARNING: shift/reduce conflict for IF in state 64 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 64 resolved as shift
WARNING: shift/reduce conflict for FOR in state 64 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 64 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 64 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 64 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 64 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 64 resolved as shift
WARNING: shift/reduce conflict for INT in state 64 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 64 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 64 resolved as shift
WARNING: shift/reduce conflict for ID in state 64 resolved as shift
WARNING: shift/reduce conflict for THIS in state 64 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 64 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 64 resolved as shift
WARNING: shift/reduce conflict for NEW in state 64 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 64 resolved as shift
WARNING: shift/reduce conflict for STRING in state 64 resolved as shift
WARNING: shift/reduce conflict for NULL in state 64 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 64 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 64 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 140 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 140 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 140 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 140 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 140 resolved as shift
WARNING: shift/reduce conflict for LESS in state 140 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 140 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 140 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 140 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 140 resolved as shift
WARNING: shift/reduce conflict for AND in state 140 resolved as shift
WARNING: shift/reduce conflict for OR in state 140 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 144 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 144 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 144 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 144 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 144 resolved as shift
WARNING: shift/reduce conflict for LESS in state 144 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 144 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 144 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 144 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 144 resolved as shift
WARNING: shift/reduce conflict for AND in state 144 resolved as shift
WARNING: shift/reduce conflict for OR in state 144 resolved as shift
WARNING: shift/reduce conflict for IF in state 150 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 150 resolved as shift
WARNING: shift/reduce conflict for FOR in state 150 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 150 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 150 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 150 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 150 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 150 resolved as shift
WARNING: shift/reduce conflict for INT in state 150 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 150 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 150 resolved as shift
WARNING: shift/reduce conflict for ID in state 150 resolved as shift
WARNING: shift/reduce conflict for THIS in state 150 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 150 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 150 resolved as shift
WARNING: shift/reduce conflict for NEW in state 150 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 150 resolved as shift
WARNING: shift/reduce conflict for STRING in state 150 resolved as shift
WARNING: shift/reduce conflict for NULL in state 150 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 150 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 150 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 151 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 151 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 151 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 151 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 151 resolved as shift
WARNING: shift/reduce conflict for LESS in state 151 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 151 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 151 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 151 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 151 resolved as shift
WARNING: shift/reduce conflict for AND in state 151 resolved as shift
WARNING: shift/reduce conflict for OR in state 151 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 152 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 152 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 152 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 152 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 152 resolved as shift
WARNING: shift/reduce conflict for LESS in state 152 resolved as shift
WARNING: shift/reduce conflict for GREATEREQ in state 152 resolved as shift
WARNING: shift/reduce conflict for LESSEQ in state 152 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 152 resolved as shift
WARNING: shift/reduce conflict for NOTEQUAL in state 152 resolved as shift
WARNING: shift/reduce conflict for AND in state 152 resolved as shift
WARNING: shift/reduce conflict for OR in state 152 resolved as shift
WARNING: shift/reduce conflict for IF in state 153 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 153 resolved as shift
WARNING: shift/reduce conflict for FOR in state 153 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 153 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 153 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 153 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 153 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 153 resolved as shift
WARNING: shift/reduce conflict for INT in state 153 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 153 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 153 resolved as shift
WARNING: shift/reduce conflict for ID in state 153 resolved as shift
WARNING: shift/reduce conflict for THIS in state 153 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 153 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 153 resolved as shift
WARNING: shift/reduce conflict for NEW in state 153 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 153 resolved as shift
WARNING: shift/reduce conflict for STRING in state 153 resolved as shift
WARNING: shift/reduce conflict for NULL in state 153 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 153 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 153 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 159 resolved as shift
WARNING: shift/reduce conflict for IF in state 164 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 164 resolved as shift
WARNING: shift/reduce conflict for FOR in state 164 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 164 resolved as shift
WARNING: shift/reduce conflict for BREAK in state 164 resolved as shift
WARNING: shift/reduce conflict for CONTINUE in state 164 resolved as shift
WARNING: shift/reduce conflict for SEMICOLON in state 164 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 164 resolved as shift
WARNING: shift/reduce conflict for INT in state 164 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 164 resolved as shift
WARNING: shift/reduce conflict for BOOLEAN in state 164 resolved as shift
WARNING: shift/reduce conflict for ID in state 164 resolved as shift
WARNING: shift/reduce conflict for THIS in state 164 resolved as shift
WARNING: shift/reduce conflict for SUPER in state 164 resolved as shift
WARNING: shift/reduce conflict for LPAREN in state 164 resolved as shift
WARNING: shift/reduce conflict for NEW in state 164 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 164 resolved as shift
WARNING: shift/reduce conflict for STRING in state 164 resolved as shift
WARNING: shift/reduce conflict for NULL in state 164 resolved as shift
WARNING: shift/reduce conflict for FALSE in state 164 resolved as shift
WARNING: shift/reduce conflict for TRUE in state 164 resolved as shift
WARNING: shift/reduce conflict for LCURLY in state 168 resolved as shift
